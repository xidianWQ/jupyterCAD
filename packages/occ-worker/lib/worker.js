/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
define(() => { return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@jupyter/ydoc/lib/api.js"
/*!***************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/api.js ***!
  \***************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/api.js?\n}");

/***/ },

/***/ "../../node_modules/@jupyter/ydoc/lib/awareness.js"
/*!*********************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/awareness.js ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/awareness.js?\n}");

/***/ },

/***/ "../../node_modules/@jupyter/ydoc/lib/index.js"
/*!*****************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/index.js ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   YBaseCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YBaseCell),\n/* harmony export */   YCodeCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YCodeCell),\n/* harmony export */   YDocument: () => (/* reexport safe */ _ydocument_js__WEBPACK_IMPORTED_MODULE_4__.YDocument),\n/* harmony export */   YFile: () => (/* reexport safe */ _yfile_js__WEBPACK_IMPORTED_MODULE_5__.YFile),\n/* harmony export */   YMarkdownCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YMarkdownCell),\n/* harmony export */   YNotebook: () => (/* reexport safe */ _ynotebook_js__WEBPACK_IMPORTED_MODULE_6__.YNotebook),\n/* harmony export */   YRawCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YRawCell),\n/* harmony export */   convertYMapEventToMapChange: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.convertYMapEventToMapChange),\n/* harmony export */   createMutex: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.createMutex),\n/* harmony export */   createStandaloneCell: () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.createStandaloneCell)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"../../node_modules/@jupyter/ydoc/lib/api.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../../node_modules/@jupyter/ydoc/lib/utils.js\");\n/* harmony import */ var _awareness_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./awareness.js */ \"../../node_modules/@jupyter/ydoc/lib/awareness.js\");\n/* harmony import */ var _ytext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ytext.js */ \"../../node_modules/@jupyter/ydoc/lib/ytext.js\");\n/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ydocument.js */ \"../../node_modules/@jupyter/ydoc/lib/ydocument.js\");\n/* harmony import */ var _yfile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./yfile.js */ \"../../node_modules/@jupyter/ydoc/lib/yfile.js\");\n/* harmony import */ var _ynotebook_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ynotebook.js */ \"../../node_modules/@jupyter/ydoc/lib/ynotebook.js\");\n/* harmony import */ var _ycell_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ycell.js */ \"../../node_modules/@jupyter/ydoc/lib/ycell.js\");\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module ydoc\n */\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/index.js?\n}");

/***/ },

/***/ "../../node_modules/@jupyter/ydoc/lib/utils.js"
/*!*****************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/utils.js ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertYMapEventToMapChange: () => (/* binding */ convertYMapEventToMapChange),\n/* harmony export */   createMutex: () => (/* binding */ createMutex)\n/* harmony export */ });\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nfunction convertYMapEventToMapChange(event) {\n    let changes = new Map();\n    event.changes.keys.forEach((event, key) => {\n        changes.set(key, {\n            action: event.action,\n            oldValue: event.oldValue,\n            newValue: this.ymeta.get(key)\n        });\n    });\n    return changes;\n}\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n */\nconst createMutex = () => {\n    let token = true;\n    return (f) => {\n        if (token) {\n            token = false;\n            try {\n                f();\n            }\n            finally {\n                token = true;\n            }\n        }\n    };\n};\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/utils.js?\n}");

/***/ },

/***/ "../../node_modules/@jupyter/ydoc/lib/ycell.js"
/*!*****************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/ycell.js ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   YBaseCell: () => (/* binding */ YBaseCell),\n/* harmony export */   YCodeCell: () => (/* binding */ YCodeCell),\n/* harmony export */   YMarkdownCell: () => (/* binding */ YMarkdownCell),\n/* harmony export */   YRawCell: () => (/* binding */ YRawCell),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createCellModelFromSharedType: () => (/* binding */ createCellModelFromSharedType),\n/* harmony export */   createStandaloneCell: () => (/* binding */ createStandaloneCell)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"../../node_modules/@lumino/coreutils/dist/index.js\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ \"../../node_modules/@lumino/signaling/dist/index.es6.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness */ \"../../node_modules/y-protocols/awareness.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"../../node_modules/yjs/dist/yjs.mjs\");\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n\n/**\n * Create a new shared cell model given the YJS shared type.\n */\nconst createCellModelFromSharedType = (type, options = {}) => {\n    switch (type.get('cell_type')) {\n        case 'code':\n            return new YCodeCell(type, type.get('source'), type.get('outputs'), options);\n        case 'markdown':\n            return new YMarkdownCell(type, type.get('source'), options);\n        case 'raw':\n            return new YRawCell(type, type.get('source'), options);\n        default:\n            throw new Error('Found unknown cell type');\n    }\n};\n/**\n * Create a new cell that can be inserted in an existing shared model.\n *\n * If no notebook is specified the cell will be standalone.\n *\n * @param cell Cell JSON representation\n * @param notebook Notebook to which the cell will be added\n */\nconst createCell = (cell, notebook) => {\n    var _a, _b;\n    const ymodel = new yjs__WEBPACK_IMPORTED_MODULE_3__.Map();\n    const ysource = new yjs__WEBPACK_IMPORTED_MODULE_3__.Text();\n    const ymetadata = new yjs__WEBPACK_IMPORTED_MODULE_3__.Map();\n    ymodel.set('source', ysource);\n    ymodel.set('metadata', ymetadata);\n    ymodel.set('cell_type', cell.cell_type);\n    ymodel.set('id', (_a = cell.id) !== null && _a !== void 0 ? _a : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4());\n    let ycell;\n    switch (cell.cell_type) {\n        case 'markdown': {\n            ycell = new YMarkdownCell(ymodel, ysource, { notebook }, ymetadata);\n            if (cell.attachments != null) {\n                ycell.setAttachments(cell.attachments);\n            }\n            break;\n        }\n        case 'code': {\n            const youtputs = new yjs__WEBPACK_IMPORTED_MODULE_3__.Array();\n            ymodel.set('outputs', youtputs);\n            ycell = new YCodeCell(ymodel, ysource, youtputs, {\n                notebook\n            }, ymetadata);\n            const cCell = cell;\n            ycell.execution_count = (_b = cCell.execution_count) !== null && _b !== void 0 ? _b : null;\n            if (cCell.outputs) {\n                ycell.setOutputs(cCell.outputs);\n            }\n            break;\n        }\n        default: {\n            // raw\n            ycell = new YRawCell(ymodel, ysource, { notebook }, ymetadata);\n            if (cell.attachments) {\n                ycell.setAttachments(cell.attachments);\n            }\n            break;\n        }\n    }\n    if (cell.metadata != null) {\n        ycell.setMetadata(cell.metadata);\n    }\n    if (cell.source != null) {\n        ycell.setSource(typeof cell.source === 'string' ? cell.source : cell.source.join(''));\n    }\n    return ycell;\n};\n/**\n * Create a new cell that cannot be inserted in an existing shared model.\n *\n * @param cell Cell JSON representation\n */\nconst createStandaloneCell = (cell) => createCell(cell);\nclass YBaseCell {\n    /**\n     * Create a new YCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static create(id) {\n        return createCell({ id, cell_type: this.prototype.cell_type });\n    }\n    /**\n     * Base cell constructor\n     *\n     * ### Notes\n     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``\n     *\n     * The ``ysource`` is needed because ``ymodel.get('source')`` will\n     * not return the real source if the model is not yet attached to\n     * a document. Requesting it explicitly allows to introspect a non-empty\n     * source before the cell is attached to the document.\n     *\n     * @param ymodel Cell map\n     * @param ysource Cell source\n     * @param options \\{ notebook?: The notebook the cell is attached to \\}\n     * @param ymetadata Cell metadata\n     */\n    constructor(ymodel, ysource, options = {}, ymetadata) {\n        /**\n         * Handle a change to the ymodel.\n         */\n        this._modelObserver = (events, transaction) => {\n            if (transaction.origin !== 'silent-change') {\n                this._changed.emit(this.getChanges(events));\n            }\n        };\n        this._metadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        /**\n         * The notebook that this cell belongs to.\n         */\n        this._notebook = null;\n        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        this._isDisposed = false;\n        this._undoManager = null;\n        this.ymodel = ymodel;\n        this._ysource = ysource;\n        this._ymetadata = ymetadata !== null && ymetadata !== void 0 ? ymetadata : this.ymodel.get('metadata');\n        this._prevSourceLength = ysource ? ysource.length : 0;\n        this._notebook = null;\n        this._awareness = null;\n        this._undoManager = null;\n        if (options.notebook) {\n            this._notebook = options.notebook;\n            if (this._notebook.disableDocumentWideUndoRedo) {\n                this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([this.ymodel], {\n                    trackedOrigins: new Set([this]),\n                    doc: this._notebook.ydoc\n                });\n            }\n        }\n        else {\n            // Standalone cell\n            const doc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();\n            doc.getArray().insert(0, [this.ymodel]);\n            this._awareness = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__.Awareness(doc);\n            this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([this.ymodel], {\n                trackedOrigins: new Set([this])\n            });\n        }\n        this.ymodel.observeDeep(this._modelObserver);\n    }\n    /**\n     * Cell notebook awareness or null.\n     */\n    get awareness() {\n        var _a, _b, _c;\n        return (_c = (_a = this._awareness) !== null && _a !== void 0 ? _a : (_b = this.notebook) === null || _b === void 0 ? void 0 : _b.awareness) !== null && _c !== void 0 ? _c : null;\n    }\n    /**\n     * The type of the cell.\n     */\n    get cell_type() {\n        throw new Error('A YBaseCell must not be constructed');\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Signal emitted when the cell is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Cell id\n     */\n    get id() {\n        return this.getId();\n    }\n    /**\n     * Whether the model has been disposed or not.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Whether the cell is standalone or not.\n     *\n     * If the cell is standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    get isStandalone() {\n        return this._notebook !== null;\n    }\n    /**\n     * Cell metadata.\n     *\n     * #### Notes\n     * You should prefer to access and modify the specific key of interest.\n     */\n    get metadata() {\n        return this.getMetadata();\n    }\n    set metadata(v) {\n        this.setMetadata(v);\n    }\n    /**\n     * Signal triggered when the cell metadata changes.\n     */\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    /**\n     * The notebook that this cell belongs to.\n     */\n    get notebook() {\n        return this._notebook;\n    }\n    /**\n     * Cell input content.\n     */\n    get source() {\n        return this.getSource();\n    }\n    set source(v) {\n        this.setSource(v);\n    }\n    /**\n     * The cell undo manager.\n     */\n    get undoManager() {\n        var _a;\n        if (!this.notebook) {\n            return this._undoManager;\n        }\n        return ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.disableDocumentWideUndoRedo)\n            ? this._undoManager\n            : this.notebook.undoManager;\n    }\n    get ysource() {\n        return this._ysource;\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    canUndo() {\n        return !!this.undoManager && this.undoManager.undoStack.length > 0;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    canRedo() {\n        return !!this.undoManager && this.undoManager.redoStack.length > 0;\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndoHistory() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.redo();\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        var _a;\n        if (this._isDisposed)\n            return;\n        this._isDisposed = true;\n        this.ymodel.unobserveDeep(this._modelObserver);\n        if (this._awareness) {\n            // A new document is created for standalone cell.\n            const doc = this._awareness.doc;\n            this._awareness.destroy();\n            doc.destroy();\n        }\n        if (this._undoManager) {\n            // Be sure to not destroy the document undo manager.\n            if (this._undoManager === ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.undoManager)) {\n                this._undoManager = null;\n            }\n            else {\n                this._undoManager.destroy();\n            }\n        }\n        this._disposed.emit();\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);\n    }\n    /**\n     * Get cell id.\n     *\n     * @returns Cell id\n     */\n    getId() {\n        return this.ymodel.get('id');\n    }\n    /**\n     * Gets cell's source.\n     *\n     * @returns Cell's source.\n     */\n    getSource() {\n        return this.ysource.toString();\n    }\n    /**\n     * Sets cell's source.\n     *\n     * @param value: New source.\n     */\n    setSource(value) {\n        this.transact(() => {\n            this.ysource.delete(0, this.ysource.length);\n            this.ysource.insert(0, value);\n        });\n        // @todo Do we need proper replace semantic? This leads to issues in editor bindings because they don't switch source.\n        // this.ymodel.set('source', new Y.Text(value));\n    }\n    /**\n     * Replace content from `start' to `end` with `value`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param value: New source (optional).\n     */\n    updateSource(start, end, value = '') {\n        this.transact(() => {\n            const ysource = this.ysource;\n            // insert and then delete.\n            // This ensures that the cursor position is adjusted after the replaced content.\n            ysource.insert(start, value);\n            ysource.delete(start + value.length, end - start);\n        });\n    }\n    /**\n     * Delete a metadata cell.\n     *\n     * @param key The key to delete\n     */\n    deleteMetadata(key) {\n        if (typeof this.getMetadata(key) === 'undefined') {\n            return;\n        }\n        this.transact(() => {\n            this._ymetadata.delete(key);\n            const jupyter = this.getMetadata('jupyter');\n            if (key === 'collapsed' && jupyter) {\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const { outputs_hidden, ...others } = jupyter;\n                if (Object.keys(others).length === 0) {\n                    this._ymetadata.delete('jupyter');\n                }\n                else {\n                    this._ymetadata.set('jupyter', others);\n                }\n            }\n            else if (key === 'jupyter') {\n                this._ymetadata.delete('collapsed');\n            }\n        }, false);\n    }\n    getMetadata(key) {\n        const metadata = this._ymetadata;\n        // Transiently the metadata can be missing - like during destruction\n        if (metadata === undefined) {\n            return undefined;\n        }\n        if (typeof key === 'string') {\n            const value = metadata.get(key);\n            return typeof value === 'undefined'\n                ? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`\n                : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata.get(key));\n        }\n        else {\n            return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata.toJSON());\n        }\n    }\n    setMetadata(metadata, value) {\n        var _a, _b;\n        if (typeof metadata === 'string') {\n            if (typeof value === 'undefined') {\n                throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);\n            }\n            const key = metadata;\n            // Only set metadata if we change something to avoid infinite\n            // loop of signal changes.\n            if (_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual((_a = this.getMetadata(key)) !== null && _a !== void 0 ? _a : null, value)) {\n                return;\n            }\n            this.transact(() => {\n                var _a;\n                this._ymetadata.set(key, value);\n                if (key === 'collapsed') {\n                    const jupyter = ((_a = this.getMetadata('jupyter')) !== null && _a !== void 0 ? _a : {});\n                    if (jupyter.outputs_hidden !== value) {\n                        this.setMetadata('jupyter', {\n                            ...jupyter,\n                            outputs_hidden: value\n                        });\n                    }\n                }\n                else if (key === 'jupyter') {\n                    const isHidden = value['outputs_hidden'];\n                    if (typeof isHidden !== 'undefined') {\n                        if (this.getMetadata('collapsed') !== isHidden) {\n                            this.setMetadata('collapsed', isHidden);\n                        }\n                    }\n                    else {\n                        this.deleteMetadata('collapsed');\n                    }\n                }\n            }, false);\n        }\n        else {\n            const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata);\n            if (clone.collapsed != null) {\n                clone.jupyter = clone.jupyter || {};\n                clone.jupyter.outputs_hidden = clone.collapsed;\n            }\n            else if (((_b = clone === null || clone === void 0 ? void 0 : clone.jupyter) === null || _b === void 0 ? void 0 : _b.outputs_hidden) != null) {\n                clone.collapsed = clone.jupyter.outputs_hidden;\n            }\n            if (!_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(clone, this.getMetadata())) {\n                this.transact(() => {\n                    for (const [key, value] of Object.entries(clone)) {\n                        this._ymetadata.set(key, value);\n                    }\n                }, false);\n            }\n        }\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: this.cell_type,\n            source: this.getSource(),\n            metadata: this.getMetadata()\n        };\n    }\n    /**\n     * Perform a transaction. While the function f is called, all changes to the shared\n     * document are bundled into a single event.\n     *\n     * @param f Transaction to execute\n     * @param undoable Whether to track the change in the action history or not (default `true`)\n     */\n    transact(f, undoable = true, origin = null) {\n        !this.notebook || this.notebook.disableDocumentWideUndoRedo\n            ? this.ymodel.doc == null\n                ? f()\n                : this.ymodel.doc.transact(f, undoable ? this : origin)\n            : this.notebook.transact(f, undoable);\n    }\n    /**\n     * Extract changes from YJS events\n     *\n     * @param events YJS events\n     * @returns Cell changes\n     */\n    getChanges(events) {\n        const changes = {};\n        const sourceEvent = events.find(event => event.target === this.ymodel.get('source'));\n        if (sourceEvent) {\n            changes.sourceChange = sourceEvent.changes.delta;\n        }\n        const metadataEvents = events.find(event => event.target === this._ymetadata);\n        if (metadataEvents) {\n            changes.metadataChange = metadataEvents.changes.keys;\n            metadataEvents.changes.keys.forEach((change, key) => {\n                switch (change.action) {\n                    case 'add':\n                        this._metadataChanged.emit({\n                            key,\n                            newValue: this._ymetadata.get(key),\n                            type: 'add'\n                        });\n                        break;\n                    case 'delete':\n                        this._metadataChanged.emit({\n                            key,\n                            oldValue: change.oldValue,\n                            type: 'remove'\n                        });\n                        break;\n                    case 'update':\n                        {\n                            const newValue = this._ymetadata.get(key);\n                            const oldValue = change.oldValue;\n                            let equal = true;\n                            if (typeof oldValue == 'object' && typeof newValue == 'object') {\n                                equal = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(oldValue, newValue);\n                            }\n                            else {\n                                equal = oldValue === newValue;\n                            }\n                            if (!equal) {\n                                this._metadataChanged.emit({\n                                    key,\n                                    type: 'change',\n                                    oldValue,\n                                    newValue\n                                });\n                            }\n                        }\n                        break;\n                }\n            });\n        }\n        const modelEvent = events.find(event => event.target === this.ymodel);\n        // The model allows us to replace the complete source with a new string. We express this in the Delta format\n        // as a replace of the complete string.\n        const ysource = this.ymodel.get('source');\n        if (modelEvent && modelEvent.keysChanged.has('source')) {\n            changes.sourceChange = [\n                { delete: this._prevSourceLength },\n                { insert: ysource.toString() }\n            ];\n        }\n        this._prevSourceLength = ysource.length;\n        return changes;\n    }\n}\n/**\n * Shareable code cell.\n */\nclass YCodeCell extends YBaseCell {\n    /**\n     * Create a new YCodeCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static create(id) {\n        return super.create(id);\n    }\n    /**\n     * Code cell constructor\n     *\n     * ### Notes\n     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``\n     *\n     * The ``ysource`` is needed because ``ymodel.get('source')`` will\n     * not return the real source if the model is not yet attached to\n     * a document. Requesting it explicitly allows to introspect a non-empty\n     * source before the cell is attached to the document.\n     *\n     * @param ymodel Cell map\n     * @param ysource Cell source\n     * @param youtputs Code cell outputs\n     * @param options \\{ notebook?: The notebook the cell is attached to \\}\n     * @param ymetadata Cell metadata\n     */\n    constructor(ymodel, ysource, youtputs, options = {}, ymetadata) {\n        super(ymodel, ysource, options, ymetadata);\n        this._youtputs = youtputs;\n    }\n    /**\n     * The type of the cell.\n     */\n    get cell_type() {\n        return 'code';\n    }\n    /**\n     * The code cell's prompt number. Will be null if the cell has not been run.\n     */\n    get execution_count() {\n        return this.ymodel.get('execution_count') || null;\n    }\n    set execution_count(count) {\n        // Do not use `this.execution_count`. When initializing the\n        // cell, we need to set execution_count to `null` if we compare\n        // using `this.execution_count` it will return `null` and we will\n        // never initialize it\n        if (this.ymodel.get('execution_count') !== count) {\n            this.transact(() => {\n                this.ymodel.set('execution_count', count);\n            }, false);\n        }\n    }\n    /**\n     * The code cell's execution state.\n     */\n    get executionState() {\n        var _a;\n        return (_a = this.ymodel.get('execution_state')) !== null && _a !== void 0 ? _a : 'idle';\n    }\n    set executionState(state) {\n        if (this.ymodel.get('execution_state') !== state) {\n            this.transact(() => {\n                this.ymodel.set('execution_state', state);\n            }, false);\n        }\n    }\n    /**\n     * Cell outputs.\n     */\n    get outputs() {\n        return this.getOutputs();\n    }\n    set outputs(v) {\n        this.setOutputs(v);\n    }\n    get youtputs() {\n        return this._youtputs;\n    }\n    /**\n     * Execution, display, or stream outputs.\n     */\n    getOutputs() {\n        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(this._youtputs.toJSON());\n    }\n    createOutputs(outputs) {\n        const newOutputs = [];\n        for (const output of _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(outputs)) {\n            let _newOutput1;\n            if (output.output_type === 'stream') {\n                // Set the text field as a Y.Text\n                const { text, ...outputWithoutText } = output;\n                _newOutput1 = outputWithoutText;\n                const newText = new yjs__WEBPACK_IMPORTED_MODULE_3__.Text();\n                let _text = text instanceof Array ? text.join() : text;\n                newText.insert(0, _text);\n                _newOutput1['text'] = newText;\n            }\n            else {\n                _newOutput1 = output;\n            }\n            const _newOutput2 = [];\n            for (const [key, value] of Object.entries(_newOutput1)) {\n                _newOutput2.push([key, value]);\n            }\n            const newOutput = new yjs__WEBPACK_IMPORTED_MODULE_3__.Map(_newOutput2);\n            newOutputs.push(newOutput);\n        }\n        return newOutputs;\n    }\n    /**\n     * Replace all outputs.\n     */\n    setOutputs(outputs) {\n        this.transact(() => {\n            this._youtputs.delete(0, this._youtputs.length);\n            const newOutputs = this.createOutputs(outputs);\n            this._youtputs.insert(0, newOutputs);\n        }, false);\n    }\n    /**\n     * Remove text from a stream output.\n     */\n    removeStreamOutput(index, start, origin = null) {\n        this.transact(() => {\n            const output = this._youtputs.get(index);\n            const prevText = output.get('text');\n            const length = prevText.length - start;\n            prevText.delete(start, length);\n        }, false, origin);\n    }\n    /**\n     * Append text to a stream output.\n     */\n    appendStreamOutput(index, text, origin = null) {\n        this.transact(() => {\n            const output = this._youtputs.get(index);\n            const prevText = output.get('text');\n            prevText.insert(prevText.length, text);\n        }, false, origin);\n    }\n    /**\n     * Replace content from `start' to `end` with `outputs`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param outputs: New outputs (optional).\n     */\n    updateOutputs(start, end, outputs = [], origin = null) {\n        const fin = end < this._youtputs.length ? end - start : this._youtputs.length - start;\n        this.transact(() => {\n            this._youtputs.delete(start, fin);\n            const newOutputs = this.createOutputs(outputs);\n            this._youtputs.insert(start, newOutputs);\n        }, false, origin);\n    }\n    /**\n     * Clear all outputs from the cell.\n     */\n    clearOutputs(origin = null) {\n        this.transact(() => {\n            this._youtputs.delete(0, this._youtputs.length);\n        }, false, origin);\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            outputs: this.getOutputs(),\n            execution_count: this.execution_count\n        };\n    }\n    /**\n     * Extract changes from YJS events\n     *\n     * @param events YJS events\n     * @returns Cell changes\n     */\n    getChanges(events) {\n        const changes = super.getChanges(events);\n        const streamOutputEvent = events.find(\n        // Changes to the 'text' of a cell's stream output can be accessed like so:\n        // ycell['outputs'][output_idx]['text']\n        // This translates to an event path of: ['outputs', output_idx, 'text]\n        event => event.path.length === 3 &&\n            event.path[0] === 'outputs' &&\n            event.path[2] === 'text');\n        if (streamOutputEvent) {\n            changes.streamOutputChange = streamOutputEvent.changes.delta;\n        }\n        const outputEvent = events.find(event => event.target === this.ymodel.get('outputs'));\n        if (outputEvent) {\n            changes.outputsChange = outputEvent.changes.delta;\n        }\n        const modelEvent = events.find(event => event.target === this.ymodel);\n        if (modelEvent && modelEvent.keysChanged.has('execution_count')) {\n            const change = modelEvent.changes.keys.get('execution_count');\n            changes.executionCountChange = {\n                oldValue: change.oldValue,\n                newValue: this.ymodel.get('execution_count')\n            };\n        }\n        if (modelEvent && modelEvent.keysChanged.has('execution_state')) {\n            const change = modelEvent.changes.keys.get('execution_state');\n            changes.executionStateChange = {\n                oldValue: change.oldValue,\n                newValue: this.ymodel.get('execution_state')\n            };\n        }\n        return changes;\n    }\n}\nclass YAttachmentCell extends YBaseCell {\n    /**\n     * Cell attachments\n     */\n    get attachments() {\n        return this.getAttachments();\n    }\n    set attachments(v) {\n        this.setAttachments(v);\n    }\n    /**\n     * Gets the cell attachments.\n     *\n     * @returns The cell attachments.\n     */\n    getAttachments() {\n        return this.ymodel.get('attachments');\n    }\n    /**\n     * Sets the cell attachments\n     *\n     * @param attachments: The cell attachments.\n     */\n    setAttachments(attachments) {\n        this.transact(() => {\n            if (attachments == null) {\n                this.ymodel.delete('attachments');\n            }\n            else {\n                this.ymodel.set('attachments', attachments);\n            }\n        }, false);\n    }\n    /**\n     * Extract changes from YJS events\n     *\n     * @param events YJS events\n     * @returns Cell changes\n     */\n    getChanges(events) {\n        const changes = super.getChanges(events);\n        const modelEvent = events.find(event => event.target === this.ymodel);\n        if (modelEvent && modelEvent.keysChanged.has('attachments')) {\n            const change = modelEvent.changes.keys.get('attachments');\n            changes.attachmentsChange = {\n                oldValue: change.oldValue,\n                newValue: this.ymodel.get('attachments')\n            };\n        }\n        return changes;\n    }\n}\n/**\n * Shareable raw cell.\n */\nclass YRawCell extends YAttachmentCell {\n    /**\n     * Create a new YRawCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static create(id) {\n        return super.create(id);\n    }\n    /**\n     * String identifying the type of cell.\n     */\n    get cell_type() {\n        return 'raw';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'raw',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            attachments: this.getAttachments()\n        };\n    }\n}\n/**\n * Shareable markdown cell.\n */\nclass YMarkdownCell extends YAttachmentCell {\n    /**\n     * Create a new YMarkdownCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static create(id) {\n        return super.create(id);\n    }\n    /**\n     * String identifying the type of cell.\n     */\n    get cell_type() {\n        return 'markdown';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'markdown',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            attachments: this.getAttachments()\n        };\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/ycell.js?\n}");

/***/ },

/***/ "../../node_modules/@jupyter/ydoc/lib/ydocument.js"
/*!*********************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/ydocument.js ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   YDocument: () => (/* binding */ YDocument)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"../../node_modules/@lumino/coreutils/dist/index.js\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ \"../../node_modules/@lumino/signaling/dist/index.es6.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness */ \"../../node_modules/y-protocols/awareness.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"../../node_modules/yjs/dist/yjs.mjs\");\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n\n/**\n * Generic shareable document.\n */\nclass YDocument {\n    constructor(options) {\n        var _a;\n        /**\n         * Handle a change to the ystate.\n         */\n        this.onStateChanged = (event) => {\n            const stateChange = new Array();\n            event.keysChanged.forEach(key => {\n                const change = event.changes.keys.get(key);\n                if (change) {\n                    stateChange.push({\n                        name: key,\n                        oldValue: change.oldValue,\n                        newValue: this.ystate.get(key)\n                    });\n                }\n            });\n            this._changed.emit({ stateChange });\n        };\n        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        this._isDisposed = false;\n        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        this._ydoc = (_a = options === null || options === void 0 ? void 0 : options.ydoc) !== null && _a !== void 0 ? _a : new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();\n        this._ystate = this._ydoc.getMap('state');\n        this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([], {\n            trackedOrigins: new Set([this]),\n            doc: this._ydoc\n        });\n        this._awareness = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__.Awareness(this._ydoc);\n        this._ystate.observe(this.onStateChanged);\n    }\n    /**\n     * YJS document.\n     */\n    get ydoc() {\n        return this._ydoc;\n    }\n    /**\n     * Shared state\n     */\n    get ystate() {\n        return this._ystate;\n    }\n    /**\n     * YJS document undo manager\n     */\n    get undoManager() {\n        return this._undoManager;\n    }\n    /**\n     * Shared awareness\n     */\n    get awareness() {\n        return this._awareness;\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * A signal emitted when the document is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Whether the document is disposed or not.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Document state\n     */\n    get state() {\n        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(this.ystate.toJSON());\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    canUndo() {\n        return this.undoManager.undoStack.length > 0;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    canRedo() {\n        return this.undoManager.redoStack.length > 0;\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.ystate.unobserve(this.onStateChanged);\n        this.awareness.destroy();\n        this.undoManager.destroy();\n        this.ydoc.destroy();\n        this._disposed.emit();\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);\n    }\n    /**\n     * Get the value for a state attribute\n     *\n     * @param key Key to get\n     */\n    getState(key) {\n        const value = this.ystate.get(key);\n        return typeof value === 'undefined'\n            ? value\n            : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);\n    }\n    /**\n     * Set the value of a state attribute\n     *\n     * @param key Key to set\n     * @param value New attribute value\n     */\n    setState(key, value) {\n        if (!_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(this.ystate.get(key), value)) {\n            this.ystate.set(key, value);\n        }\n    }\n    /**\n     * Get the document source\n     *\n     * @returns The source\n     */\n    get source() {\n        return this.getSource();\n    }\n    /**\n     * Set the document source\n     *\n     * @param value The source to set\n     */\n    set source(value) {\n        this.setSource(value);\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        this.undoManager.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        this.undoManager.redo();\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndoHistory() {\n        this.undoManager.clear();\n    }\n    /**\n     * Perform a transaction. While the function f is called, all changes to the shared\n     * document are bundled into a single event.\n     */\n    transact(f, undoable = true, origin = null) {\n        this.ydoc.transact(f, undoable ? this : origin);\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/ydocument.js?\n}");

/***/ },

/***/ "../../node_modules/@jupyter/ydoc/lib/yfile.js"
/*!*****************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/yfile.js ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   YFile: () => (/* binding */ YFile)\n/* harmony export */ });\n/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ydocument.js */ \"../../node_modules/@jupyter/ydoc/lib/ydocument.js\");\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n/**\n * Shareable text file.\n */\nclass YFile extends _ydocument_js__WEBPACK_IMPORTED_MODULE_0__.YDocument {\n    /**\n     * Create a new file\n     *\n     * #### Notes\n     * The document is empty and must be populated\n     */\n    constructor() {\n        super();\n        /**\n         * Document version\n         */\n        this.version = '1.0.0';\n        /**\n         * YJS file text.\n         */\n        this.ysource = this.ydoc.getText('source');\n        /**\n         * Handle a change to the ymodel.\n         */\n        this._modelObserver = (event) => {\n            this._changed.emit({ sourceChange: event.changes.delta });\n        };\n        this.undoManager.addToScope(this.ysource);\n        this.ysource.observe(this._modelObserver);\n    }\n    /**\n     * Creates a standalone YFile\n     */\n    static create() {\n        return new YFile();\n    }\n    /**\n     * File text\n     */\n    get source() {\n        return this.getSource();\n    }\n    set source(v) {\n        this.setSource(v);\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.ysource.unobserve(this._modelObserver);\n        super.dispose();\n    }\n    /**\n     * Get the file text.\n     *\n     * @returns File text.\n     */\n    getSource() {\n        return this.ysource.toString();\n    }\n    /**\n     * Set the file text.\n     *\n     * @param value New text\n     */\n    setSource(value) {\n        this.transact(() => {\n            const ytext = this.ysource;\n            ytext.delete(0, ytext.length);\n            ytext.insert(0, value);\n        });\n    }\n    /**\n     * Replace content from `start' to `end` with `value`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     * @param end: The end index of the range to replace (exclusive).\n     * @param value: New source (optional).\n     */\n    updateSource(start, end, value = '') {\n        this.transact(() => {\n            const ysource = this.ysource;\n            // insert and then delete.\n            // This ensures that the cursor position is adjusted after the replaced content.\n            ysource.insert(start, value);\n            ysource.delete(start + value.length, end - start);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/yfile.js?\n}");

/***/ },

/***/ "../../node_modules/@jupyter/ydoc/lib/ynotebook.js"
/*!*********************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/ynotebook.js ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   YNotebook: () => (/* binding */ YNotebook)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"../../node_modules/@lumino/coreutils/dist/index.js\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ \"../../node_modules/@lumino/signaling/dist/index.es6.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ \"../../node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ydocument.js */ \"../../node_modules/@jupyter/ydoc/lib/ydocument.js\");\n/* harmony import */ var _ycell_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ycell.js */ \"../../node_modules/@jupyter/ydoc/lib/ycell.js\");\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n\n\n/**\n * Shared implementation of the Shared Document types.\n *\n * Shared cells can be inserted into a SharedNotebook.\n * Shared cells only start emitting events when they are connected to a SharedNotebook.\n *\n * \"Standalone\" cells must not be inserted into a (Shared)Notebook.\n * Standalone cells emit events immediately after they have been created, but they must not\n * be included into a (Shared)Notebook.\n */\nclass YNotebook extends _ydocument_js__WEBPACK_IMPORTED_MODULE_3__.YDocument {\n    /**\n     * Create a new notebook\n     *\n     * #### Notes\n     * The document is empty and must be populated\n     *\n     * @param options\n     */\n    constructor(options = {}) {\n        var _a;\n        super();\n        /**\n         * Document version\n         */\n        this.version = '2.0.0';\n        /**\n         * YJS map for the notebook metadata\n         */\n        this.ymeta = this.ydoc.getMap('meta');\n        /**\n         * Handle a change to the ystate.\n         */\n        this._onMetaChanged = (events) => {\n            const metadataEvents = events.find(event => event.target === this.ymeta.get('metadata'));\n            if (metadataEvents) {\n                const metadataChange = metadataEvents.changes.keys;\n                const ymetadata = this.ymeta.get('metadata');\n                metadataEvents.changes.keys.forEach((change, key) => {\n                    switch (change.action) {\n                        case 'add':\n                            this._metadataChanged.emit({\n                                key,\n                                type: 'add',\n                                newValue: ymetadata.get(key)\n                            });\n                            break;\n                        case 'delete':\n                            this._metadataChanged.emit({\n                                key,\n                                type: 'remove',\n                                oldValue: change.oldValue\n                            });\n                            break;\n                        case 'update':\n                            {\n                                const newValue = ymetadata.get(key);\n                                const oldValue = change.oldValue;\n                                let equal = true;\n                                if (typeof oldValue == 'object' && typeof newValue == 'object') {\n                                    equal = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(oldValue, newValue);\n                                }\n                                else {\n                                    equal = oldValue === newValue;\n                                }\n                                if (!equal) {\n                                    this._metadataChanged.emit({\n                                        key,\n                                        type: 'change',\n                                        oldValue,\n                                        newValue\n                                    });\n                                }\n                            }\n                            break;\n                    }\n                });\n                this._changed.emit({ metadataChange });\n            }\n            const metaEvent = events.find(event => event.target === this.ymeta);\n            if (!metaEvent) {\n                return;\n            }\n            if (metaEvent.keysChanged.has('metadata')) {\n                // Handle metadata change when adding/removing the YMap\n                const change = metaEvent.changes.keys.get('metadata');\n                if ((change === null || change === void 0 ? void 0 : change.action) === 'add' && !change.oldValue) {\n                    const metadataChange = new Map();\n                    for (const key of Object.keys(this.metadata)) {\n                        metadataChange.set(key, {\n                            action: 'add',\n                            oldValue: undefined\n                        });\n                        this._metadataChanged.emit({\n                            key,\n                            type: 'add',\n                            newValue: this.getMetadata(key)\n                        });\n                    }\n                    this._changed.emit({ metadataChange });\n                }\n            }\n            if (metaEvent.keysChanged.has('nbformat')) {\n                const change = metaEvent.changes.keys.get('nbformat');\n                const nbformatChanged = {\n                    key: 'nbformat',\n                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                    newValue: this.nbformat\n                };\n                this._changed.emit({ nbformatChanged });\n            }\n            if (metaEvent.keysChanged.has('nbformat_minor')) {\n                const change = metaEvent.changes.keys.get('nbformat_minor');\n                const nbformatChanged = {\n                    key: 'nbformat_minor',\n                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                    newValue: this.nbformat_minor\n                };\n                this._changed.emit({ nbformatChanged });\n            }\n        };\n        /**\n         * Handle a change to the list of cells.\n         */\n        this._onYCellsChanged = (event) => {\n            // update the type cell mapping by iterating through the added/removed types\n            event.changes.added.forEach(item => {\n                const type = item.content.type;\n                if (!this._ycellMapping.has(type)) {\n                    const c = (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCellModelFromSharedType)(type, { notebook: this });\n                    this._ycellMapping.set(type, c);\n                }\n            });\n            event.changes.deleted.forEach(item => {\n                const type = item.content.type;\n                const model = this._ycellMapping.get(type);\n                if (model) {\n                    model.dispose();\n                    this._ycellMapping.delete(type);\n                }\n            });\n            let index = 0;\n            // this reflects the event.changes.delta, but replaces the content of delta.insert with ycells\n            const cellsChange = [];\n            event.changes.delta.forEach((d) => {\n                if (d.insert != null) {\n                    const insertedCells = d.insert.map((ycell) => this._ycellMapping.get(ycell));\n                    cellsChange.push({ insert: insertedCells });\n                    this.cells.splice(index, 0, ...insertedCells);\n                    index += d.insert.length;\n                }\n                else if (d.delete != null) {\n                    cellsChange.push(d);\n                    this.cells.splice(index, d.delete);\n                }\n                else if (d.retain != null) {\n                    cellsChange.push(d);\n                    index += d.retain;\n                }\n            });\n            this._changed.emit({\n                cellsChange: cellsChange\n            });\n        };\n        this._metadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        /**\n         * Internal Yjs cells list\n         */\n        this._ycells = this.ydoc.getArray('cells');\n        this._ycellMapping = new WeakMap();\n        this._disableDocumentWideUndoRedo =\n            (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false;\n        this.cells = this._ycells.toArray().map(ycell => {\n            if (!this._ycellMapping.has(ycell)) {\n                this._ycellMapping.set(ycell, (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCellModelFromSharedType)(ycell, { notebook: this }));\n            }\n            return this._ycellMapping.get(ycell);\n        });\n        this.undoManager.addToScope(this._ycells);\n        this._ycells.observe(this._onYCellsChanged);\n        this.ymeta.observeDeep(this._onMetaChanged);\n    }\n    /**\n     * Creates a standalone YNotebook\n     *\n     * Note: This method is useful when we need to initialize\n     * the YNotebook from the JavaScript side.\n     */\n    static create(options = {}) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const ynotebook = new YNotebook({\n            disableDocumentWideUndoRedo: (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false\n        });\n        const data = {\n            cells: (_c = (_b = options.data) === null || _b === void 0 ? void 0 : _b.cells) !== null && _c !== void 0 ? _c : [],\n            nbformat: (_e = (_d = options.data) === null || _d === void 0 ? void 0 : _d.nbformat) !== null && _e !== void 0 ? _e : 4,\n            nbformat_minor: (_g = (_f = options.data) === null || _f === void 0 ? void 0 : _f.nbformat_minor) !== null && _g !== void 0 ? _g : 5,\n            metadata: (_j = (_h = options.data) === null || _h === void 0 ? void 0 : _h.metadata) !== null && _j !== void 0 ? _j : {}\n        };\n        ynotebook.fromJSON(data);\n        return ynotebook;\n    }\n    /**\n     * Wether the undo/redo logic should be\n     * considered on the full document across all cells.\n     *\n     * Default: false\n     */\n    get disableDocumentWideUndoRedo() {\n        return this._disableDocumentWideUndoRedo;\n    }\n    /**\n     * Notebook metadata\n     */\n    get metadata() {\n        return this.getMetadata();\n    }\n    set metadata(v) {\n        this.setMetadata(v);\n    }\n    /**\n     * Signal triggered when a metadata changes.\n     */\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    /**\n     * nbformat major version\n     */\n    get nbformat() {\n        return this.ymeta.get('nbformat');\n    }\n    set nbformat(value) {\n        this.transact(() => {\n            this.ymeta.set('nbformat', value);\n        }, false);\n    }\n    /**\n     * nbformat minor version\n     */\n    get nbformat_minor() {\n        return this.ymeta.get('nbformat_minor');\n    }\n    set nbformat_minor(value) {\n        this.transact(() => {\n            this.ymeta.set('nbformat_minor', value);\n        }, false);\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._ycells.unobserve(this._onYCellsChanged);\n        this.ymeta.unobserveDeep(this._onMetaChanged);\n        super.dispose();\n    }\n    /**\n     * Get a shared cell by index.\n     *\n     * @param index: Cell's position.\n     *\n     * @returns The requested shared cell.\n     */\n    getCell(index) {\n        return this.cells[index];\n    }\n    /**\n     * Add a shared cell at the notebook bottom.\n     *\n     * @param cell Cell to add.\n     *\n     * @returns The added cell.\n     */\n    addCell(cell) {\n        return this.insertCell(this._ycells.length, cell);\n    }\n    /**\n     * Insert a shared cell into a specific position.\n     *\n     * @param index: Cell's position.\n     * @param cell: Cell to insert.\n     *\n     * @returns The inserted cell.\n     */\n    insertCell(index, cell) {\n        return this.insertCells(index, [cell])[0];\n    }\n    /**\n     * Insert a list of shared cells into a specific position.\n     *\n     * @param index: Position to insert the cells.\n     * @param cells: Array of shared cells to insert.\n     *\n     * @returns The inserted cells.\n     */\n    insertCells(index, cells) {\n        const yCells = cells.map(c => {\n            const cell = (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCell)(c, this);\n            this._ycellMapping.set(cell.ymodel, cell);\n            return cell;\n        });\n        this.transact(() => {\n            this._ycells.insert(index, yCells.map(cell => cell.ymodel));\n        });\n        return yCells;\n    }\n    /**\n     * Move a cell.\n     *\n     * @param fromIndex: Index of the cell to move.\n     * @param toIndex: New position of the cell.\n     */\n    moveCell(fromIndex, toIndex) {\n        this.moveCells(fromIndex, toIndex);\n    }\n    /**\n     * Move cells.\n     *\n     * @param fromIndex: Index of the first cells to move.\n     * @param toIndex: New position of the first cell (in the current array).\n     * @param n: Number of cells to move (default 1)\n     */\n    moveCells(fromIndex, toIndex, n = 1) {\n        // FIXME we need to use yjs move feature to preserve undo history\n        const clones = new Array(n)\n            .fill(true)\n            .map((_, idx) => this.getCell(fromIndex + idx).toJSON());\n        this.transact(() => {\n            this._ycells.delete(fromIndex, n);\n            this._ycells.insert(fromIndex > toIndex ? toIndex : toIndex - n + 1, clones.map(clone => (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCell)(clone, this).ymodel));\n        });\n    }\n    /**\n     * Remove a cell.\n     *\n     * @param index: Index of the cell to remove.\n     */\n    deleteCell(index) {\n        this.deleteCellRange(index, index + 1);\n    }\n    /**\n     * Remove a range of cells.\n     *\n     * @param from: The start index of the range to remove (inclusive).\n     * @param to: The end index of the range to remove (exclusive).\n     */\n    deleteCellRange(from, to) {\n        // Cells will be removed from the mapping in the model event listener.\n        this.transact(() => {\n            this._ycells.delete(from, to - from);\n        });\n    }\n    /**\n     * Delete a metadata notebook.\n     *\n     * @param key The key to delete\n     */\n    deleteMetadata(key) {\n        if (typeof this.getMetadata(key) === 'undefined') {\n            return;\n        }\n        const allMetadata = this.metadata;\n        delete allMetadata[key];\n        this.setMetadata(allMetadata);\n    }\n    getMetadata(key) {\n        const ymetadata = this.ymeta.get('metadata');\n        // Transiently the metadata can be missing - like during destruction\n        if (ymetadata === undefined) {\n            return undefined;\n        }\n        if (typeof key === 'string') {\n            const value = ymetadata.get(key);\n            return typeof value === 'undefined'\n                ? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`\n                : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);\n        }\n        else {\n            return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(ymetadata.toJSON());\n        }\n    }\n    setMetadata(metadata, value) {\n        var _a;\n        if (typeof metadata === 'string') {\n            if (typeof value === 'undefined') {\n                throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);\n            }\n            if (_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual((_a = this.getMetadata(metadata)) !== null && _a !== void 0 ? _a : null, value)) {\n                return;\n            }\n            const update = {};\n            update[metadata] = value;\n            this.updateMetadata(update);\n        }\n        else {\n            if (!this.metadata || !_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(this.metadata, metadata)) {\n                const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata);\n                const ymetadata = this.ymeta.get('metadata');\n                // Transiently the metadata can be missing - like during destruction\n                if (ymetadata === undefined) {\n                    return undefined;\n                }\n                this.transact(() => {\n                    ymetadata.clear();\n                    for (const [key, value] of Object.entries(clone)) {\n                        ymetadata.set(key, value);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * Updates the metadata associated with the notebook.\n     *\n     * @param value: Metadata's attribute to update.\n     */\n    updateMetadata(value) {\n        // TODO: Maybe modify only attributes instead of replacing the whole metadata?\n        const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);\n        const ymetadata = this.ymeta.get('metadata');\n        // Transiently the metadata can be missing - like during destruction\n        if (ymetadata === undefined) {\n            return undefined;\n        }\n        this.transact(() => {\n            for (const [key, value] of Object.entries(clone)) {\n                ymetadata.set(key, value);\n            }\n        });\n    }\n    /**\n     * Get the notebook source\n     *\n     * @returns The notebook\n     */\n    getSource() {\n        return this.toJSON();\n    }\n    /**\n     * Set the notebook source\n     *\n     * @param value The notebook\n     */\n    setSource(value) {\n        this.fromJSON(value);\n    }\n    /**\n     * Override the notebook with a JSON-serialized document.\n     *\n     * @param value The notebook\n     */\n    fromJSON(value) {\n        this.transact(() => {\n            this.nbformat = value.nbformat;\n            this.nbformat_minor = value.nbformat_minor;\n            const metadata = value.metadata;\n            if (metadata['orig_nbformat'] !== undefined) {\n                delete metadata['orig_nbformat'];\n            }\n            if (!this.metadata) {\n                const ymetadata = new yjs__WEBPACK_IMPORTED_MODULE_2__.Map();\n                for (const [key, value] of Object.entries(metadata)) {\n                    ymetadata.set(key, value);\n                }\n                this.ymeta.set('metadata', ymetadata);\n            }\n            else {\n                this.metadata = metadata;\n            }\n            const useId = value.nbformat === 4 && value.nbformat_minor >= 5;\n            const ycells = value.cells.map(cell => {\n                if (!useId) {\n                    delete cell.id;\n                }\n                return cell;\n            });\n            this.insertCells(this.cells.length, ycells);\n            this.deleteCellRange(0, this.cells.length);\n        });\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        // strip cell ids if we have notebook format 4.0-4.4\n        const pruneCellId = this.nbformat === 4 && this.nbformat_minor <= 4;\n        return {\n            metadata: this.metadata,\n            nbformat_minor: this.nbformat_minor,\n            nbformat: this.nbformat,\n            cells: this.cells.map(c => {\n                const raw = c.toJSON();\n                if (pruneCellId) {\n                    delete raw.id;\n                }\n                return raw;\n            })\n        };\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/ynotebook.js?\n}");

/***/ },

/***/ "../../node_modules/@jupyter/ydoc/lib/ytext.js"
/*!*****************************************************!*\
  !*** ../../node_modules/@jupyter/ydoc/lib/ytext.js ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@jupyter/ydoc/lib/ytext.js?\n}");

/***/ },

/***/ "../../node_modules/@lumino/algorithm/dist/index.es6.js"
/*!**************************************************************!*\
  !*** ../../node_modules/@lumino/algorithm/dist/index.es6.js ***!
  \**************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayExt: () => (/* binding */ ArrayExt),\n/* harmony export */   StringExt: () => (/* binding */ StringExt),\n/* harmony export */   chain: () => (/* binding */ chain),\n/* harmony export */   each: () => (/* binding */ each),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enumerate: () => (/* binding */ enumerate),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   findIndex: () => (/* binding */ findIndex),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   minmax: () => (/* binding */ minmax),\n/* harmony export */   once: () => (/* binding */ once),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   reduce: () => (/* binding */ reduce),\n/* harmony export */   repeat: () => (/* binding */ repeat),\n/* harmony export */   retro: () => (/* binding */ retro),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   stride: () => (/* binding */ stride),\n/* harmony export */   take: () => (/* binding */ take),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toObject: () => (/* binding */ toObject),\n/* harmony export */   topologicSort: () => (/* binding */ topologicSort),\n/* harmony export */   zip: () => (/* binding */ zip)\n/* harmony export */ });\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for array-specific algorithms.\n */\nvar ArrayExt;\n(function (ArrayExt) {\n    /**\n     * Find the index of the first occurrence of a value in an array.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param value - The value to locate in the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first occurrence of the value, or `-1`\n     *   if the value is not found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four', 'one'];\n     * ArrayExt.firstIndexOf(data, 'red');        // -1\n     * ArrayExt.firstIndexOf(data, 'one');        // 0\n     * ArrayExt.firstIndexOf(data, 'one', 1);     // 4\n     * ArrayExt.firstIndexOf(data, 'two', 2);     // -1\n     * ArrayExt.firstIndexOf(data, 'two', 2, 1);  // 1\n     * ```\n     */\n    function firstIndexOf(array, value, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let span;\n        if (stop < start) {\n            span = stop + 1 + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (let i = 0; i < span; ++i) {\n            let j = (start + i) % n;\n            if (array[j] === value) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.firstIndexOf = firstIndexOf;\n    /**\n     * Find the index of the last occurrence of a value in an array.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param value - The value to locate in the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the last occurrence of the value, or `-1`\n     *   if the value is not found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four', 'one'];\n     * ArrayExt.lastIndexOf(data, 'red');        // -1\n     * ArrayExt.lastIndexOf(data, 'one');        // 4\n     * ArrayExt.lastIndexOf(data, 'one', 1);     // 0\n     * ArrayExt.lastIndexOf(data, 'two', 0);     // -1\n     * ArrayExt.lastIndexOf(data, 'two', 0, 1);  // 1\n     * ```\n     */\n    function lastIndexOf(array, value, start = -1, stop = 0) {\n        let n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let span;\n        if (start < stop) {\n            span = start + 1 + (n - stop);\n        }\n        else {\n            span = start - stop + 1;\n        }\n        for (let i = 0; i < span; ++i) {\n            let j = (start - i + n) % n;\n            if (array[j] === value) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.lastIndexOf = lastIndexOf;\n    /**\n     * Find the index of the first value which matches a predicate.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first matching value, or `-1` if no\n     *   matching value is found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findFirstIndex(data, isEven);       // 1\n     * ArrayExt.findFirstIndex(data, isEven, 4);    // 5\n     * ArrayExt.findFirstIndex(data, isEven, 6);    // -1\n     * ArrayExt.findFirstIndex(data, isEven, 6, 5); // 1\n     * ```\n     */\n    function findFirstIndex(array, fn, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let span;\n        if (stop < start) {\n            span = stop + 1 + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (let i = 0; i < span; ++i) {\n            let j = (start + i) % n;\n            if (fn(array[j], j)) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.findFirstIndex = findFirstIndex;\n    /**\n     * Find the index of the last value which matches a predicate.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the last matching value, or `-1` if no\n     *   matching value is found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findLastIndex(data, isEven);        // 5\n     * ArrayExt.findLastIndex(data, isEven, 4);     // 3\n     * ArrayExt.findLastIndex(data, isEven, 0);     // -1\n     * ArrayExt.findLastIndex(data, isEven, 0, 1);  // 5\n     * ```\n     */\n    function findLastIndex(array, fn, start = -1, stop = 0) {\n        let n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let d;\n        if (start < stop) {\n            d = start + 1 + (n - stop);\n        }\n        else {\n            d = start - stop + 1;\n        }\n        for (let i = 0; i < d; ++i) {\n            let j = (start - i + n) % n;\n            if (fn(array[j], j)) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.findLastIndex = findLastIndex;\n    /**\n     * Find the first value which matches a predicate.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The first matching value, or `undefined` if no matching\n     *   value is found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findFirstValue(data, isEven);       // 2\n     * ArrayExt.findFirstValue(data, isEven, 2);    // 4\n     * ArrayExt.findFirstValue(data, isEven, 6);    // undefined\n     * ArrayExt.findFirstValue(data, isEven, 6, 5); // 2\n     * ```\n     */\n    function findFirstValue(array, fn, start = 0, stop = -1) {\n        let index = findFirstIndex(array, fn, start, stop);\n        return index !== -1 ? array[index] : undefined;\n    }\n    ArrayExt.findFirstValue = findFirstValue;\n    /**\n     * Find the last value which matches a predicate.\n     *\n     * @param object - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The last matching value, or `undefined` if no matching\n     *   value is found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findLastValue(data, isEven);        // 2\n     * ArrayExt.findLastValue(data, isEven, 4);     // 4\n     * ArrayExt.findLastValue(data, isEven, 0);     // undefined\n     * ArrayExt.findLastValue(data, isEven, 0, 1);  // 2\n     * ```\n     */\n    function findLastValue(array, fn, start = -1, stop = 0) {\n        let index = findLastIndex(array, fn, start, stop);\n        return index !== -1 ? array[index] : undefined;\n    }\n    ArrayExt.findLastValue = findLastValue;\n    /**\n     * Find the index of the first element which compares `>=` to a value.\n     *\n     * @param array - The sorted array-like object to search.\n     *\n     * @param value - The value to locate in the array.\n     *\n     * @param fn - The 3-way comparison function to apply to the values.\n     *   It should return `< 0` if an element is less than a value, `0` if\n     *   an element is equal to a value, or `> 0` if an element is greater\n     *   than a value.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first element which compares `>=` to the\n     *   value, or `length` if there is no such element. If the computed\n     *   index for `stop` is less than `start`, then the computed index\n     *   for `start` is returned.\n     *\n     * #### Notes\n     * The array must already be sorted in ascending order according to\n     * the comparison function.\n     *\n     * #### Complexity\n     * Logarithmic.\n     *\n     * #### Undefined Behavior\n     * Searching a range which is not sorted in ascending order.\n     *\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function numberCmp(a: number, b: number): number {\n     *   return a - b;\n     * }\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.lowerBound(data, 0, numberCmp);   // 0\n     * ArrayExt.lowerBound(data, 6, numberCmp);   // 3\n     * ArrayExt.lowerBound(data, 7, numberCmp);   // 3\n     * ArrayExt.lowerBound(data, -1, numberCmp);  // 0\n     * ArrayExt.lowerBound(data, 10, numberCmp);  // 6\n     * ```\n     */\n    function lowerBound(array, value, fn, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let begin = start;\n        let span = stop - start + 1;\n        while (span > 0) {\n            let half = span >> 1;\n            let middle = begin + half;\n            if (fn(array[middle], value) < 0) {\n                begin = middle + 1;\n                span -= half + 1;\n            }\n            else {\n                span = half;\n            }\n        }\n        return begin;\n    }\n    ArrayExt.lowerBound = lowerBound;\n    /**\n     * Find the index of the first element which compares `>` than a value.\n     *\n     * @param array - The sorted array-like object to search.\n     *\n     * @param value - The value to locate in the array.\n     *\n     * @param fn - The 3-way comparison function to apply to the values.\n     *   It should return `< 0` if an element is less than a value, `0` if\n     *   an element is equal to a value, or `> 0` if an element is greater\n     *   than a value.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first element which compares `>` than the\n     *   value, or `length` if there is no such element. If the computed\n     *   index for `stop` is less than `start`, then the computed index\n     *   for `start` is returned.\n     *\n     * #### Notes\n     * The array must already be sorted in ascending order according to\n     * the comparison function.\n     *\n     * #### Complexity\n     * Logarithmic.\n     *\n     * #### Undefined Behavior\n     * Searching a range which is not sorted in ascending order.\n     *\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function numberCmp(a: number, b: number): number {\n     *   return a - b;\n     * }\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.upperBound(data, 0, numberCmp);   // 1\n     * ArrayExt.upperBound(data, 6, numberCmp);   // 3\n     * ArrayExt.upperBound(data, 7, numberCmp);   // 5\n     * ArrayExt.upperBound(data, -1, numberCmp);  // 0\n     * ArrayExt.upperBound(data, 10, numberCmp);  // 6\n     * ```\n     */\n    function upperBound(array, value, fn, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let begin = start;\n        let span = stop - start + 1;\n        while (span > 0) {\n            let half = span >> 1;\n            let middle = begin + half;\n            if (fn(array[middle], value) > 0) {\n                span = half;\n            }\n            else {\n                begin = middle + 1;\n                span -= half + 1;\n            }\n        }\n        return begin;\n    }\n    ArrayExt.upperBound = upperBound;\n    /**\n     * Test whether two arrays are shallowly equal.\n     *\n     * @param a - The first array-like object to compare.\n     *\n     * @param b - The second array-like object to compare.\n     *\n     * @param fn - The comparison function to apply to the elements. It\n     *   should return `true` if the elements are \"equal\". The default\n     *   compares elements using strict `===` equality.\n     *\n     * @returns Whether the two arrays are shallowly equal.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * Modifying the length of the arrays while comparing.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let d1 = [0, 3, 4, 7, 7, 9];\n     * let d2 = [0, 3, 4, 7, 7, 9];\n     * let d3 = [42];\n     * ArrayExt.shallowEqual(d1, d2);  // true\n     * ArrayExt.shallowEqual(d2, d3);  // false\n     * ```\n     */\n    function shallowEqual(a, b, fn) {\n        // Check for object identity first.\n        if (a === b) {\n            return true;\n        }\n        // Bail early if the lengths are different.\n        if (a.length !== b.length) {\n            return false;\n        }\n        // Compare each element for equality.\n        for (let i = 0, n = a.length; i < n; ++i) {\n            if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {\n                return false;\n            }\n        }\n        // The array are shallowly equal.\n        return true;\n    }\n    ArrayExt.shallowEqual = shallowEqual;\n    /**\n     * Create a slice of an array subject to an optional step.\n     *\n     * @param array - The array-like object of interest.\n     *\n     * @param options - The options for configuring the slice.\n     *\n     * @returns A new array with the specified values.\n     *\n     * @throws An exception if the slice `step` is `0`.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start`, `stop`, or `step` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.slice(data);                         // [0, 3, 4, 7, 7, 9]\n     * ArrayExt.slice(data, { start: 2 });           // [4, 7, 7, 9]\n     * ArrayExt.slice(data, { start: 0, stop: 4 });  // [0, 3, 4, 7]\n     * ArrayExt.slice(data, { step: 2 });            // [0, 4, 7]\n     * ArrayExt.slice(data, { step: -1 });           // [9, 7, 7, 4, 3, 0]\n     * ```\n     */\n    function slice(array, options = {}) {\n        // Extract the options.\n        let { start, stop, step } = options;\n        // Set up the `step` value.\n        if (step === undefined) {\n            step = 1;\n        }\n        // Validate the step size.\n        if (step === 0) {\n            throw new Error('Slice `step` cannot be zero.');\n        }\n        // Look up the length of the array.\n        let n = array.length;\n        // Set up the `start` value.\n        if (start === undefined) {\n            start = step < 0 ? n - 1 : 0;\n        }\n        else if (start < 0) {\n            start = Math.max(start + n, step < 0 ? -1 : 0);\n        }\n        else if (start >= n) {\n            start = step < 0 ? n - 1 : n;\n        }\n        // Set up the `stop` value.\n        if (stop === undefined) {\n            stop = step < 0 ? -1 : n;\n        }\n        else if (stop < 0) {\n            stop = Math.max(stop + n, step < 0 ? -1 : 0);\n        }\n        else if (stop >= n) {\n            stop = step < 0 ? n - 1 : n;\n        }\n        // Compute the slice length.\n        let length;\n        if ((step < 0 && stop >= start) || (step > 0 && start >= stop)) {\n            length = 0;\n        }\n        else if (step < 0) {\n            length = Math.floor((stop - start + 1) / step + 1);\n        }\n        else {\n            length = Math.floor((stop - start - 1) / step + 1);\n        }\n        // Compute the sliced result.\n        let result = [];\n        for (let i = 0; i < length; ++i) {\n            result[i] = array[start + i * step];\n        }\n        // Return the result.\n        return result;\n    }\n    ArrayExt.slice = slice;\n    /**\n     * Move an element in an array from one index to another.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param fromIndex - The index of the element to move. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * @param toIndex - The target index of the element. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or `toIndex` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.move(data, 1, 2);  // [0, 2, 1, 3, 4]\n     * ArrayExt.move(data, 4, 2);  // [0, 2, 4, 1, 3]\n     * ```\n     */\n    function move(array, fromIndex, toIndex) {\n        let n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (fromIndex < 0) {\n            fromIndex = Math.max(0, fromIndex + n);\n        }\n        else {\n            fromIndex = Math.min(fromIndex, n - 1);\n        }\n        if (toIndex < 0) {\n            toIndex = Math.max(0, toIndex + n);\n        }\n        else {\n            toIndex = Math.min(toIndex, n - 1);\n        }\n        if (fromIndex === toIndex) {\n            return;\n        }\n        let value = array[fromIndex];\n        let d = fromIndex < toIndex ? 1 : -1;\n        for (let i = fromIndex; i !== toIndex; i += d) {\n            array[i] = array[i + d];\n        }\n        array[toIndex] = value;\n    }\n    ArrayExt.move = move;\n    /**\n     * Reverse an array in-place.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param start - The index of the first element in the range to be\n     *   reversed, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   reversed, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or  `stop` index which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.reverse(data, 1, 3);  // [0, 3, 2, 1, 4]\n     * ArrayExt.reverse(data, 3);     // [0, 3, 2, 4, 1]\n     * ArrayExt.reverse(data);        // [1, 4, 2, 3, 0]\n     * ```\n     */\n    function reverse(array, start = 0, stop = -1) {\n        let n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        while (start < stop) {\n            let a = array[start];\n            let b = array[stop];\n            array[start++] = b;\n            array[stop--] = a;\n        }\n    }\n    ArrayExt.reverse = reverse;\n    /**\n     * Rotate the elements of an array in-place.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param delta - The amount of rotation to apply to the elements. A\n     *   positive value will rotate the elements to the left. A negative\n     *   value will rotate the elements to the right.\n     *\n     * @param start - The index of the first element in the range to be\n     *   rotated, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   rotated, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `delta`, `start`, or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.rotate(data, 2);        // [2, 3, 4, 0, 1]\n     * ArrayExt.rotate(data, -2);       // [0, 1, 2, 3, 4]\n     * ArrayExt.rotate(data, 10);       // [0, 1, 2, 3, 4]\n     * ArrayExt.rotate(data, 9);        // [4, 0, 1, 2, 3]\n     * ArrayExt.rotate(data, 2, 1, 3);  // [4, 2, 0, 1, 3]\n     * ```\n     */\n    function rotate(array, delta, start = 0, stop = -1) {\n        let n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        if (start >= stop) {\n            return;\n        }\n        let length = stop - start + 1;\n        if (delta > 0) {\n            delta = delta % length;\n        }\n        else if (delta < 0) {\n            delta = ((delta % length) + length) % length;\n        }\n        if (delta === 0) {\n            return;\n        }\n        let pivot = start + delta;\n        reverse(array, start, pivot - 1);\n        reverse(array, pivot, stop);\n        reverse(array, start, stop);\n    }\n    ArrayExt.rotate = rotate;\n    /**\n     * Fill an array with a static value.\n     *\n     * @param array - The mutable array-like object to fill.\n     *\n     * @param value - The static value to use to fill the array.\n     *\n     * @param start - The index of the first element in the range to be\n     *   filled, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   filled, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Notes\n     * If `stop < start` the fill will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four'];\n     * ArrayExt.fill(data, 'r');        // ['r', 'r', 'r', 'r']\n     * ArrayExt.fill(data, 'g', 1);     // ['r', 'g', 'g', 'g']\n     * ArrayExt.fill(data, 'b', 2, 3);  // ['r', 'g', 'b', 'b']\n     * ArrayExt.fill(data, 'z', 3, 1);  // ['z', 'z', 'b', 'z']\n     * ```\n     */\n    function fill(array, value, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let span;\n        if (stop < start) {\n            span = stop + 1 + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (let i = 0; i < span; ++i) {\n            array[(start + i) % n] = value;\n        }\n    }\n    ArrayExt.fill = fill;\n    /**\n     * Insert a value into an array at a specific index.\n     *\n     * @param array - The array of interest.\n     *\n     * @param index - The index at which to insert the value. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2];\n     * ArrayExt.insert(data, 0, -1);  // [-1, 0, 1, 2]\n     * ArrayExt.insert(data, 2, 12);  // [-1, 0, 12, 1, 2]\n     * ArrayExt.insert(data, -1, 7);  // [-1, 0, 12, 1, 7, 2]\n     * ArrayExt.insert(data, 6, 19);  // [-1, 0, 12, 1, 7, 2, 19]\n     * ```\n     */\n    function insert(array, index, value) {\n        let n = array.length;\n        if (index < 0) {\n            index = Math.max(0, index + n);\n        }\n        else {\n            index = Math.min(index, n);\n        }\n        for (let i = n; i > index; --i) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    ArrayExt.insert = insert;\n    /**\n     * Remove and return a value at a specific index in an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param index - The index of the value to remove. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The value at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeAt(data, 2);   // 23\n     * ArrayExt.removeAt(data, -2);  // 12\n     * ArrayExt.removeAt(data, 10);  // undefined;\n     * ```\n     */\n    function removeAt(array, index) {\n        let n = array.length;\n        if (index < 0) {\n            index += n;\n        }\n        if (index < 0 || index >= n) {\n            return undefined;\n        }\n        let value = array[index];\n        for (let i = index + 1; i < n; ++i) {\n            array[i - 1] = array[i];\n        }\n        array.length = n - 1;\n        return value;\n    }\n    ArrayExt.removeAt = removeAt;\n    /**\n     * Remove the first occurrence of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeFirstOf(data, 12);        // 1\n     * ArrayExt.removeFirstOf(data, 17);        // -1\n     * ArrayExt.removeFirstOf(data, 39, 3);     // -1\n     * ArrayExt.removeFirstOf(data, 39, 3, 2);  // 2\n     * ```\n     */\n    function removeFirstOf(array, value, start = 0, stop = -1) {\n        let index = firstIndexOf(array, value, start, stop);\n        if (index !== -1) {\n            removeAt(array, index);\n        }\n        return index;\n    }\n    ArrayExt.removeFirstOf = removeFirstOf;\n    /**\n     * Remove the last occurrence of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the array.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeLastOf(data, 12);        // 5\n     * ArrayExt.removeLastOf(data, 17);        // -1\n     * ArrayExt.removeLastOf(data, 39, 2);     // -1\n     * ArrayExt.removeLastOf(data, 39, 2, 3);  // 3\n     * ```\n     */\n    function removeLastOf(array, value, start = -1, stop = 0) {\n        let index = lastIndexOf(array, value, start, stop);\n        if (index !== -1) {\n            removeAt(array, index);\n        }\n        return index;\n    }\n    ArrayExt.removeLastOf = removeLastOf;\n    /**\n     * Remove all occurrences of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The number of elements removed from the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will conceptually wrap at the end of\n     * the array, however the array will be traversed front-to-back.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [14, 12, 23, 39, 14, 12, 19, 14];\n     * ArrayExt.removeAllOf(data, 12);        // 2\n     * ArrayExt.removeAllOf(data, 17);        // 0\n     * ArrayExt.removeAllOf(data, 14, 1, 4);  // 1\n     * ```\n     */\n    function removeAllOf(array, value, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let count = 0;\n        for (let i = 0; i < n; ++i) {\n            if (start <= stop && i >= start && i <= stop && array[i] === value) {\n                count++;\n            }\n            else if (stop < start &&\n                (i <= stop || i >= start) &&\n                array[i] === value) {\n                count++;\n            }\n            else if (count > 0) {\n                array[i - count] = array[i];\n            }\n        }\n        if (count > 0) {\n            array.length = n - count;\n        }\n        return count;\n    }\n    ArrayExt.removeAllOf = removeAllOf;\n    /**\n     * Remove the first occurrence of a value which matches a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The removed `{ index, value }`, which will be `-1` and\n     *   `undefined` if the value is not contained in the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeFirstWhere(data, isEven);     // { index: 0, value: 0 }\n     * ArrayExt.removeFirstWhere(data, isEven, 2);  // { index: 3, value: 14 }\n     * ArrayExt.removeFirstWhere(data, isEven, 4);  // { index: -1, value: undefined }\n     * ```\n     */\n    function removeFirstWhere(array, fn, start = 0, stop = -1) {\n        let value;\n        let index = findFirstIndex(array, fn, start, stop);\n        if (index !== -1) {\n            value = removeAt(array, index);\n        }\n        return { index, value };\n    }\n    ArrayExt.removeFirstWhere = removeFirstWhere;\n    /**\n     * Remove the last occurrence of a value which matches a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The removed `{ index, value }`, which will be `-1` and\n     *   `undefined` if the value is not contained in the array.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeLastWhere(data, isEven);        // { index: 5, value: 12 }\n     * ArrayExt.removeLastWhere(data, isEven, 2);     // { index: 1, value: 12 }\n     * ArrayExt.removeLastWhere(data, isEven, 2, 1);  // { index: -1, value: undefined }\n     * ```\n     */\n    function removeLastWhere(array, fn, start = -1, stop = 0) {\n        let value;\n        let index = findLastIndex(array, fn, start, stop);\n        if (index !== -1) {\n            value = removeAt(array, index);\n        }\n        return { index, value };\n    }\n    ArrayExt.removeLastWhere = removeLastWhere;\n    /**\n     * Remove all occurrences of values which match a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The number of elements removed from the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will conceptually wrap at the end of\n     * the array, however the array will be traversed front-to-back.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * function isNegative(value: number): boolean {\n     *   return value < 0;\n     * }\n     *\n     * let data = [0, 12, -13, -9, 23, 39, 14, -15, 12, 75];\n     * ArrayExt.removeAllWhere(data, isEven);            // 4\n     * ArrayExt.removeAllWhere(data, isNegative, 0, 3);  // 2\n     * ```\n     */\n    function removeAllWhere(array, fn, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let count = 0;\n        for (let i = 0; i < n; ++i) {\n            if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {\n                count++;\n            }\n            else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {\n                count++;\n            }\n            else if (count > 0) {\n                array[i - count] = array[i];\n            }\n        }\n        if (count > 0) {\n            array.length = n - count;\n        }\n        return count;\n    }\n    ArrayExt.removeAllWhere = removeAllWhere;\n})(ArrayExt || (ArrayExt = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Chain together several iterables.\n *\n * @deprecated\n *\n * @param objects - The iterable objects of interest.\n *\n * @returns An iterator which yields the values of the iterables\n *   in the order in which they are supplied.\n *\n * #### Example\n * ```typescript\n * import { chain } from '@lumino/algorithm';\n *\n * let data1 = [1, 2, 3];\n * let data2 = [4, 5, 6];\n *\n * let stream = chain(data1, data2);\n *\n * Array.from(stream);  // [1, 2, 3, 4, 5, 6]\n * ```\n */\nfunction* chain(...objects) {\n    for (const object of objects) {\n        yield* object;\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Create an empty iterator.\n *\n * @returns A new iterator which yields nothing.\n *\n * #### Example\n * ```typescript\n * import { empty } from '@lumino/algorithm';\n *\n * let stream = empty<number>();\n *\n * Array.from(stream);  // []\n * ```\n */\n// eslint-disable-next-line require-yield\nfunction* empty() {\n    return;\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Enumerate an iterable object.\n *\n * @param object - The iterable object of interest.\n *\n * @param start - The starting enum value. The default is `0`.\n *\n * @returns An iterator which yields the enumerated values.\n *\n * #### Example\n * ```typescript\n * import { enumerate } from '@lumino/algorithm';\n *\n * let data = ['foo', 'bar', 'baz'];\n *\n * let stream = enumerate(data, 1);\n *\n * Array.from(stream);  // [[1, 'foo'], [2, 'bar'], [3, 'baz']]\n * ```\n */\nfunction* enumerate(object, start = 0) {\n    for (const value of object) {\n        yield [start++, value];\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Filter an iterable for values which pass a test.\n *\n * @param object - The iterable object of interest.\n *\n * @param fn - The predicate function to invoke for each value.\n *\n * @returns An iterator which yields the values which pass the test.\n *\n * #### Example\n * ```typescript\n * import { filter } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3, 4, 5, 6];\n *\n * let stream = filter(data, value => value % 2 === 0);\n *\n * Array.from(stream);  // [2, 4, 6]\n * ```\n */\nfunction* filter(object, fn) {\n    let index = 0;\n    for (const value of object) {\n        if (fn(value, index++)) {\n            yield value;\n        }\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Find the first value in an iterable which matches a predicate.\n *\n * @param object - The iterable object to search.\n *\n * @param fn - The predicate function to apply to the values.\n *\n * @returns The first matching value, or `undefined` if no matching\n *   value is found.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { find } from '@lumino/algorithm';\n *\n * interface IAnimal { species: string, name: string };\n *\n * function isCat(value: IAnimal): boolean {\n *   return value.species === 'cat';\n * }\n *\n * let data: IAnimal[] = [\n *   { species: 'dog', name: 'spot' },\n *   { species: 'cat', name: 'fluffy' },\n *   { species: 'alligator', name: 'pocho' }\n * ];\n *\n * find(data, isCat).name;  // 'fluffy'\n * ```\n */\nfunction find(object, fn) {\n    let index = 0;\n    for (const value of object) {\n        if (fn(value, index++)) {\n            return value;\n        }\n    }\n    return undefined;\n}\n/**\n * Find the index of the first value which matches a predicate.\n *\n * @param object - The iterable object to search.\n *\n * @param fn - The predicate function to apply to the values.\n *\n * @returns The index of the first matching value, or `-1` if no\n *   matching value is found.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { findIndex } from '@lumino/algorithm';\n *\n * interface IAnimal { species: string, name: string };\n *\n * function isCat(value: IAnimal): boolean {\n *   return value.species === 'cat';\n * }\n *\n * let data: IAnimal[] = [\n *   { species: 'dog', name: 'spot' },\n *   { species: 'cat', name: 'fluffy' },\n *   { species: 'alligator', name: 'pocho' }\n * ];\n *\n * findIndex(data, isCat);  // 1\n * ```\n */\nfunction findIndex(object, fn) {\n    let index = 0;\n    for (const value of object) {\n        if (fn(value, index++)) {\n            return index - 1;\n        }\n    }\n    return -1;\n}\n/**\n * Find the minimum value in an iterable.\n *\n * @param object - The iterable object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns The minimum value in the iterable. If multiple values are\n *   equivalent to the minimum, the left-most value is returned. If\n *   the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { min } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * min([7, 4, 0, 3, 9, 4], numberCmp);  // 0\n * ```\n */\nfunction min(object, fn) {\n    let result = undefined;\n    for (const value of object) {\n        if (result === undefined) {\n            result = value;\n            continue;\n        }\n        if (fn(value, result) < 0) {\n            result = value;\n        }\n    }\n    return result;\n}\n/**\n * Find the maximum value in an iterable.\n *\n * @param object - The iterable object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns The maximum value in the iterable. If multiple values are\n *   equivalent to the maximum, the left-most value is returned. If\n *   the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { max } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * max([7, 4, 0, 3, 9, 4], numberCmp);  // 9\n * ```\n */\nfunction max(object, fn) {\n    let result = undefined;\n    for (const value of object) {\n        if (result === undefined) {\n            result = value;\n            continue;\n        }\n        if (fn(value, result) > 0) {\n            result = value;\n        }\n    }\n    return result;\n}\n/**\n * Find the minimum and maximum values in an iterable.\n *\n * @param object - The iterable object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns A 2-tuple of the `[min, max]` values in the iterable. If\n *   multiple values are equivalent, the left-most values are returned.\n *   If the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { minmax } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * minmax([7, 4, 0, 3, 9, 4], numberCmp);  // [0, 9]\n * ```\n */\nfunction minmax(object, fn) {\n    let empty = true;\n    let vmin;\n    let vmax;\n    for (const value of object) {\n        if (empty) {\n            vmin = value;\n            vmax = value;\n            empty = false;\n        }\n        else if (fn(value, vmin) < 0) {\n            vmin = value;\n        }\n        else if (fn(value, vmax) > 0) {\n            vmax = value;\n        }\n    }\n    return empty ? undefined : [vmin, vmax];\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Create an array from an iterable of values.\n *\n * @deprecated\n *\n * @param object - The iterable object of interest.\n *\n * @returns A new array of values from the given object.\n *\n * #### Example\n * ```typescript\n * import { toArray } from '@lumino/algorithm';\n *\n * let stream = [1, 2, 3, 4, 5, 6][Symbol.iterator]();\n *\n * toArray(stream);  // [1, 2, 3, 4, 5, 6];\n * ```\n */\nfunction toArray(object) {\n    return Array.from(object);\n}\n/**\n * Create an object from an iterable of key/value pairs.\n *\n * @param object - The iterable object of interest.\n *\n * @returns A new object mapping keys to values.\n *\n * #### Example\n * ```typescript\n * import { toObject } from '@lumino/algorithm';\n *\n * let data: [string, number][] = [['one', 1], ['two', 2], ['three', 3]];\n *\n * toObject(data);  // { one: 1, two: 2, three: 3 }\n * ```\n */\nfunction toObject(object) {\n    const result = {};\n    for (const [key, value] of object) {\n        result[key] = value;\n    }\n    return result;\n}\n/**\n * Invoke a function for each value in an iterable.\n *\n * @deprecated\n *\n * @param object - The iterable object of interest.\n *\n * @param fn - The callback function to invoke for each value.\n *\n * #### Notes\n * Iteration can be terminated early by returning `false` from the\n * callback function.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each } from '@lumino/algorithm';\n *\n * let data = [5, 7, 0, -2, 9];\n *\n * each(data, value => { console.log(value); });\n * ```\n */\nfunction each(object, fn) {\n    let index = 0;\n    for (const value of object) {\n        if (false === fn(value, index++)) {\n            return;\n        }\n    }\n}\n/**\n * Test whether all values in an iterable satisfy a predicate.\n *\n * @param object - The iterable object of interest.\n *\n * @param fn - The predicate function to invoke for each value.\n *\n * @returns `true` if all values pass the test, `false` otherwise.\n *\n * #### Notes\n * Iteration terminates on the first `false` predicate result.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { every } from '@lumino/algorithm';\n *\n * let data = [5, 7, 1];\n *\n * every(data, value => value % 2 === 0);  // false\n * every(data, value => value % 2 === 1);  // true\n * ```\n */\nfunction every(object, fn) {\n    let index = 0;\n    for (const value of object) {\n        if (false === fn(value, index++)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Test whether any value in an iterable satisfies a predicate.\n *\n * @param object - The iterable object of interest.\n *\n * @param fn - The predicate function to invoke for each value.\n *\n * @returns `true` if any value passes the test, `false` otherwise.\n *\n * #### Notes\n * Iteration terminates on the first `true` predicate result.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { some } from '@lumino/algorithm';\n *\n * let data = [5, 7, 1];\n *\n * some(data, value => value === 7);  // true\n * some(data, value => value === 3);  // false\n * ```\n */\nfunction some(object, fn) {\n    let index = 0;\n    for (const value of object) {\n        if (fn(value, index++)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Transform the values of an iterable with a mapping function.\n *\n * @param object - The iterable object of interest.\n *\n * @param fn - The mapping function to invoke for each value.\n *\n * @returns An iterator which yields the transformed values.\n *\n * #### Example\n * ```typescript\n * import { map } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3];\n *\n * let stream = map(data, value => value * 2);\n *\n * Array.from(stream);  // [2, 4, 6]\n * ```\n */\nfunction* map(object, fn) {\n    let index = 0;\n    for (const value of object) {\n        yield fn(value, index++);\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Create an iterator of evenly spaced values.\n *\n * @param start - The starting value for the range, inclusive.\n *\n * @param stop - The stopping value for the range, exclusive.\n *\n * @param step - The distance between each value.\n *\n * @returns An iterator which produces evenly spaced values.\n *\n * #### Notes\n * In the single argument form of `range(stop)`, `start` defaults to\n * `0` and `step` defaults to `1`.\n *\n * In the two argument form of `range(start, stop)`, `step` defaults\n * to `1`.\n *\n * #### Example\n * ```typescript\n * import { range } from '@lumino/algorithm';\n *\n * let stream = range(2, 4);\n *\n * Array.from(stream);  // [2, 3]\n * ```\n */\nfunction* range(start, stop, step) {\n    if (stop === undefined) {\n        stop = start;\n        start = 0;\n        step = 1;\n    }\n    else if (step === undefined) {\n        step = 1;\n    }\n    const length = Private.rangeLength(start, stop, step);\n    for (let index = 0; index < length; index++) {\n        yield start + step * index;\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Compute the effective length of a range.\n     *\n     * @param start - The starting value for the range, inclusive.\n     *\n     * @param stop - The stopping value for the range, exclusive.\n     *\n     * @param step - The distance between each value.\n     *\n     * @returns The number of steps need to traverse the range.\n     */\n    function rangeLength(start, stop, step) {\n        if (step === 0) {\n            return Infinity;\n        }\n        if (start > stop && step > 0) {\n            return 0;\n        }\n        if (start < stop && step < 0) {\n            return 0;\n        }\n        return Math.ceil((stop - start) / step);\n    }\n    Private.rangeLength = rangeLength;\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nfunction reduce(object, fn, initial) {\n    // Setup the iterator and fetch the first value.\n    const it = object[Symbol.iterator]();\n    let index = 0;\n    let first = it.next();\n    // An empty iterator and no initial value is an error.\n    if (first.done && initial === undefined) {\n        throw new TypeError('Reduce of empty iterable with no initial value.');\n    }\n    // If the iterator is empty, return the initial value.\n    if (first.done) {\n        return initial;\n    }\n    // If the iterator has a single item and no initial value, the\n    // reducer is not invoked and the first item is the return value.\n    let second = it.next();\n    if (second.done && initial === undefined) {\n        return first.value;\n    }\n    // If iterator has a single item and an initial value is provided,\n    // the reducer is invoked and that result is the return value.\n    if (second.done) {\n        return fn(initial, first.value, index++);\n    }\n    // Setup the initial accumlated value.\n    let accumulator;\n    if (initial === undefined) {\n        accumulator = fn(first.value, second.value, index++);\n    }\n    else {\n        accumulator = fn(fn(initial, first.value, index++), second.value, index++);\n    }\n    // Iterate the rest of the values, updating the accumulator.\n    let next;\n    while (!(next = it.next()).done) {\n        accumulator = fn(accumulator, next.value, index++);\n    }\n    // Return the final accumulated value.\n    return accumulator;\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Create an iterator which repeats a value a number of times.\n *\n * @deprecated\n *\n * @param value - The value to repeat.\n *\n * @param count - The number of times to repeat the value.\n *\n * @returns A new iterator which repeats the specified value.\n *\n * #### Example\n * ```typescript\n * import { repeat } from '@lumino/algorithm';\n *\n * let stream = repeat(7, 3);\n *\n * Array.from(stream);  // [7, 7, 7]\n * ```\n */\nfunction* repeat(value, count) {\n    while (0 < count--) {\n        yield value;\n    }\n}\n/**\n * Create an iterator which yields a value a single time.\n *\n * @deprecated\n *\n * @param value - The value to wrap in an iterator.\n *\n * @returns A new iterator which yields the value a single time.\n *\n * #### Example\n * ```typescript\n * import { once } from '@lumino/algorithm';\n *\n * let stream = once(7);\n *\n * Array.from(stream);  // [7]\n * ```\n */\nfunction* once(value) {\n    yield value;\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Create an iterator for a retroable object.\n *\n * @param object - The retroable or array-like object of interest.\n *\n * @returns An iterator which traverses the object's values in reverse.\n *\n * #### Example\n * ```typescript\n * import { retro } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3, 4, 5, 6];\n *\n * let stream = retro(data);\n *\n * Array.from(stream);  // [6, 5, 4, 3, 2, 1]\n * ```\n */\nfunction* retro(object) {\n    if (typeof object.retro === 'function') {\n        yield* object.retro();\n    }\n    else {\n        for (let index = object.length - 1; index > -1; index--) {\n            yield object[index];\n        }\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Topologically sort an iterable of edges.\n *\n * @param edges - The iterable object of edges to sort.\n *   An edge is represented as a 2-tuple of `[fromNode, toNode]`.\n *\n * @returns The topologically sorted array of nodes.\n *\n * #### Notes\n * If a cycle is present in the graph, the cycle will be ignored and\n * the return value will be only approximately sorted.\n *\n * #### Example\n * ```typescript\n * import { topologicSort } from '@lumino/algorithm';\n *\n * let data = [\n *   ['d', 'e'],\n *   ['c', 'd'],\n *   ['a', 'b'],\n *   ['b', 'c']\n * ];\n *\n * topologicSort(data);  // ['a', 'b', 'c', 'd', 'e']\n * ```\n */\nfunction topologicSort(edges) {\n    // Setup the shared sorting state.\n    let sorted = [];\n    let visited = new Set();\n    let graph = new Map();\n    // Add the edges to the graph.\n    for (const edge of edges) {\n        addEdge(edge);\n    }\n    // Visit each node in the graph.\n    for (const [k] of graph) {\n        visit(k);\n    }\n    // Return the sorted results.\n    return sorted;\n    // Add an edge to the graph.\n    function addEdge(edge) {\n        let [fromNode, toNode] = edge;\n        let children = graph.get(toNode);\n        if (children) {\n            children.push(fromNode);\n        }\n        else {\n            graph.set(toNode, [fromNode]);\n        }\n    }\n    // Recursively visit the node.\n    function visit(node) {\n        if (visited.has(node)) {\n            return;\n        }\n        visited.add(node);\n        let children = graph.get(node);\n        if (children) {\n            for (const child of children) {\n                visit(child);\n            }\n        }\n        sorted.push(node);\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Iterate over an iterable using a stepped increment.\n *\n * @param object - The iterable object of interest.\n *\n * @param step - The distance to step on each iteration. A value\n *   of less than `1` will behave the same as a value of `1`.\n *\n * @returns An iterator which traverses the iterable step-wise.\n *\n * #### Example\n * ```typescript\n * import { stride } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3, 4, 5, 6];\n *\n * let stream = stride(data, 2);\n *\n * Array.from(stream);  // [1, 3, 5];\n * ```\n */\nfunction* stride(object, step) {\n    let count = 0;\n    for (const value of object) {\n        if (0 === count++ % step) {\n            yield value;\n        }\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for string-specific algorithms.\n */\nvar StringExt;\n(function (StringExt) {\n    /**\n     * Find the indices of characters in a source text.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The matched indices, or `null` if there is no match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * In order for there to be a match, all of the characters in `query`\n     * **must** appear in `source` in the order given by `query`.\n     *\n     * Characters are matched using strict `===` equality.\n     */\n    function findIndices(source, query, start = 0) {\n        let indices = new Array(query.length);\n        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {\n            j = source.indexOf(query[i], j);\n            if (j === -1) {\n                return null;\n            }\n            indices[i] = j;\n        }\n        return indices;\n    }\n    StringExt.findIndices = findIndices;\n    /**\n     * A string matcher which uses a sum-of-squares algorithm.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The match result, or `null` if there is no match.\n     *   A lower `score` represents a stronger match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * This scoring algorithm uses a sum-of-squares approach to determine\n     * the score. In order for there to be a match, all of the characters\n     * in `query` **must** appear in `source` in order. The index of each\n     * matching character is squared and added to the score. This means\n     * that early and consecutive character matches are preferred, while\n     * late matches are heavily penalized.\n     */\n    function matchSumOfSquares(source, query, start = 0) {\n        let indices = findIndices(source, query, start);\n        if (!indices) {\n            return null;\n        }\n        let score = 0;\n        for (let i = 0, n = indices.length; i < n; ++i) {\n            let j = indices[i] - start;\n            score += j * j;\n        }\n        return { score, indices };\n    }\n    StringExt.matchSumOfSquares = matchSumOfSquares;\n    /**\n     * A string matcher which uses a sum-of-deltas algorithm.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The match result, or `null` if there is no match.\n     *   A lower `score` represents a stronger match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * This scoring algorithm uses a sum-of-deltas approach to determine\n     * the score. In order for there to be a match, all of the characters\n     * in `query` **must** appear in `source` in order. The delta between\n     * the indices are summed to create the score. This means that groups\n     * of matched characters are preferred, while fragmented matches are\n     * penalized.\n     */\n    function matchSumOfDeltas(source, query, start = 0) {\n        let indices = findIndices(source, query, start);\n        if (!indices) {\n            return null;\n        }\n        let score = 0;\n        let last = start - 1;\n        for (let i = 0, n = indices.length; i < n; ++i) {\n            let j = indices[i];\n            score += j - last - 1;\n            last = j;\n        }\n        return { score, indices };\n    }\n    StringExt.matchSumOfDeltas = matchSumOfDeltas;\n    /**\n     * Highlight the matched characters of a source text.\n     *\n     * @param source - The text which should be highlighted.\n     *\n     * @param indices - The indices of the matched characters. They must\n     *   appear in increasing order and must be in bounds of the source.\n     *\n     * @param fn - The function to apply to the matched chunks.\n     *\n     * @returns An array of unmatched and highlighted chunks.\n     */\n    function highlight(source, indices, fn) {\n        // Set up the result array.\n        let result = [];\n        // Set up the counter variables.\n        let k = 0;\n        let last = 0;\n        let n = indices.length;\n        // Iterator over each index.\n        while (k < n) {\n            // Set up the chunk indices.\n            let i = indices[k];\n            let j = indices[k];\n            // Advance the right chunk index until it's non-contiguous.\n            while (++k < n && indices[k] === j + 1) {\n                j++;\n            }\n            // Extract the unmatched text.\n            if (last < i) {\n                result.push(source.slice(last, i));\n            }\n            // Extract and highlight the matched text.\n            if (i < j + 1) {\n                result.push(fn(source.slice(i, j + 1)));\n            }\n            // Update the last visited index.\n            last = j + 1;\n        }\n        // Extract any remaining unmatched text.\n        if (last < source.length) {\n            result.push(source.slice(last));\n        }\n        // Return the highlighted result.\n        return result;\n    }\n    StringExt.highlight = highlight;\n    /**\n     * A 3-way string comparison function.\n     *\n     * @param a - The first string of interest.\n     *\n     * @param b - The second string of interest.\n     *\n     * @returns `-1` if `a < b`, else `1` if `a > b`, else `0`.\n     */\n    function cmp(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n    StringExt.cmp = cmp;\n})(StringExt || (StringExt = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Take a fixed number of items from an iterable.\n *\n * @param object - The iterable object of interest.\n *\n * @param count - The number of items to take from the iterable.\n *\n * @returns An iterator which yields the specified number of items\n *   from the source iterable.\n *\n * #### Notes\n * The returned iterator will exhaust early if the source iterable\n * contains an insufficient number of items.\n *\n * #### Example\n * ```typescript\n * import { take } from '@lumino/algorithm';\n *\n * let stream = take([5, 4, 3, 2, 1, 0, -1], 3);\n *\n * Array.from(stream);  // [5, 4, 3]\n * ```\n */\nfunction* take(object, count) {\n    if (count < 1) {\n        return;\n    }\n    const it = object[Symbol.iterator]();\n    let item;\n    while (0 < count-- && !(item = it.next()).done) {\n        yield item.value;\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Iterate several iterables in lockstep.\n *\n * @param objects - The iterable objects of interest.\n *\n * @returns An iterator which yields successive tuples of values where\n *   each value is taken in turn from the provided iterables. It will\n *   be as long as the shortest provided iterable.\n *\n * #### Example\n * ```typescript\n * import { zip } from '@lumino/algorithm';\n *\n * let data1 = [1, 2, 3];\n * let data2 = [4, 5, 6];\n *\n * let stream = zip(data1, data2);\n *\n * Array.from(stream);  // [[1, 4], [2, 5], [3, 6]]\n * ```\n */\nfunction* zip(...objects) {\n    const iters = objects.map(obj => obj[Symbol.iterator]());\n    let tuple = iters.map(it => it.next());\n    for (; every(tuple, item => !item.done); tuple = iters.map(it => it.next())) {\n        yield tuple.map(item => item.value);\n    }\n}\n\n\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@lumino/algorithm/dist/index.es6.js?\n}");

/***/ },

/***/ "../../node_modules/@lumino/coreutils/dist/index.js"
/*!**********************************************************!*\
  !*** ../../node_modules/@lumino/coreutils/dist/index.js ***!
  \**********************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

eval("{(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! @lumino/algorithm */ \"../../node_modules/@lumino/algorithm/dist/index.es6.js\")) :\n    0;\n})(this, (function (exports, algorithm) { 'use strict';\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * The namespace for JSON-specific functions.\n     */\n    exports.JSONExt = void 0;\n    (function (JSONExt) {\n        /**\n         * A shared frozen empty JSONObject\n         */\n        JSONExt.emptyObject = Object.freeze({});\n        /**\n         * A shared frozen empty JSONArray\n         */\n        JSONExt.emptyArray = Object.freeze([]);\n        /**\n         * Test whether a JSON value is a primitive.\n         *\n         * @param value - The JSON value of interest.\n         *\n         * @returns `true` if the value is a primitive,`false` otherwise.\n         */\n        function isPrimitive(value) {\n            return (value === null ||\n                typeof value === 'boolean' ||\n                typeof value === 'number' ||\n                typeof value === 'string');\n        }\n        JSONExt.isPrimitive = isPrimitive;\n        function isArray(value) {\n            return Array.isArray(value);\n        }\n        JSONExt.isArray = isArray;\n        function isObject(value) {\n            return !isPrimitive(value) && !isArray(value);\n        }\n        JSONExt.isObject = isObject;\n        /**\n         * Compare two JSON values for deep equality.\n         *\n         * @param first - The first JSON value of interest.\n         *\n         * @param second - The second JSON value of interest.\n         *\n         * @returns `true` if the values are equivalent, `false` otherwise.\n         */\n        function deepEqual(first, second) {\n            // Check referential and primitive equality first.\n            if (first === second) {\n                return true;\n            }\n            // If one is a primitive, the `===` check ruled out the other.\n            if (isPrimitive(first) || isPrimitive(second)) {\n                return false;\n            }\n            // Test whether they are arrays.\n            let a1 = isArray(first);\n            let a2 = isArray(second);\n            // Bail if the types are different.\n            if (a1 !== a2) {\n                return false;\n            }\n            // If they are both arrays, compare them.\n            if (a1 && a2) {\n                return deepArrayEqual(first, second);\n            }\n            // At this point, they must both be objects.\n            return deepObjectEqual(first, second);\n        }\n        JSONExt.deepEqual = deepEqual;\n        /**\n         * Create a deep copy of a JSON value.\n         *\n         * @param value - The JSON value to copy.\n         *\n         * @returns A deep copy of the given JSON value.\n         */\n        function deepCopy(value) {\n            // Do nothing for primitive values.\n            if (isPrimitive(value)) {\n                return value;\n            }\n            // Deep copy an array.\n            if (isArray(value)) {\n                return deepArrayCopy(value);\n            }\n            // Deep copy an object.\n            return deepObjectCopy(value);\n        }\n        JSONExt.deepCopy = deepCopy;\n        /**\n         * Compare two JSON arrays for deep equality.\n         */\n        function deepArrayEqual(first, second) {\n            // Check referential equality first.\n            if (first === second) {\n                return true;\n            }\n            // Test the arrays for equal length.\n            if (first.length !== second.length) {\n                return false;\n            }\n            // Compare the values for equality.\n            for (let i = 0, n = first.length; i < n; ++i) {\n                if (!deepEqual(first[i], second[i])) {\n                    return false;\n                }\n            }\n            // At this point, the arrays are equal.\n            return true;\n        }\n        /**\n         * Compare two JSON objects for deep equality.\n         */\n        function deepObjectEqual(first, second) {\n            // Check referential equality first.\n            if (first === second) {\n                return true;\n            }\n            // Check for the first object's keys in the second object.\n            for (let key in first) {\n                if (first[key] !== undefined && !(key in second)) {\n                    return false;\n                }\n            }\n            // Check for the second object's keys in the first object.\n            for (let key in second) {\n                if (second[key] !== undefined && !(key in first)) {\n                    return false;\n                }\n            }\n            // Compare the values for equality.\n            for (let key in first) {\n                // Get the values.\n                let firstValue = first[key];\n                let secondValue = second[key];\n                // If both are undefined, ignore the key.\n                if (firstValue === undefined && secondValue === undefined) {\n                    continue;\n                }\n                // If only one value is undefined, the objects are not equal.\n                if (firstValue === undefined || secondValue === undefined) {\n                    return false;\n                }\n                // Compare the values.\n                if (!deepEqual(firstValue, secondValue)) {\n                    return false;\n                }\n            }\n            // At this point, the objects are equal.\n            return true;\n        }\n        /**\n         * Create a deep copy of a JSON array.\n         */\n        function deepArrayCopy(value) {\n            let result = new Array(value.length);\n            for (let i = 0, n = value.length; i < n; ++i) {\n                result[i] = deepCopy(value[i]);\n            }\n            return result;\n        }\n        /**\n         * Create a deep copy of a JSON object.\n         */\n        function deepObjectCopy(value) {\n            let result = {};\n            for (let key in value) {\n                // Ignore undefined values.\n                let subvalue = value[key];\n                if (subvalue === undefined) {\n                    continue;\n                }\n                result[key] = deepCopy(subvalue);\n            }\n            return result;\n        }\n    })(exports.JSONExt || (exports.JSONExt = {}));\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * An object which stores MIME data for general application use.\n     *\n     * #### Notes\n     * This class does not attempt to enforce \"correctness\" of MIME types\n     * and their associated data. Since this class is designed to transfer\n     * arbitrary data and objects within the same application, it assumes\n     * that the user provides correct and accurate data.\n     */\n    class MimeData {\n        constructor() {\n            this._types = [];\n            this._values = [];\n        }\n        /**\n         * Get an array of the MIME types contained within the dataset.\n         *\n         * @returns A new array of the MIME types, in order of insertion.\n         */\n        types() {\n            return this._types.slice();\n        }\n        /**\n         * Test whether the dataset has an entry for the given type.\n         *\n         * @param mime - The MIME type of interest.\n         *\n         * @returns `true` if the dataset contains a value for the given\n         *   MIME type, `false` otherwise.\n         */\n        hasData(mime) {\n            return this._types.indexOf(mime) !== -1;\n        }\n        /**\n         * Get the data value for the given MIME type.\n         *\n         * @param mime - The MIME type of interest.\n         *\n         * @returns The value for the given MIME type, or `undefined` if\n         *   the dataset does not contain a value for the type.\n         */\n        getData(mime) {\n            let i = this._types.indexOf(mime);\n            return i !== -1 ? this._values[i] : undefined;\n        }\n        /**\n         * Set the data value for the given MIME type.\n         *\n         * @param mime - The MIME type of interest.\n         *\n         * @param data - The data value for the given MIME type.\n         *\n         * #### Notes\n         * This will overwrite any previous entry for the MIME type.\n         */\n        setData(mime, data) {\n            this.clearData(mime);\n            this._types.push(mime);\n            this._values.push(data);\n        }\n        /**\n         * Remove the data entry for the given MIME type.\n         *\n         * @param mime - The MIME type of interest.\n         *\n         * #### Notes\n         * This is a no-op if there is no entry for the given MIME type.\n         */\n        clearData(mime) {\n            let i = this._types.indexOf(mime);\n            if (i !== -1) {\n                this._types.splice(i, 1);\n                this._values.splice(i, 1);\n            }\n        }\n        /**\n         * Remove all data entries from the dataset.\n         */\n        clear() {\n            this._types.length = 0;\n            this._values.length = 0;\n        }\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /**\n     * Plugin registry.\n     */\n    class PluginRegistry {\n        constructor(options = {}) {\n            this._application = null;\n            this._validatePlugin = () => true;\n            this._plugins = new Map();\n            this._services = new Map();\n            if (options.validatePlugin) {\n                console.info('Plugins may be rejected by the custom validation plugin method.');\n                this._validatePlugin = options.validatePlugin;\n            }\n        }\n        /**\n         * The application object.\n         *\n         * It will be provided as first argument to the\n         * plugins activation and deactivation functions.\n         *\n         * It can only be set once.\n         *\n         * By default, it is `null`.\n         */\n        get application() {\n            return this._application;\n        }\n        set application(v) {\n            if (this._application !== null) {\n                throw Error('PluginRegistry.application is already set. It cannot be overridden.');\n            }\n            this._application = v;\n        }\n        /**\n         * The list of all the deferred plugins.\n         */\n        get deferredPlugins() {\n            return Array.from(this._plugins)\n                .filter(([id, plugin]) => plugin.autoStart === 'defer')\n                .map(([id, plugin]) => id);\n        }\n        /**\n         * Get a plugin description.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns The plugin description.\n         */\n        getPluginDescription(id) {\n            var _a, _b;\n            return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : '';\n        }\n        /**\n         * Test whether a plugin is registered with the application.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns `true` if the plugin is registered, `false` otherwise.\n         */\n        hasPlugin(id) {\n            return this._plugins.has(id);\n        }\n        /**\n         * Test whether a plugin is activated with the application.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns `true` if the plugin is activated, `false` otherwise.\n         */\n        isPluginActivated(id) {\n            var _a, _b;\n            return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.activated) !== null && _b !== void 0 ? _b : false;\n        }\n        /**\n         * List the IDs of the plugins registered with the application.\n         *\n         * @returns A new array of the registered plugin IDs.\n         */\n        listPlugins() {\n            return Array.from(this._plugins.keys());\n        }\n        /**\n         * Register a plugin with the application.\n         *\n         * @param plugin - The plugin to register.\n         *\n         * #### Notes\n         * An error will be thrown if a plugin with the same ID is already\n         * registered, or if the plugin has a circular dependency.\n         *\n         * If the plugin provides a service which has already been provided\n         * by another plugin, the new service will override the old service.\n         */\n        registerPlugin(plugin) {\n            // Throw an error if the plugin ID is already registered.\n            if (this._plugins.has(plugin.id)) {\n                throw new TypeError(`Plugin '${plugin.id}' is already registered.`);\n            }\n            if (!this._validatePlugin(plugin)) {\n                throw new Error(`Plugin '${plugin.id}' is not valid.`);\n            }\n            // Create the normalized plugin data.\n            const data = Private.createPluginData(plugin);\n            // Ensure the plugin does not cause a cyclic dependency.\n            Private.ensureNoCycle(data, this._plugins, this._services);\n            // Add the service token to the service map.\n            if (data.provides) {\n                this._services.set(data.provides, data.id);\n            }\n            // Add the plugin to the plugin map.\n            this._plugins.set(data.id, data);\n        }\n        /**\n         * Register multiple plugins with the application.\n         *\n         * @param plugins - The plugins to register.\n         *\n         * #### Notes\n         * This calls `registerPlugin()` for each of the given plugins.\n         */\n        registerPlugins(plugins) {\n            for (const plugin of plugins) {\n                this.registerPlugin(plugin);\n            }\n        }\n        /**\n         * Deregister a plugin with the application.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @param force - Whether to deregister the plugin even if it is active.\n         */\n        deregisterPlugin(id, force) {\n            const plugin = this._plugins.get(id);\n            if (!plugin) {\n                return;\n            }\n            if (plugin.activated && !force) {\n                throw new Error(`Plugin '${id}' is still active.`);\n            }\n            this._plugins.delete(id);\n        }\n        /**\n         * Activate the plugin with the given ID.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns A promise which resolves when the plugin is activated\n         *   or rejects with an error if it cannot be activated.\n         */\n        async activatePlugin(id) {\n            // Reject the promise if the plugin is not registered.\n            const plugin = this._plugins.get(id);\n            if (!plugin) {\n                throw new ReferenceError(`Plugin '${id}' is not registered.`);\n            }\n            // Resolve immediately if the plugin is already activated.\n            if (plugin.activated) {\n                return;\n            }\n            // Return the pending resolver promise if it exists.\n            if (plugin.promise) {\n                return plugin.promise;\n            }\n            // Resolve the required services for the plugin.\n            const required = plugin.requires.map(t => this.resolveRequiredService(t));\n            // Resolve the optional services for the plugin.\n            const optional = plugin.optional.map(t => this.resolveOptionalService(t));\n            // Setup the resolver promise for the plugin.\n            plugin.promise = Promise.all([...required, ...optional])\n                .then(services => plugin.activate.apply(undefined, [this.application, ...services]))\n                .then(service => {\n                plugin.service = service;\n                plugin.activated = true;\n                plugin.promise = null;\n            })\n                .catch(error => {\n                plugin.promise = null;\n                throw error;\n            });\n            // Return the pending resolver promise.\n            return plugin.promise;\n        }\n        /**\n         * Activate all the deferred plugins.\n         *\n         * @returns A promise which will resolve when each plugin is activated\n         * or rejects with an error if one cannot be activated.\n         */\n        async activatePlugins(kind, options = {}) {\n            switch (kind) {\n                case 'defer': {\n                    const promises = this.deferredPlugins\n                        .filter(pluginId => this._plugins.get(pluginId).autoStart)\n                        .map(pluginId => {\n                        return this.activatePlugin(pluginId);\n                    });\n                    await Promise.all(promises);\n                    break;\n                }\n                case 'startUp': {\n                    // Collect the ids of the startup plugins.\n                    const startups = Private.collectStartupPlugins(this._plugins, options);\n                    // Generate the activation promises.\n                    const promises = startups.map(async (id) => {\n                        try {\n                            return await this.activatePlugin(id);\n                        }\n                        catch (error) {\n                            console.error(`Plugin '${id}' failed to activate.`, error);\n                        }\n                    });\n                    await Promise.all(promises);\n                    break;\n                }\n            }\n        }\n        /**\n         * Deactivate the plugin and its downstream dependents if and only if the\n         * plugin and its dependents all support `deactivate`.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns A list of IDs of downstream plugins deactivated with this one.\n         */\n        async deactivatePlugin(id) {\n            // Reject the promise if the plugin is not registered.\n            const plugin = this._plugins.get(id);\n            if (!plugin) {\n                throw new ReferenceError(`Plugin '${id}' is not registered.`);\n            }\n            // Bail early if the plugin is not activated.\n            if (!plugin.activated) {\n                return [];\n            }\n            // Check that this plugin can deactivate.\n            if (!plugin.deactivate) {\n                throw new TypeError(`Plugin '${id}'#deactivate() method missing`);\n            }\n            // Find the optimal deactivation order for plugins downstream of this one.\n            const manifest = Private.findDependents(id, this._plugins, this._services);\n            const downstream = manifest.map(id => this._plugins.get(id));\n            // Check that all downstream plugins can deactivate.\n            for (const plugin of downstream) {\n                if (!plugin.deactivate) {\n                    throw new TypeError(`Plugin ${plugin.id}#deactivate() method missing (depends on ${id})`);\n                }\n            }\n            // Deactivate all downstream plugins.\n            for (const plugin of downstream) {\n                const services = [...plugin.requires, ...plugin.optional].map(service => {\n                    const id = this._services.get(service);\n                    return id ? this._plugins.get(id).service : null;\n                });\n                // Await deactivation so the next plugins only receive active services.\n                await plugin.deactivate(this.application, ...services);\n                plugin.service = null;\n                plugin.activated = false;\n            }\n            // Remove plugin ID and return manifest of deactivated plugins.\n            manifest.pop();\n            return manifest;\n        }\n        /**\n         * Resolve a required service of a given type.\n         *\n         * @param token - The token for the service type of interest.\n         *\n         * @returns A promise which resolves to an instance of the requested\n         *   service, or rejects with an error if it cannot be resolved.\n         *\n         * #### Notes\n         * Services are singletons. The same instance will be returned each\n         * time a given service token is resolved.\n         *\n         * If the plugin which provides the service has not been activated,\n         * resolving the service will automatically activate the plugin.\n         *\n         * User code will not typically call this method directly. Instead,\n         * the required services for the user's plugins will be resolved\n         * automatically when the plugin is activated.\n         */\n        async resolveRequiredService(token) {\n            // Reject the promise if there is no provider for the type.\n            const id = this._services.get(token);\n            if (!id) {\n                throw new TypeError(`No provider for: ${token.name}.`);\n            }\n            // Activate the plugin if necessary.\n            const plugin = this._plugins.get(id);\n            if (!plugin.activated) {\n                await this.activatePlugin(id);\n            }\n            return plugin.service;\n        }\n        /**\n         * Resolve an optional service of a given type.\n         *\n         * @param token - The token for the service type of interest.\n         *\n         * @returns A promise which resolves to an instance of the requested\n         *   service, or `null` if it cannot be resolved.\n         *\n         * #### Notes\n         * Services are singletons. The same instance will be returned each\n         * time a given service token is resolved.\n         *\n         * If the plugin which provides the service has not been activated,\n         * resolving the service will automatically activate the plugin.\n         *\n         * User code will not typically call this method directly. Instead,\n         * the optional services for the user's plugins will be resolved\n         * automatically when the plugin is activated.\n         */\n        async resolveOptionalService(token) {\n            // Resolve with `null` if there is no provider for the type.\n            const id = this._services.get(token);\n            if (!id) {\n                return null;\n            }\n            // Activate the plugin if necessary.\n            const plugin = this._plugins.get(id);\n            if (!plugin.activated) {\n                try {\n                    await this.activatePlugin(id);\n                }\n                catch (reason) {\n                    console.error(reason);\n                    return null;\n                }\n            }\n            return plugin.service;\n        }\n    }\n    /**\n     * The namespace for the module implementation details.\n     */\n    var Private;\n    (function (Private) {\n        class PluginData {\n            constructor(plugin) {\n                var _a, _b, _c, _d;\n                this._activated = false;\n                this._promise = null;\n                this._service = null;\n                this.id = plugin.id;\n                this.description = (_a = plugin.description) !== null && _a !== void 0 ? _a : '';\n                this.activate = plugin.activate;\n                this.deactivate = (_b = plugin.deactivate) !== null && _b !== void 0 ? _b : null;\n                this.provides = (_c = plugin.provides) !== null && _c !== void 0 ? _c : null;\n                this.autoStart = (_d = plugin.autoStart) !== null && _d !== void 0 ? _d : false;\n                this.requires = plugin.requires ? plugin.requires.slice() : [];\n                this.optional = plugin.optional ? plugin.optional.slice() : [];\n            }\n            /**\n             * Whether the plugin has been activated.\n             */\n            get activated() {\n                return this._activated;\n            }\n            set activated(a) {\n                this._activated = a;\n            }\n            /**\n             * The resolved service for the plugin, or `null`.\n             */\n            get service() {\n                return this._service;\n            }\n            set service(s) {\n                this._service = s;\n            }\n            /**\n             * The pending resolver promise, or `null`.\n             */\n            get promise() {\n                return this._promise;\n            }\n            set promise(p) {\n                this._promise = p;\n            }\n        }\n        /**\n         * Create a normalized plugin data object for the given plugin.\n         */\n        function createPluginData(plugin) {\n            return new PluginData(plugin);\n        }\n        Private.createPluginData = createPluginData;\n        /**\n         * Ensure no cycle is present in the plugin resolution graph.\n         *\n         * If a cycle is detected, an error will be thrown.\n         */\n        function ensureNoCycle(plugin, plugins, services) {\n            const dependencies = [...plugin.requires, ...plugin.optional];\n            const visit = (token) => {\n                if (token === plugin.provides) {\n                    return true;\n                }\n                const id = services.get(token);\n                if (!id) {\n                    return false;\n                }\n                const visited = plugins.get(id);\n                const dependencies = [...visited.requires, ...visited.optional];\n                if (dependencies.length === 0) {\n                    return false;\n                }\n                trace.push(id);\n                if (dependencies.some(visit)) {\n                    return true;\n                }\n                trace.pop();\n                return false;\n            };\n            // Bail early if there cannot be a cycle.\n            if (!plugin.provides || dependencies.length === 0) {\n                return;\n            }\n            // Setup a stack to trace service resolution.\n            const trace = [plugin.id];\n            // Throw an exception if a cycle is present.\n            if (dependencies.some(visit)) {\n                throw new ReferenceError(`Cycle detected: ${trace.join(' -> ')}.`);\n            }\n        }\n        Private.ensureNoCycle = ensureNoCycle;\n        /**\n         * Find dependents in deactivation order.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @param plugins - The map containing all plugins.\n         *\n         * @param services - The map containing all services.\n         *\n         * @returns A list of dependent plugin IDs in order of deactivation\n         *\n         * #### Notes\n         * The final item of the returned list is always the plugin of interest.\n         */\n        function findDependents(id, plugins, services) {\n            const edges = new Array();\n            const add = (id) => {\n                const plugin = plugins.get(id);\n                // FIXME In the case of missing optional dependencies, we may consider\n                // deactivating and reactivating the plugin without the missing service.\n                const dependencies = [...plugin.requires, ...plugin.optional];\n                edges.push(...dependencies.reduce((acc, dep) => {\n                    const service = services.get(dep);\n                    if (service) {\n                        // An edge is oriented from dependent to provider.\n                        acc.push([id, service]);\n                    }\n                    return acc;\n                }, []));\n            };\n            for (const id of plugins.keys()) {\n                add(id);\n            }\n            // Filter edges\n            // - Get all packages that dependent on the package to be deactivated\n            const newEdges = edges.filter(edge => edge[1] === id);\n            let oldSize = 0;\n            while (newEdges.length > oldSize) {\n                const previousSize = newEdges.length;\n                // Get all packages that dependent on packages that will be deactivated\n                const packagesOfInterest = new Set(newEdges.map(edge => edge[0]));\n                for (const poi of packagesOfInterest) {\n                    edges\n                        .filter(edge => edge[1] === poi)\n                        .forEach(edge => {\n                        // We check it is not already included to deal with circular dependencies\n                        if (!newEdges.includes(edge)) {\n                            newEdges.push(edge);\n                        }\n                    });\n                }\n                oldSize = previousSize;\n            }\n            const sorted = algorithm.topologicSort(newEdges);\n            const index = sorted.findIndex(candidate => candidate === id);\n            if (index === -1) {\n                return [id];\n            }\n            return sorted.slice(0, index + 1);\n        }\n        Private.findDependents = findDependents;\n        /**\n         * Collect the IDs of the plugins to activate on startup.\n         */\n        function collectStartupPlugins(plugins, options) {\n            // Create a set to hold the plugin IDs.\n            const collection = new Set();\n            // Collect the auto-start (non deferred) plugins.\n            for (const id of plugins.keys()) {\n                if (plugins.get(id).autoStart === true) {\n                    collection.add(id);\n                }\n            }\n            // Add the startup plugins.\n            if (options.startPlugins) {\n                for (const id of options.startPlugins) {\n                    collection.add(id);\n                }\n            }\n            // Remove the ignored plugins.\n            if (options.ignorePlugins) {\n                for (const id of options.ignorePlugins) {\n                    collection.delete(id);\n                }\n            }\n            // Return the collected startup plugins.\n            return Array.from(collection);\n        }\n        Private.collectStartupPlugins = collectStartupPlugins;\n    })(Private || (Private = {}));\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * A class which wraps a promise into a delegate object.\n     *\n     * #### Notes\n     * This class is useful when the logic to resolve or reject a promise\n     * cannot be defined at the point where the promise is created.\n     */\n    class PromiseDelegate {\n        /**\n         * Construct a new promise delegate.\n         */\n        constructor() {\n            this.promise = new Promise((resolve, reject) => {\n                this._resolve = resolve;\n                this._reject = reject;\n            });\n        }\n        /**\n         * Resolve the wrapped promise with the given value.\n         *\n         * @param value - The value to use for resolving the promise.\n         */\n        resolve(value) {\n            let resolve = this._resolve;\n            resolve(value);\n        }\n        /**\n         * Reject the wrapped promise with the given value.\n         *\n         * @reason - The reason for rejecting the promise.\n         */\n        reject(reason) {\n            let reject = this._reject;\n            reject(reason);\n        }\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * A runtime object which captures compile-time type information.\n     *\n     * #### Notes\n     * A token captures the compile-time type of an interface or class in\n     * an object which can be used at runtime in a type-safe fashion.\n     */\n    class Token {\n        /**\n         * Construct a new token.\n         *\n         * @param name - A human readable name for the token.\n         * @param description - Token purpose description for documentation.\n         */\n        constructor(name, description) {\n            this.name = name;\n            this.description = description !== null && description !== void 0 ? description : '';\n            this._tokenStructuralPropertyT = null;\n        }\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    // Fallback\n    function fallbackRandomValues(buffer) {\n        let value = 0;\n        for (let i = 0, n = buffer.length; i < n; ++i) {\n            if (i % 4 === 0) {\n                value = (Math.random() * 0xffffffff) >>> 0;\n            }\n            buffer[i] = value & 0xff;\n            value >>>= 8;\n        }\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * The namespace for random number related functionality.\n     */\n    exports.Random = void 0;\n    (function (Random) {\n        /**\n         * A function which generates random bytes.\n         *\n         * @param buffer - The `Uint8Array` to fill with random bytes.\n         *\n         * #### Notes\n         * A cryptographically strong random number generator will be used if\n         * available. Otherwise, `Math.random` will be used as a fallback for\n         * randomness.\n         *\n         * The following RNGs are supported, listed in order of precedence:\n         *   - `window.crypto.getRandomValues`\n         *   - `window.msCrypto.getRandomValues`\n         *   - `require('crypto').randomFillSync\n         *   - `require('crypto').randomBytes\n         *   - `Math.random`\n         */\n        Random.getRandomValues = (() => {\n            // Look up the crypto module if available.\n            const crypto = (typeof window !== 'undefined' && (window.crypto || window.msCrypto)) ||\n                null;\n            // Modern browsers and IE 11\n            if (crypto && typeof crypto.getRandomValues === 'function') {\n                return function getRandomValues(buffer) {\n                    return crypto.getRandomValues(buffer);\n                };\n            }\n            // Fallback\n            return fallbackRandomValues;\n        })();\n    })(exports.Random || (exports.Random = {}));\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * A function which creates a function that generates UUID v4 identifiers.\n     *\n     * @returns A new function that creates a UUID v4 string.\n     *\n     * #### Notes\n     * This implementation complies with RFC 4122.\n     *\n     * This uses `Random.getRandomValues()` for random bytes, which in\n     * turn will use the underlying `crypto` module of the platform if\n     * it is available. The fallback for randomness is `Math.random`.\n     */\n    function uuid4Factory(getRandomValues) {\n        // Create a 16 byte array to hold the random values.\n        const bytes = new Uint8Array(16);\n        // Create a look up table from bytes to hex strings.\n        const lut = new Array(256);\n        // Pad the single character hex digits with a leading zero.\n        for (let i = 0; i < 16; ++i) {\n            lut[i] = '0' + i.toString(16);\n        }\n        // Populate the rest of the hex digits.\n        for (let i = 16; i < 256; ++i) {\n            lut[i] = i.toString(16);\n        }\n        // Return a function which generates the UUID.\n        return function uuid4() {\n            // Get a new batch of random values.\n            getRandomValues(bytes);\n            // Set the UUID version number to 4.\n            bytes[6] = 0x40 | (bytes[6] & 0x0f);\n            // Set the clock sequence bit to the RFC spec.\n            bytes[8] = 0x80 | (bytes[8] & 0x3f);\n            // Assemble the UUID string.\n            return (lut[bytes[0]] +\n                lut[bytes[1]] +\n                lut[bytes[2]] +\n                lut[bytes[3]] +\n                '-' +\n                lut[bytes[4]] +\n                lut[bytes[5]] +\n                '-' +\n                lut[bytes[6]] +\n                lut[bytes[7]] +\n                '-' +\n                lut[bytes[8]] +\n                lut[bytes[9]] +\n                '-' +\n                lut[bytes[10]] +\n                lut[bytes[11]] +\n                lut[bytes[12]] +\n                lut[bytes[13]] +\n                lut[bytes[14]] +\n                lut[bytes[15]]);\n        };\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * The namespace for UUID related functionality.\n     */\n    exports.UUID = void 0;\n    (function (UUID) {\n        /**\n         * A function which generates UUID v4 identifiers.\n         *\n         * @returns A new UUID v4 string.\n         *\n         * #### Notes\n         * This implementation complies with RFC 4122.\n         *\n         * This uses `Random.getRandomValues()` for random bytes, which in\n         * turn will use the underlying `crypto` module of the platform if\n         * it is available. The fallback for randomness is `Math.random`.\n         */\n        UUID.uuid4 = uuid4Factory(exports.Random.getRandomValues);\n    })(exports.UUID || (exports.UUID = {}));\n\n    exports.MimeData = MimeData;\n    exports.PluginRegistry = PluginRegistry;\n    exports.PromiseDelegate = PromiseDelegate;\n    exports.Token = Token;\n\n}));\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@lumino/coreutils/dist/index.js?\n}");

/***/ },

/***/ "../../node_modules/@lumino/signaling/dist/index.es6.js"
/*!**************************************************************!*\
  !*** ../../node_modules/@lumino/signaling/dist/index.es6.js ***!
  \**************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signal: () => (/* binding */ Signal),\n/* harmony export */   Stream: () => (/* binding */ Stream)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/algorithm */ \"../../node_modules/@lumino/algorithm/dist/index.es6.js\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ \"../../node_modules/@lumino/coreutils/dist/index.js\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module signaling\n */\n/**\n * A concrete implementation of `ISignal`.\n *\n * #### Example\n * ```typescript\n * import { ISignal, Signal } from '@lumino/signaling';\n *\n * class SomeClass {\n *\n *   constructor(name: string) {\n *     this.name = name;\n *   }\n *\n *   readonly name: string;\n *\n *   get valueChanged: ISignal<this, number> {\n *     return this._valueChanged;\n *   }\n *\n *   get value(): number {\n *     return this._value;\n *   }\n *\n *   set value(value: number) {\n *     if (value === this._value) {\n *       return;\n *     }\n *     this._value = value;\n *     this._valueChanged.emit(value);\n *   }\n *\n *   private _value = 0;\n *   private _valueChanged = new Signal<this, number>(this);\n * }\n *\n * function logger(sender: SomeClass, value: number): void {\n *   console.log(sender.name, value);\n * }\n *\n * let m1 = new SomeClass('foo');\n * let m2 = new SomeClass('bar');\n *\n * m1.valueChanged.connect(logger);\n * m2.valueChanged.connect(logger);\n *\n * m1.value = 42;  // logs: foo 42\n * m2.value = 17;  // logs: bar 17\n * ```\n */\nclass Signal {\n    /**\n     * Construct a new signal.\n     *\n     * @param sender - The sender which owns the signal.\n     */\n    constructor(sender) {\n        this.sender = sender;\n    }\n    /**\n     * Connect a slot to the signal.\n     *\n     * @param slot - The slot to invoke when the signal is emitted.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection succeeds, `false` otherwise.\n     */\n    connect(slot, thisArg) {\n        return Private.connect(this, slot, thisArg);\n    }\n    /**\n     * Disconnect a slot from the signal.\n     *\n     * @param slot - The slot to disconnect from the signal.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection is removed, `false` otherwise.\n     */\n    disconnect(slot, thisArg) {\n        return Private.disconnect(this, slot, thisArg);\n    }\n    /**\n     * Emit the signal and invoke the connected slots.\n     *\n     * @param args - The args to pass to the connected slots.\n     *\n     * #### Notes\n     * Slots are invoked synchronously in connection order.\n     *\n     * Exceptions thrown by connected slots will be caught and logged.\n     */\n    emit(args) {\n        Private.emit(this, args);\n    }\n}\n/**\n * The namespace for the `Signal` class statics.\n */\n(function (Signal) {\n    /**\n     * Remove all connections between a sender and receiver.\n     *\n     * @param sender - The sender object of interest.\n     *\n     * @param receiver - The receiver object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectBetween(sender, receiver) {\n        Private.disconnectBetween(sender, receiver);\n    }\n    Signal.disconnectBetween = disconnectBetween;\n    /**\n     * Remove all connections where the given object is the sender.\n     *\n     * @param sender - The sender object of interest.\n     */\n    function disconnectSender(sender) {\n        Private.disconnectSender(sender);\n    }\n    Signal.disconnectSender = disconnectSender;\n    /**\n     * Remove all connections where the given object is the receiver.\n     *\n     * @param receiver - The receiver object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectReceiver(receiver) {\n        Private.disconnectReceiver(receiver);\n    }\n    Signal.disconnectReceiver = disconnectReceiver;\n    /**\n     * Remove all connections where an object is the sender or receiver.\n     *\n     * @param object - The object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectAll(object) {\n        Private.disconnectAll(object);\n    }\n    Signal.disconnectAll = disconnectAll;\n    /**\n     * Clear all signal data associated with the given object.\n     *\n     * @param object - The object for which the data should be cleared.\n     *\n     * #### Notes\n     * This removes all signal connections and any other signal data\n     * associated with the object.\n     */\n    function clearData(object) {\n        Private.disconnectAll(object);\n    }\n    Signal.clearData = clearData;\n    /**\n     * Get the signal exception handler.\n     *\n     * @returns The current exception handler.\n     *\n     * #### Notes\n     * The default exception handler is `console.error`.\n     */\n    function getExceptionHandler() {\n        return Private.exceptionHandler;\n    }\n    Signal.getExceptionHandler = getExceptionHandler;\n    /**\n     * Set the signal exception handler.\n     *\n     * @param handler - The function to use as the exception handler.\n     *\n     * @returns The old exception handler.\n     *\n     * #### Notes\n     * The exception handler is invoked when a slot throws an exception.\n     */\n    function setExceptionHandler(handler) {\n        let old = Private.exceptionHandler;\n        Private.exceptionHandler = handler;\n        return old;\n    }\n    Signal.setExceptionHandler = setExceptionHandler;\n})(Signal || (Signal = {}));\n/**\n * A concrete implementation of `IStream`.\n *\n * #### Example\n * ```typescript\n * import { IStream, Stream } from '@lumino/signaling';\n *\n * class SomeClass {\n *\n *   constructor(name: string) {\n *     this.name = name;\n *   }\n *\n *   readonly name: string;\n *\n *   get pings(): IStream<this, string> {\n *     return this._pings;\n *   }\n *\n *   ping(value: string) {\n *     this._pings.emit(value);\n *   }\n *\n *   private _pings = new Stream<this, string>(this);\n * }\n *\n * let m1 = new SomeClass('foo');\n *\n * m1.pings.connect((_, value: string) => {\n *   console.log('connect', value);\n * });\n *\n * void (async () => {\n *   for await (const ping of m1.pings) {\n *     console.log('iterator', ping);\n *   }\n * })();\n *\n * m1.ping('alpha');  // logs: connect alpha\n *                    // logs: iterator alpha\n * m1.ping('beta');   // logs: connect beta\n *                    // logs: iterator beta\n * ```\n */\nclass Stream extends Signal {\n    constructor() {\n        super(...arguments);\n        this._pending = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.PromiseDelegate();\n    }\n    /**\n     * Return an async iterator that yields every emission.\n     */\n    async *[Symbol.asyncIterator]() {\n        let pending = this._pending;\n        while (true) {\n            try {\n                const { args, next } = await pending.promise;\n                pending = next;\n                yield args;\n            }\n            catch (_) {\n                return; // Any promise rejection stops the iterator.\n            }\n        }\n    }\n    /**\n     * Emit the signal, invoke the connected slots, and yield the emission.\n     *\n     * @param args - The args to pass to the connected slots.\n     */\n    emit(args) {\n        const pending = this._pending;\n        const next = (this._pending = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.PromiseDelegate());\n        pending.resolve({ args, next });\n        super.emit(args);\n    }\n    /**\n     * Stop the stream's async iteration.\n     */\n    stop() {\n        this._pending.promise.catch(() => undefined);\n        this._pending.reject('stop');\n        this._pending = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.PromiseDelegate();\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The signal exception handler function.\n     */\n    Private.exceptionHandler = (err) => {\n        console.error(err);\n    };\n    /**\n     * Connect a slot to a signal.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param slot - The slot to invoke when the signal is emitted.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection succeeds, `false` otherwise.\n     */\n    function connect(signal, slot, thisArg) {\n        // Coerce a `null` `thisArg` to `undefined`.\n        thisArg = thisArg || undefined;\n        // Ensure the sender's array of receivers is created.\n        let receivers = receiversForSender.get(signal.sender);\n        if (!receivers) {\n            receivers = [];\n            receiversForSender.set(signal.sender, receivers);\n        }\n        // Bail if a matching connection already exists.\n        if (findConnection(receivers, signal, slot, thisArg)) {\n            return false;\n        }\n        // Choose the best object for the receiver.\n        let receiver = thisArg || slot;\n        // Ensure the receiver's array of senders is created.\n        let senders = sendersForReceiver.get(receiver);\n        if (!senders) {\n            senders = [];\n            sendersForReceiver.set(receiver, senders);\n        }\n        // Create a new connection and add it to the end of each array.\n        let connection = { signal, slot, thisArg };\n        receivers.push(connection);\n        senders.push(connection);\n        // Indicate a successful connection.\n        return true;\n    }\n    Private.connect = connect;\n    /**\n     * Disconnect a slot from a signal.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param slot - The slot to disconnect from the signal.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection is removed, `false` otherwise.\n     */\n    function disconnect(signal, slot, thisArg) {\n        // Coerce a `null` `thisArg` to `undefined`.\n        thisArg = thisArg || undefined;\n        // Lookup the list of receivers, and bail if none exist.\n        let receivers = receiversForSender.get(signal.sender);\n        if (!receivers || receivers.length === 0) {\n            return false;\n        }\n        // Bail if no matching connection exits.\n        let connection = findConnection(receivers, signal, slot, thisArg);\n        if (!connection) {\n            return false;\n        }\n        // Choose the best object for the receiver.\n        let receiver = thisArg || slot;\n        // Lookup the array of senders, which is now known to exist.\n        let senders = sendersForReceiver.get(receiver);\n        // Clear the connection and schedule cleanup of the arrays.\n        connection.signal = null;\n        scheduleCleanup(receivers);\n        scheduleCleanup(senders);\n        // Indicate a successful disconnection.\n        return true;\n    }\n    Private.disconnect = disconnect;\n    /**\n     * Remove all connections between a sender and receiver.\n     *\n     * @param sender - The sender object of interest.\n     *\n     * @param receiver - The receiver object of interest.\n     */\n    function disconnectBetween(sender, receiver) {\n        // If there are no receivers, there is nothing to do.\n        let receivers = receiversForSender.get(sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // If there are no senders, there is nothing to do.\n        let senders = sendersForReceiver.get(receiver);\n        if (!senders || senders.length === 0) {\n            return;\n        }\n        // Clear each connection between the sender and receiver.\n        for (const connection of senders) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                continue;\n            }\n            // Clear the connection if it matches the sender.\n            if (connection.signal.sender === sender) {\n                connection.signal = null;\n            }\n        }\n        // Schedule a cleanup of the senders and receivers.\n        scheduleCleanup(receivers);\n        scheduleCleanup(senders);\n    }\n    Private.disconnectBetween = disconnectBetween;\n    /**\n     * Remove all connections where the given object is the sender.\n     *\n     * @param sender - The sender object of interest.\n     */\n    function disconnectSender(sender) {\n        // If there are no receivers, there is nothing to do.\n        let receivers = receiversForSender.get(sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // Clear each receiver connection.\n        for (const connection of receivers) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                continue;\n            }\n            // Choose the best object for the receiver.\n            let receiver = connection.thisArg || connection.slot;\n            // Clear the connection.\n            connection.signal = null;\n            // Cleanup the array of senders, which is now known to exist.\n            scheduleCleanup(sendersForReceiver.get(receiver));\n        }\n        // Schedule a cleanup of the receivers.\n        scheduleCleanup(receivers);\n    }\n    Private.disconnectSender = disconnectSender;\n    /**\n     * Remove all connections where the given object is the receiver.\n     *\n     * @param receiver - The receiver object of interest.\n     */\n    function disconnectReceiver(receiver) {\n        // If there are no senders, there is nothing to do.\n        let senders = sendersForReceiver.get(receiver);\n        if (!senders || senders.length === 0) {\n            return;\n        }\n        // Clear each sender connection.\n        for (const connection of senders) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                continue;\n            }\n            // Lookup the sender for the connection.\n            let sender = connection.signal.sender;\n            // Clear the connection.\n            connection.signal = null;\n            // Cleanup the array of receivers, which is now known to exist.\n            scheduleCleanup(receiversForSender.get(sender));\n        }\n        // Schedule a cleanup of the list of senders.\n        scheduleCleanup(senders);\n    }\n    Private.disconnectReceiver = disconnectReceiver;\n    /**\n     * Remove all connections where an object is the sender or receiver.\n     *\n     * @param object - The object of interest.\n     */\n    function disconnectAll(object) {\n        // Remove all connections where the given object is the sender.\n        disconnectSender(object);\n        // Remove all connections where the given object is the receiver.\n        disconnectReceiver(object);\n    }\n    Private.disconnectAll = disconnectAll;\n    /**\n     * Emit a signal and invoke its connected slots.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param args - The args to pass to the connected slots.\n     *\n     * #### Notes\n     * Slots are invoked synchronously in connection order.\n     *\n     * Exceptions thrown by connected slots will be caught and logged.\n     */\n    function emit(signal, args) {\n        // If there are no receivers, there is nothing to do.\n        let receivers = receiversForSender.get(signal.sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // Invoke the slots for connections with a matching signal.\n        // Any connections added during emission are not invoked.\n        for (let i = 0, n = receivers.length; i < n; ++i) {\n            let connection = receivers[i];\n            if (connection.signal === signal) {\n                invokeSlot(connection, args);\n            }\n        }\n    }\n    Private.emit = emit;\n    /**\n     * A weak mapping of sender to array of receiver connections.\n     */\n    const receiversForSender = new WeakMap();\n    /**\n     * A weak mapping of receiver to array of sender connections.\n     */\n    const sendersForReceiver = new WeakMap();\n    /**\n     * A set of connection arrays which are pending cleanup.\n     */\n    const dirtySet = new Set();\n    /**\n     * A function to schedule an event loop callback.\n     */\n    const schedule = (() => {\n        let ok = typeof requestAnimationFrame === 'function';\n        return ok ? requestAnimationFrame : setImmediate;\n    })();\n    /**\n     * Find a connection which matches the given parameters.\n     */\n    function findConnection(connections, signal, slot, thisArg) {\n        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.find)(connections, connection => connection.signal === signal &&\n            connection.slot === slot &&\n            connection.thisArg === thisArg);\n    }\n    /**\n     * Invoke a slot with the given parameters.\n     *\n     * The connection is assumed to be valid.\n     *\n     * Exceptions in the slot will be caught and logged.\n     */\n    function invokeSlot(connection, args) {\n        let { signal, slot, thisArg } = connection;\n        try {\n            slot.call(thisArg, signal.sender, args);\n        }\n        catch (err) {\n            Private.exceptionHandler(err);\n        }\n    }\n    /**\n     * Schedule a cleanup of a connection array.\n     *\n     * This will add the array to the dirty set and schedule a deferred\n     * cleanup of the array contents. On cleanup, any connection with a\n     * `null` signal will be removed from the array.\n     */\n    function scheduleCleanup(array) {\n        if (dirtySet.size === 0) {\n            schedule(cleanupDirtySet);\n        }\n        dirtySet.add(array);\n    }\n    /**\n     * Cleanup the connection lists in the dirty set.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupDirtySet() {\n        dirtySet.forEach(cleanupConnections);\n        dirtySet.clear();\n    }\n    /**\n     * Cleanup the dirty connections in a connections array.\n     *\n     * This will remove any connection with a `null` signal.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupConnections(connections) {\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAllWhere(connections, isDeadConnection);\n    }\n    /**\n     * Test whether a connection is dead.\n     *\n     * A dead connection has a `null` signal.\n     */\n    function isDeadConnection(connection) {\n        return connection.signal === null;\n    }\n})(Private || (Private = {}));\n\n\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/@lumino/signaling/dist/index.es6.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/ajv.js"
/*!******************************************!*\
  !*** ../../node_modules/ajv/dist/ajv.js ***!
  \******************************************/
(module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;\nconst core_1 = __webpack_require__(/*! ./core */ \"../../node_modules/ajv/dist/core.js\");\nconst draft7_1 = __webpack_require__(/*! ./vocabularies/draft7 */ \"../../node_modules/ajv/dist/vocabularies/draft7.js\");\nconst discriminator_1 = __webpack_require__(/*! ./vocabularies/discriminator */ \"../../node_modules/ajv/dist/vocabularies/discriminator/index.js\");\nconst draft7MetaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"../../node_modules/ajv/dist/refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv = Ajv;\nmodule.exports = exports = Ajv;\nmodule.exports.Ajv = Ajv;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = Ajv;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"../../node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nvar validation_error_1 = __webpack_require__(/*! ./runtime/validation_error */ \"../../node_modules/ajv/dist/runtime/validation_error.js\");\nObject.defineProperty(exports, \"ValidationError\", ({ enumerable: true, get: function () { return validation_error_1.default; } }));\nvar ref_error_1 = __webpack_require__(/*! ./compile/ref_error */ \"../../node_modules/ajv/dist/compile/ref_error.js\");\nObject.defineProperty(exports, \"MissingRefError\", ({ enumerable: true, get: function () { return ref_error_1.default; } }));\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/ajv.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/codegen/code.js"
/*!***********************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/codegen/code.js ***!
  \***********************************************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/codegen/code.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/codegen/index.js"
/*!************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/codegen/index.js ***!
  \************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = __webpack_require__(/*! ./code */ \"../../node_modules/ajv/dist/compile/codegen/code.js\");\nconst scope_1 = __webpack_require__(/*! ./scope */ \"../../node_modules/ajv/dist/compile/codegen/scope.js\");\nvar code_2 = __webpack_require__(/*! ./code */ \"../../node_modules/ajv/dist/compile/codegen/code.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return code_2._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return code_2.str; } }));\nObject.defineProperty(exports, \"strConcat\", ({ enumerable: true, get: function () { return code_2.strConcat; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return code_2.nil; } }));\nObject.defineProperty(exports, \"getProperty\", ({ enumerable: true, get: function () { return code_2.getProperty; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return code_2.stringify; } }));\nObject.defineProperty(exports, \"regexpCode\", ({ enumerable: true, get: function () { return code_2.regexpCode; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return code_2.Name; } }));\nvar scope_2 = __webpack_require__(/*! ./scope */ \"../../node_modules/ajv/dist/compile/codegen/scope.js\");\nObject.defineProperty(exports, \"Scope\", ({ enumerable: true, get: function () { return scope_2.Scope; } }));\nObject.defineProperty(exports, \"ValueScope\", ({ enumerable: true, get: function () { return scope_2.ValueScope; } }));\nObject.defineProperty(exports, \"ValueScopeName\", ({ enumerable: true, get: function () { return scope_2.ValueScopeName; } }));\nObject.defineProperty(exports, \"varKinds\", ({ enumerable: true, get: function () { return scope_2.varKinds; } }));\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/codegen/index.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/codegen/scope.js"
/*!************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/codegen/scope.js ***!
  \************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = __webpack_require__(/*! ./code */ \"../../node_modules/ajv/dist/compile/codegen/code.js\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/codegen/scope.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/errors.js"
/*!*****************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/errors.js ***!
  \*****************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ./names */ \"../../node_modules/ajv/dist/compile/names.js\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"), // also used in JTD errors\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/errors.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/index.js"
/*!****************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/index.js ***!
  \****************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst validation_error_1 = __webpack_require__(/*! ../runtime/validation_error */ \"../../node_modules/ajv/dist/runtime/validation_error.js\");\nconst names_1 = __webpack_require__(/*! ./names */ \"../../node_modules/ajv/dist/compile/names.js\");\nconst resolve_1 = __webpack_require__(/*! ./resolve */ \"../../node_modules/ajv/dist/compile/resolve.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"../../node_modules/ajv/dist/compile/validate/index.js\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/index.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/names.js"
/*!****************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/names.js ***!
  \****************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"), // data passed to validation function\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"), // null or array of validation errors\n    errors: new codegen_1.Name(\"errors\"), // counter of validation errors\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports[\"default\"] = names;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/names.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/ref_error.js"
/*!********************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/ref_error.js ***!
  \********************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst resolve_1 = __webpack_require__(/*! ./resolve */ \"../../node_modules/ajv/dist/compile/resolve.js\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports[\"default\"] = MissingRefError;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/ref_error.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/resolve.js"
/*!******************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/resolve.js ***!
  \******************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"../../node_modules/fast-deep-equal/index.js\");\nconst traverse = __webpack_require__(/*! json-schema-traverse */ \"../../node_modules/ajv/node_modules/json-schema-traverse/index.js\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/resolve.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/rules.js"
/*!****************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/rules.js ***!
  \****************************************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == \"string\" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/rules.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/util.js"
/*!***************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/util.js ***!
  \***************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst code_1 = __webpack_require__(/*! ./codegen/code */ \"../../node_modules/ajv/dist/compile/codegen/code.js\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type || (exports.Type = Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/util.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/validate/applicability.js"
/*!*********************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/validate/applicability.js ***!
  \*********************************************************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/validate/applicability.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/validate/boolSchema.js"
/*!******************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/validate/boolSchema.js ***!
  \******************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../node_modules/ajv/dist/compile/errors.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../node_modules/ajv/dist/compile/names.js\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/validate/boolSchema.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/validate/dataType.js"
/*!****************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/validate/dataType.js ***!
  \****************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = __webpack_require__(/*! ../rules */ \"../../node_modules/ajv/dist/compile/rules.js\");\nconst applicability_1 = __webpack_require__(/*! ./applicability */ \"../../node_modules/ajv/dist/compile/validate/applicability.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../node_modules/ajv/dist/compile/errors.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../node_modules/ajv/dist/compile/util.js\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/validate/dataType.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/validate/defaults.js"
/*!****************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/validate/defaults.js ***!
  \****************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assignDefaults = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../node_modules/ajv/dist/compile/util.js\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/validate/defaults.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/validate/index.js"
/*!*************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/validate/index.js ***!
  \*************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = __webpack_require__(/*! ./boolSchema */ \"../../node_modules/ajv/dist/compile/validate/boolSchema.js\");\nconst dataType_1 = __webpack_require__(/*! ./dataType */ \"../../node_modules/ajv/dist/compile/validate/dataType.js\");\nconst applicability_1 = __webpack_require__(/*! ./applicability */ \"../../node_modules/ajv/dist/compile/validate/applicability.js\");\nconst dataType_2 = __webpack_require__(/*! ./dataType */ \"../../node_modules/ajv/dist/compile/validate/dataType.js\");\nconst defaults_1 = __webpack_require__(/*! ./defaults */ \"../../node_modules/ajv/dist/compile/validate/defaults.js\");\nconst keyword_1 = __webpack_require__(/*! ./keyword */ \"../../node_modules/ajv/dist/compile/validate/keyword.js\");\nconst subschema_1 = __webpack_require__(/*! ./subschema */ \"../../node_modules/ajv/dist/compile/validate/subschema.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../node_modules/ajv/dist/compile/names.js\");\nconst resolve_1 = __webpack_require__(/*! ../resolve */ \"../../node_modules/ajv/dist/compile/resolve.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../node_modules/ajv/dist/compile/errors.js\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/validate/index.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/validate/keyword.js"
/*!***************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/validate/keyword.js ***!
  \***************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../node_modules/ajv/dist/compile/names.js\");\nconst code_1 = __webpack_require__(/*! ../../vocabularies/code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../node_modules/ajv/dist/compile/errors.js\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/validate/keyword.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/compile/validate/subschema.js"
/*!*****************************************************************!*\
  !*** ../../node_modules/ajv/dist/compile/validate/subschema.js ***!
  \*****************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../node_modules/ajv/dist/compile/util.js\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/compile/validate/subschema.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/core.js"
/*!*******************************************!*\
  !*** ../../node_modules/ajv/dist/core.js ***!
  \*******************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"../../node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nconst validation_error_1 = __webpack_require__(/*! ./runtime/validation_error */ \"../../node_modules/ajv/dist/runtime/validation_error.js\");\nconst ref_error_1 = __webpack_require__(/*! ./compile/ref_error */ \"../../node_modules/ajv/dist/compile/ref_error.js\");\nconst rules_1 = __webpack_require__(/*! ./compile/rules */ \"../../node_modules/ajv/dist/compile/rules.js\");\nconst compile_1 = __webpack_require__(/*! ./compile */ \"../../node_modules/ajv/dist/compile/index.js\");\nconst codegen_2 = __webpack_require__(/*! ./compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst resolve_1 = __webpack_require__(/*! ./compile/resolve */ \"../../node_modules/ajv/dist/compile/resolve.js\");\nconst dataType_1 = __webpack_require__(/*! ./compile/validate/dataType */ \"../../node_modules/ajv/dist/compile/validate/dataType.js\");\nconst util_1 = __webpack_require__(/*! ./compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst $dataRefSchema = __webpack_require__(/*! ./refs/data.json */ \"../../node_modules/ajv/dist/refs/data.json\");\nconst uri_1 = __webpack_require__(/*! ./runtime/uri */ \"../../node_modules/ajv/dist/runtime/uri.js\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nexports[\"default\"] = Ajv;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/core.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/refs/data.json"
/*!**************************************************!*\
  !*** ../../node_modules/ajv/dist/refs/data.json ***!
  \**************************************************/
(module) {

"use strict";
eval("{module.exports = /*#__PURE__*/JSON.parse('{\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}');\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/refs/data.json?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/refs/json-schema-draft-07.json"
/*!******************************************************************!*\
  !*** ../../node_modules/ajv/dist/refs/json-schema-draft-07.json ***!
  \******************************************************************/
(module) {

"use strict";
eval("{module.exports = /*#__PURE__*/JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}');\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/refs/json-schema-draft-07.json?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/runtime/equal.js"
/*!****************************************************!*\
  !*** ../../node_modules/ajv/dist/runtime/equal.js ***!
  \****************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"../../node_modules/fast-deep-equal/index.js\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports[\"default\"] = equal;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/runtime/equal.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/runtime/ucs2length.js"
/*!*********************************************************!*\
  !*** ../../node_modules/ajv/dist/runtime/ucs2length.js ***!
  \*********************************************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports[\"default\"] = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/runtime/ucs2length.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/runtime/uri.js"
/*!**************************************************!*\
  !*** ../../node_modules/ajv/dist/runtime/uri.js ***!
  \**************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst uri = __webpack_require__(/*! fast-uri */ \"../../node_modules/fast-uri/index.js\");\nuri.code = 'require(\"ajv/dist/runtime/uri\").default';\nexports[\"default\"] = uri;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/runtime/uri.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/runtime/validation_error.js"
/*!***************************************************************!*\
  !*** ../../node_modules/ajv/dist/runtime/validation_error.js ***!
  \***************************************************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports[\"default\"] = ValidationError;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/runtime/validation_error.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"
/*!******************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js ***!
  \******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"
/*!***********************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js ***!
  \***********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"../../node_modules/ajv/dist/compile/names.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/allOf.js"
/*!********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/allOf.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/allOf.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js"
/*!********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/contains.js"
/*!***********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/contains.js ***!
  \***********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/contains.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js"
/*!***************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js ***!
  \***************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/if.js"
/*!*****************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/if.js ***!
  \*****************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/if.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/index.js"
/*!********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/index.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst additionalItems_1 = __webpack_require__(/*! ./additionalItems */ \"../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\");\nconst prefixItems_1 = __webpack_require__(/*! ./prefixItems */ \"../../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\");\nconst items_1 = __webpack_require__(/*! ./items */ \"../../node_modules/ajv/dist/vocabularies/applicator/items.js\");\nconst items2020_1 = __webpack_require__(/*! ./items2020 */ \"../../node_modules/ajv/dist/vocabularies/applicator/items2020.js\");\nconst contains_1 = __webpack_require__(/*! ./contains */ \"../../node_modules/ajv/dist/vocabularies/applicator/contains.js\");\nconst dependencies_1 = __webpack_require__(/*! ./dependencies */ \"../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js\");\nconst propertyNames_1 = __webpack_require__(/*! ./propertyNames */ \"../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\");\nconst additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ \"../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\");\nconst properties_1 = __webpack_require__(/*! ./properties */ \"../../node_modules/ajv/dist/vocabularies/applicator/properties.js\");\nconst patternProperties_1 = __webpack_require__(/*! ./patternProperties */ \"../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\");\nconst not_1 = __webpack_require__(/*! ./not */ \"../../node_modules/ajv/dist/vocabularies/applicator/not.js\");\nconst anyOf_1 = __webpack_require__(/*! ./anyOf */ \"../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js\");\nconst oneOf_1 = __webpack_require__(/*! ./oneOf */ \"../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js\");\nconst allOf_1 = __webpack_require__(/*! ./allOf */ \"../../node_modules/ajv/dist/vocabularies/applicator/allOf.js\");\nconst if_1 = __webpack_require__(/*! ./if */ \"../../node_modules/ajv/dist/vocabularies/applicator/if.js\");\nconst thenElse_1 = __webpack_require__(/*! ./thenElse */ \"../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports[\"default\"] = getApplicator;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/index.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/items.js"
/*!********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/items.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateTuple = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/items.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/items2020.js"
/*!************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/items2020.js ***!
  \************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst additionalItems_1 = __webpack_require__(/*! ./additionalItems */ \"../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/items2020.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/not.js"
/*!******************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/not.js ***!
  \******************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/not.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js"
/*!********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"
/*!********************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js ***!
  \********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst util_2 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"
/*!**************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js ***!
  \**************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst items_1 = __webpack_require__(/*! ./items */ \"../../node_modules/ajv/dist/vocabularies/applicator/items.js\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/properties.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/properties.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_1 = __webpack_require__(/*! ../../compile/validate */ \"../../node_modules/ajv/dist/compile/validate/index.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ \"../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/properties.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"
/*!****************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js ***!
  \****************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js"
/*!***********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js ***!
  \***********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/code.js"
/*!********************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/code.js ***!
  \********************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = __webpack_require__(/*! ../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ../compile/names */ \"../../node_modules/ajv/dist/compile/names.js\");\nconst util_2 = __webpack_require__(/*! ../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/code.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/core/id.js"
/*!***********************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/core/id.js ***!
  \***********************************************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/core/id.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/core/index.js"
/*!**************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/core/index.js ***!
  \**************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst id_1 = __webpack_require__(/*! ./id */ \"../../node_modules/ajv/dist/vocabularies/core/id.js\");\nconst ref_1 = __webpack_require__(/*! ./ref */ \"../../node_modules/ajv/dist/vocabularies/core/ref.js\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports[\"default\"] = core;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/core/index.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/core/ref.js"
/*!************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/core/ref.js ***!
  \************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = __webpack_require__(/*! ../../compile/ref_error */ \"../../node_modules/ajv/dist/compile/ref_error.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"../../node_modules/ajv/dist/compile/names.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"../../node_modules/ajv/dist/compile/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/core/ref.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/discriminator/index.js"
/*!***********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/discriminator/index.js ***!
  \***********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst types_1 = __webpack_require__(/*! ../discriminator/types */ \"../../node_modules/ajv/dist/vocabularies/discriminator/types.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"../../node_modules/ajv/dist/compile/index.js\");\nconst ref_error_1 = __webpack_require__(/*! ../../compile/ref_error */ \"../../node_modules/ajv/dist/compile/ref_error.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    const ref = sch.$ref;\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                    if (sch === undefined)\n                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/discriminator/index.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/discriminator/types.js"
/*!***********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/discriminator/types.js ***!
  \***********************************************************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError || (exports.DiscrError = DiscrError = {}));\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/discriminator/types.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/draft7.js"
/*!**********************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/draft7.js ***!
  \**********************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core_1 = __webpack_require__(/*! ./core */ \"../../node_modules/ajv/dist/vocabularies/core/index.js\");\nconst validation_1 = __webpack_require__(/*! ./validation */ \"../../node_modules/ajv/dist/vocabularies/validation/index.js\");\nconst applicator_1 = __webpack_require__(/*! ./applicator */ \"../../node_modules/ajv/dist/vocabularies/applicator/index.js\");\nconst format_1 = __webpack_require__(/*! ./format */ \"../../node_modules/ajv/dist/vocabularies/format/index.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"../../node_modules/ajv/dist/vocabularies/metadata.js\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports[\"default\"] = draft7Vocabularies;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/draft7.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/format/format.js"
/*!*****************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/format/format.js ***!
  \*****************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/format/format.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/format/index.js"
/*!****************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/format/index.js ***!
  \****************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst format_1 = __webpack_require__(/*! ./format */ \"../../node_modules/ajv/dist/vocabularies/format/format.js\");\nconst format = [format_1.default];\nexports[\"default\"] = format;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/format/index.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/metadata.js"
/*!************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/metadata.js ***!
  \************************************************************/
(__unused_webpack_module, exports) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/metadata.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/const.js"
/*!********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/const.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/const.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/enum.js"
/*!*******************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/enum.js ***!
  \*******************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/enum.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/index.js"
/*!********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/index.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst limitNumber_1 = __webpack_require__(/*! ./limitNumber */ \"../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js\");\nconst multipleOf_1 = __webpack_require__(/*! ./multipleOf */ \"../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js\");\nconst limitLength_1 = __webpack_require__(/*! ./limitLength */ \"../../node_modules/ajv/dist/vocabularies/validation/limitLength.js\");\nconst pattern_1 = __webpack_require__(/*! ./pattern */ \"../../node_modules/ajv/dist/vocabularies/validation/pattern.js\");\nconst limitProperties_1 = __webpack_require__(/*! ./limitProperties */ \"../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js\");\nconst required_1 = __webpack_require__(/*! ./required */ \"../../node_modules/ajv/dist/vocabularies/validation/required.js\");\nconst limitItems_1 = __webpack_require__(/*! ./limitItems */ \"../../node_modules/ajv/dist/vocabularies/validation/limitItems.js\");\nconst uniqueItems_1 = __webpack_require__(/*! ./uniqueItems */ \"../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\");\nconst const_1 = __webpack_require__(/*! ./const */ \"../../node_modules/ajv/dist/vocabularies/validation/const.js\");\nconst enum_1 = __webpack_require__(/*! ./enum */ \"../../node_modules/ajv/dist/vocabularies/validation/enum.js\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports[\"default\"] = validation;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/index.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/limitItems.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/limitItems.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/limitItems.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/limitLength.js"
/*!**************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/limitLength.js ***!
  \**************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst ucs2length_1 = __webpack_require__(/*! ../../runtime/ucs2length */ \"../../node_modules/ajv/dist/runtime/ucs2length.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/limitLength.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js"
/*!**************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js ***!
  \**************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js"
/*!******************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js ***!
  \******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/pattern.js"
/*!**********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/pattern.js ***!
  \**********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/pattern.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/required.js"
/*!***********************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/required.js ***!
  \***********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/required.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"
/*!**************************************************************************!*\
  !*** ../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js ***!
  \**************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dataType_1 = __webpack_require__(/*! ../../compile/validate/dataType */ \"../../node_modules/ajv/dist/compile/validate/dataType.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports[\"default\"] = def;\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js?\n}");

/***/ },

/***/ "../../node_modules/ajv/node_modules/json-schema-traverse/index.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/ajv/node_modules/json-schema-traverse/index.js ***!
  \*************************************************************************/
(module) {

"use strict";
eval("{\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/ajv/node_modules/json-schema-traverse/index.js?\n}");

/***/ },

/***/ "../../node_modules/fast-deep-equal/index.js"
/*!***************************************************!*\
  !*** ../../node_modules/fast-deep-equal/index.js ***!
  \***************************************************/
(module) {

"use strict";
eval("{\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/fast-deep-equal/index.js?\n}");

/***/ },

/***/ "../../node_modules/fast-uri/index.js"
/*!********************************************!*\
  !*** ../../node_modules/fast-uri/index.js ***!
  \********************************************/
(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("{\n\nconst { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = __webpack_require__(/*! ./lib/utils */ \"../../node_modules/fast-uri/lib/utils.js\")\nconst { SCHEMES, getSchemeHandler } = __webpack_require__(/*! ./lib/schemes */ \"../../node_modules/fast-uri/lib/schemes.js\")\n\n/**\n * @template {import('./types/index').URIComponent|string} T\n * @param {T} uri\n * @param {import('./types/index').Options} [options]\n * @returns {T}\n */\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = /** @type {T} */ (serialize(parse(uri, options), options))\n  } else if (typeof uri === 'object') {\n    uri = /** @type {T} */ (parse(serialize(uri, options), options))\n  }\n  return uri\n}\n\n/**\n * @param {string} baseURI\n * @param {string} relativeURI\n * @param {import('./types/index').Options} [options]\n * @returns {string}\n */\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = options ? Object.assign({ scheme: 'null' }, options) : { scheme: 'null' }\n  const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  schemelessOptions.skipEscape = true\n  return serialize(resolved, schemelessOptions)\n}\n\n/**\n * @param {import ('./types/index').URIComponent} base\n * @param {import ('./types/index').URIComponent} relative\n * @param {import('./types/index').Options} [options]\n * @param {boolean} [skipNormalization=false]\n * @returns {import ('./types/index').URIComponent}\n */\nfunction resolveComponent (base, relative, options, skipNormalization) {\n  /** @type {import('./types/index').URIComponent} */\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base component\n    relative = parse(serialize(relative, options), options) // normalize relative component\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path[0] === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\n/**\n * @param {import ('./types/index').URIComponent|string} uriA\n * @param {import ('./types/index').URIComponent|string} uriB\n * @param {import ('./types/index').Options} options\n * @returns {boolean}\n */\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\n/**\n * @param {Readonly<import('./types/index').URIComponent>} cmpts\n * @param {import('./types/index').Options} [opts]\n * @returns {string}\n */\nfunction serialize (cmpts, opts) {\n  const component = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = getSchemeHandler(options.scheme || component.scheme)\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options)\n\n  if (component.path !== undefined) {\n    if (!options.skipEscape) {\n      component.path = escape(component.path)\n\n      if (component.scheme !== undefined) {\n        component.path = component.path.split('%3A').join(':')\n      }\n    } else {\n      component.path = unescape(component.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && component.scheme) {\n    uriTokens.push(component.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(component)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (component.path && component.path[0] !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (component.path !== undefined) {\n    let s = component.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (\n      authority === undefined &&\n      s[0] === '/' &&\n      s[1] === '/'\n    ) {\n      // don't allow the path to start with \"//\"\n      s = '/%2F' + s.slice(2)\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (component.query !== undefined) {\n    uriTokens.push('?', component.query)\n  }\n\n  if (component.fragment !== undefined) {\n    uriTokens.push('#', component.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\n/**\n * @param {string} uri\n * @param {import('./types/index').Options} [opts]\n * @returns\n */\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  /** @type {import('./types/index').URIComponent} */\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n\n  let isIP = false\n  if (options.reference === 'suffix') {\n    if (options.scheme) {\n      uri = options.scheme + ':' + uri\n    } else {\n      uri = '//' + uri\n    }\n  }\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = isIPv4(parsed.host)\n      if (ipv4result === false) {\n        const ipv6result = normalizeIPv6(parsed.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme)\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (uri.indexOf('%') !== -1) {\n        if (parsed.scheme !== undefined) {\n          parsed.scheme = unescape(parsed.scheme)\n        }\n        if (parsed.host !== undefined) {\n          parsed.host = unescape(parsed.host)\n        }\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponent,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports[\"default\"] = fastUri\nmodule.exports.fastUri = fastUri\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/fast-uri/index.js?\n}");

/***/ },

/***/ "../../node_modules/fast-uri/lib/schemes.js"
/*!**************************************************!*\
  !*** ../../node_modules/fast-uri/lib/schemes.js ***!
  \**************************************************/
(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("{\n\nconst { isUUID } = __webpack_require__(/*! ./utils */ \"../../node_modules/fast-uri/lib/utils.js\")\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nconst supportedSchemeNames = /** @type {const} */ (['http', 'https', 'ws',\n  'wss', 'urn', 'urn:uuid'])\n\n/** @typedef {supportedSchemeNames[number]} SchemeName */\n\n/**\n * @param {string} name\n * @returns {name is SchemeName}\n */\nfunction isValidSchemeName (name) {\n  return supportedSchemeNames.indexOf(/** @type {*} */ (name)) !== -1\n}\n\n/**\n * @callback SchemeFn\n * @param {import('../types/index').URIComponent} component\n * @param {import('../types/index').Options} options\n * @returns {import('../types/index').URIComponent}\n */\n\n/**\n * @typedef {Object} SchemeHandler\n * @property {SchemeName} scheme - The scheme name.\n * @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.\n * @property {SchemeFn} parse - Function to parse the URI component for this scheme.\n * @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.\n * @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.\n * @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.\n * @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.\n */\n\n/**\n * @param {import('../types/index').URIComponent} wsComponent\n * @returns {boolean}\n */\nfunction wsIsSecure (wsComponent) {\n  if (wsComponent.secure === true) {\n    return true\n  } else if (wsComponent.secure === false) {\n    return false\n  } else if (wsComponent.scheme) {\n    return (\n      wsComponent.scheme.length === 3 &&\n      (wsComponent.scheme[0] === 'w' || wsComponent.scheme[0] === 'W') &&\n      (wsComponent.scheme[1] === 's' || wsComponent.scheme[1] === 'S') &&\n      (wsComponent.scheme[2] === 's' || wsComponent.scheme[2] === 'S')\n    )\n  } else {\n    return false\n  }\n}\n\n/** @type {SchemeFn} */\nfunction httpParse (component) {\n  if (!component.host) {\n    component.error = component.error || 'HTTP URIs must have a host.'\n  }\n\n  return component\n}\n\n/** @type {SchemeFn} */\nfunction httpSerialize (component) {\n  const secure = String(component.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (component.port === (secure ? 443 : 80) || component.port === '') {\n    component.port = undefined\n  }\n\n  // normalize the empty path\n  if (!component.path) {\n    component.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return component\n}\n\n/** @type {SchemeFn} */\nfunction wsParse (wsComponent) {\n// indicate if the secure flag is set\n  wsComponent.secure = wsIsSecure(wsComponent)\n\n  // construct resouce name\n  wsComponent.resourceName = (wsComponent.path || '/') + (wsComponent.query ? '?' + wsComponent.query : '')\n  wsComponent.path = undefined\n  wsComponent.query = undefined\n\n  return wsComponent\n}\n\n/** @type {SchemeFn} */\nfunction wsSerialize (wsComponent) {\n// normalize the default port\n  if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === '') {\n    wsComponent.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponent.secure === 'boolean') {\n    wsComponent.scheme = (wsComponent.secure ? 'wss' : 'ws')\n    wsComponent.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponent.resourceName) {\n    const [path, query] = wsComponent.resourceName.split('?')\n    wsComponent.path = (path && path !== '/' ? path : undefined)\n    wsComponent.query = query\n    wsComponent.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponent.fragment = undefined\n\n  return wsComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnParse (urnComponent, options) {\n  if (!urnComponent.path) {\n    urnComponent.error = 'URN can not be parsed'\n    return urnComponent\n  }\n  const matches = urnComponent.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponent.scheme || 'urn'\n    urnComponent.nid = matches[1].toLowerCase()\n    urnComponent.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`\n    const schemeHandler = getSchemeHandler(urnScheme)\n    urnComponent.path = undefined\n\n    if (schemeHandler) {\n      urnComponent = schemeHandler.parse(urnComponent, options)\n    }\n  } else {\n    urnComponent.error = urnComponent.error || 'URN can not be parsed.'\n  }\n\n  return urnComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnSerialize (urnComponent, options) {\n  if (urnComponent.nid === undefined) {\n    throw new Error('URN without nid cannot be serialized')\n  }\n  const scheme = options.scheme || urnComponent.scheme || 'urn'\n  const nid = urnComponent.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = getSchemeHandler(urnScheme)\n\n  if (schemeHandler) {\n    urnComponent = schemeHandler.serialize(urnComponent, options)\n  }\n\n  const uriComponent = urnComponent\n  const nss = urnComponent.nss\n  uriComponent.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnuuidParse (urnComponent, options) {\n  const uuidComponent = urnComponent\n  uuidComponent.uuid = uuidComponent.nss\n  uuidComponent.nss = undefined\n\n  if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {\n    uuidComponent.error = uuidComponent.error || 'UUID is not valid.'\n  }\n\n  return uuidComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnuuidSerialize (uuidComponent) {\n  const urnComponent = uuidComponent\n  // normalize UUID\n  urnComponent.nss = (uuidComponent.uuid || '').toLowerCase()\n  return urnComponent\n}\n\nconst http = /** @type {SchemeHandler} */ ({\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n})\n\nconst https = /** @type {SchemeHandler} */ ({\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n})\n\nconst ws = /** @type {SchemeHandler} */ ({\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n})\n\nconst wss = /** @type {SchemeHandler} */ ({\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n})\n\nconst urn = /** @type {SchemeHandler} */ ({\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n})\n\nconst urnuuid = /** @type {SchemeHandler} */ ({\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n})\n\nconst SCHEMES = /** @type {Record<SchemeName, SchemeHandler>} */ ({\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n})\n\nObject.setPrototypeOf(SCHEMES, null)\n\n/**\n * @param {string|undefined} scheme\n * @returns {SchemeHandler|undefined}\n */\nfunction getSchemeHandler (scheme) {\n  return (\n    scheme && (\n      SCHEMES[/** @type {SchemeName} */ (scheme)] ||\n      SCHEMES[/** @type {SchemeName} */(scheme.toLowerCase())])\n  ) ||\n    undefined\n}\n\nmodule.exports = {\n  wsIsSecure,\n  SCHEMES,\n  isValidSchemeName,\n  getSchemeHandler,\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/fast-uri/lib/schemes.js?\n}");

/***/ },

/***/ "../../node_modules/fast-uri/lib/utils.js"
/*!************************************************!*\
  !*** ../../node_modules/fast-uri/lib/utils.js ***!
  \************************************************/
(module) {

"use strict";
eval("{\n\n/** @type {(value: string) => boolean} */\nconst isUUID = RegExp.prototype.test.bind(/^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu)\n\n/** @type {(value: string) => boolean} */\nconst isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u)\n\n/**\n * @param {Array<string>} input\n * @returns {string}\n */\nfunction stringArrayToHexStripped (input) {\n  let acc = ''\n  let code = 0\n  let i = 0\n\n  for (i = 0; i < input.length; i++) {\n    code = input[i].charCodeAt(0)\n    if (code === 48) {\n      continue\n    }\n    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {\n      return ''\n    }\n    acc += input[i]\n    break\n  }\n\n  for (i += 1; i < input.length; i++) {\n    code = input[i].charCodeAt(0)\n    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {\n      return ''\n    }\n    acc += input[i]\n  }\n  return acc\n}\n\n/**\n * @typedef {Object} GetIPV6Result\n * @property {boolean} error - Indicates if there was an error parsing the IPv6 address.\n * @property {string} address - The parsed IPv6 address.\n * @property {string} [zone] - The zone identifier, if present.\n */\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nconst nonSimpleDomain = RegExp.prototype.test.bind(/[^!\"$&'()*+,\\-.;=_`a-z{}~]/u)\n\n/**\n * @param {Array<string>} buffer\n * @returns {boolean}\n */\nfunction consumeIsZone (buffer) {\n  buffer.length = 0\n  return true\n}\n\n/**\n * @param {Array<string>} buffer\n * @param {Array<string>} address\n * @param {GetIPV6Result} output\n * @returns {boolean}\n */\nfunction consumeHextets (buffer, address, output) {\n  if (buffer.length) {\n    const hex = stringArrayToHexStripped(buffer)\n    if (hex !== '') {\n      address.push(hex)\n    } else {\n      output.error = true\n      return false\n    }\n    buffer.length = 0\n  }\n  return true\n}\n\n/**\n * @param {string} input\n * @returns {GetIPV6Result}\n */\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  /** @type {Array<string>} */\n  const address = []\n  /** @type {Array<string>} */\n  const buffer = []\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  let consume = consumeHextets\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume(buffer, address, output)) { break }\n      if (++tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i > 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      address.push(':')\n      continue\n    } else if (cursor === '%') {\n      if (!consume(buffer, address, output)) { break }\n      // switch to zone detection\n      consume = consumeIsZone\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (consume === consumeIsZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\n/**\n * @typedef {Object} NormalizeIPv6Result\n * @property {string} host - The normalized host.\n * @property {string} [escapedHost] - The escaped host.\n * @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.\n */\n\n/**\n * @param {string} host\n * @returns {NormalizeIPv6Result}\n */\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, isIPV6: true, escapedHost }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\n/**\n * @param {string} str\n * @param {string} token\n * @returns {number}\n */\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\n/**\n * @param {string} path\n * @returns {string}\n *\n * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4\n */\nfunction removeDotSegments (path) {\n  let input = path\n  const output = []\n  let nextSlash = -1\n  let len = 0\n\n  // eslint-disable-next-line no-cond-assign\n  while (len = input.length) {\n    if (len === 1) {\n      if (input === '.') {\n        break\n      } else if (input === '/') {\n        output.push('/')\n        break\n      } else {\n        output.push(input)\n        break\n      }\n    } else if (len === 2) {\n      if (input[0] === '.') {\n        if (input[1] === '.') {\n          break\n        } else if (input[1] === '/') {\n          input = input.slice(2)\n          continue\n        }\n      } else if (input[0] === '/') {\n        if (input[1] === '.' || input[1] === '/') {\n          output.push('/')\n          break\n        }\n      }\n    } else if (len === 3) {\n      if (input === '/..') {\n        if (output.length !== 0) {\n          output.pop()\n        }\n        output.push('/')\n        break\n      }\n    }\n    if (input[0] === '.') {\n      if (input[1] === '.') {\n        if (input[2] === '/') {\n          input = input.slice(3)\n          continue\n        }\n      } else if (input[1] === '/') {\n        input = input.slice(2)\n        continue\n      }\n    } else if (input[0] === '/') {\n      if (input[1] === '.') {\n        if (input[2] === '/') {\n          input = input.slice(2)\n          continue\n        } else if (input[2] === '.') {\n          if (input[3] === '/') {\n            input = input.slice(3)\n            if (output.length !== 0) {\n              output.pop()\n            }\n            continue\n          }\n        }\n      }\n    }\n\n    // Rule 2E: Move normal path segment to output\n    if ((nextSlash = input.indexOf('/', 1)) === -1) {\n      output.push(input)\n      break\n    } else {\n      output.push(input.slice(0, nextSlash))\n      input = input.slice(nextSlash)\n    }\n  }\n\n  return output.join('')\n}\n\n/**\n * @param {import('../types/index').URIComponent} component\n * @param {boolean} esc\n * @returns {import('../types/index').URIComponent}\n */\nfunction normalizeComponentEncoding (component, esc) {\n  const func = esc !== true ? escape : unescape\n  if (component.scheme !== undefined) {\n    component.scheme = func(component.scheme)\n  }\n  if (component.userinfo !== undefined) {\n    component.userinfo = func(component.userinfo)\n  }\n  if (component.host !== undefined) {\n    component.host = func(component.host)\n  }\n  if (component.path !== undefined) {\n    component.path = func(component.path)\n  }\n  if (component.query !== undefined) {\n    component.query = func(component.query)\n  }\n  if (component.fragment !== undefined) {\n    component.fragment = func(component.fragment)\n  }\n  return component\n}\n\n/**\n * @param {import('../types/index').URIComponent} component\n * @returns {string|undefined}\n */\nfunction recomposeAuthority (component) {\n  const uriTokens = []\n\n  if (component.userinfo !== undefined) {\n    uriTokens.push(component.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (component.host !== undefined) {\n    let host = unescape(component.host)\n    if (!isIPv4(host)) {\n      const ipV6res = normalizeIPv6(host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = component.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof component.port === 'number' || typeof component.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(component.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  nonSimpleDomain,\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  isIPv4,\n  isUUID,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/fast-uri/lib/utils.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/array.js"
/*!****************************************!*\
  !*** ../../node_modules/lib0/array.js ***!
  \****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendTo: () => (/* binding */ appendTo),\n/* harmony export */   bubblesortItem: () => (/* binding */ bubblesortItem),\n/* harmony export */   copy: () => (/* binding */ copy),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   equalFlat: () => (/* binding */ equalFlat),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   fold: () => (/* binding */ fold),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   unfold: () => (/* binding */ unfold),\n/* harmony export */   unique: () => (/* binding */ unique),\n/* harmony export */   uniqueBy: () => (/* binding */ uniqueBy)\n/* harmony export */ });\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./set.js */ \"../../node_modules/lib0/set.js\");\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nconst last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nconst create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nconst copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nconst appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template {ArrayLike<any>} ARR\n *\n * @param {ARR} arr\n * @param {ARR extends ArrayLike<infer S> ? ((value:S, index:number, arr:ARR) => boolean) : any} f\n * @return {boolean}\n */\nconst every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template {ArrayLike<any>} ARR\n *\n * @param {ARR} arr\n * @param {ARR extends ArrayLike<infer S> ? ((value:S, index:number, arr:ARR) => boolean) : never} f\n * @return {boolean}\n */\nconst some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nconst flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nconst unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nconst fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nconst isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nconst unique = arr => from(_set_js__WEBPACK_IMPORTED_MODULE_0__.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nconst uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = _set_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nconst map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n\n/**\n * This function bubble-sorts a single item to the correct position. The sort happens in-place and\n * might be useful to ensure that a single item is at the correct position in an otherwise sorted\n * array.\n *\n * @example\n *  const arr = [3, 2, 5]\n *  arr.sort((a, b) => a - b)\n *  arr // => [2, 3, 5]\n *  arr.splice(1, 0, 7)\n *  array.bubbleSortItem(arr, 1, (a, b) => a - b)\n *  arr // => [2, 3, 5, 7]\n *\n * @template T\n * @param {Array<T>} arr\n * @param {number} i\n * @param {(a:T,b:T) => number} compareFn\n */\nconst bubblesortItem = (arr, i, compareFn) => {\n  const n = arr[i]\n  let j = i\n  // try to sort to the right\n  while (j + 1 < arr.length && compareFn(n, arr[j + 1]) > 0) {\n    arr[j] = arr[j + 1]\n    arr[++j] = n\n  }\n  if (i === j && j > 0) { // no change yet\n    // sort to the left\n    while (j > 0 && compareFn(arr[j - 1], n) > 0) {\n      arr[j] = arr[j - 1]\n      arr[--j] = n\n    }\n  }\n  return j\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/array.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/binary.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/binary.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIT1: () => (/* binding */ BIT1),\n/* harmony export */   BIT10: () => (/* binding */ BIT10),\n/* harmony export */   BIT11: () => (/* binding */ BIT11),\n/* harmony export */   BIT12: () => (/* binding */ BIT12),\n/* harmony export */   BIT13: () => (/* binding */ BIT13),\n/* harmony export */   BIT14: () => (/* binding */ BIT14),\n/* harmony export */   BIT15: () => (/* binding */ BIT15),\n/* harmony export */   BIT16: () => (/* binding */ BIT16),\n/* harmony export */   BIT17: () => (/* binding */ BIT17),\n/* harmony export */   BIT18: () => (/* binding */ BIT18),\n/* harmony export */   BIT19: () => (/* binding */ BIT19),\n/* harmony export */   BIT2: () => (/* binding */ BIT2),\n/* harmony export */   BIT20: () => (/* binding */ BIT20),\n/* harmony export */   BIT21: () => (/* binding */ BIT21),\n/* harmony export */   BIT22: () => (/* binding */ BIT22),\n/* harmony export */   BIT23: () => (/* binding */ BIT23),\n/* harmony export */   BIT24: () => (/* binding */ BIT24),\n/* harmony export */   BIT25: () => (/* binding */ BIT25),\n/* harmony export */   BIT26: () => (/* binding */ BIT26),\n/* harmony export */   BIT27: () => (/* binding */ BIT27),\n/* harmony export */   BIT28: () => (/* binding */ BIT28),\n/* harmony export */   BIT29: () => (/* binding */ BIT29),\n/* harmony export */   BIT3: () => (/* binding */ BIT3),\n/* harmony export */   BIT30: () => (/* binding */ BIT30),\n/* harmony export */   BIT31: () => (/* binding */ BIT31),\n/* harmony export */   BIT32: () => (/* binding */ BIT32),\n/* harmony export */   BIT4: () => (/* binding */ BIT4),\n/* harmony export */   BIT5: () => (/* binding */ BIT5),\n/* harmony export */   BIT6: () => (/* binding */ BIT6),\n/* harmony export */   BIT7: () => (/* binding */ BIT7),\n/* harmony export */   BIT8: () => (/* binding */ BIT8),\n/* harmony export */   BIT9: () => (/* binding */ BIT9),\n/* harmony export */   BITS0: () => (/* binding */ BITS0),\n/* harmony export */   BITS1: () => (/* binding */ BITS1),\n/* harmony export */   BITS10: () => (/* binding */ BITS10),\n/* harmony export */   BITS11: () => (/* binding */ BITS11),\n/* harmony export */   BITS12: () => (/* binding */ BITS12),\n/* harmony export */   BITS13: () => (/* binding */ BITS13),\n/* harmony export */   BITS14: () => (/* binding */ BITS14),\n/* harmony export */   BITS15: () => (/* binding */ BITS15),\n/* harmony export */   BITS16: () => (/* binding */ BITS16),\n/* harmony export */   BITS17: () => (/* binding */ BITS17),\n/* harmony export */   BITS18: () => (/* binding */ BITS18),\n/* harmony export */   BITS19: () => (/* binding */ BITS19),\n/* harmony export */   BITS2: () => (/* binding */ BITS2),\n/* harmony export */   BITS20: () => (/* binding */ BITS20),\n/* harmony export */   BITS21: () => (/* binding */ BITS21),\n/* harmony export */   BITS22: () => (/* binding */ BITS22),\n/* harmony export */   BITS23: () => (/* binding */ BITS23),\n/* harmony export */   BITS24: () => (/* binding */ BITS24),\n/* harmony export */   BITS25: () => (/* binding */ BITS25),\n/* harmony export */   BITS26: () => (/* binding */ BITS26),\n/* harmony export */   BITS27: () => (/* binding */ BITS27),\n/* harmony export */   BITS28: () => (/* binding */ BITS28),\n/* harmony export */   BITS29: () => (/* binding */ BITS29),\n/* harmony export */   BITS3: () => (/* binding */ BITS3),\n/* harmony export */   BITS30: () => (/* binding */ BITS30),\n/* harmony export */   BITS31: () => (/* binding */ BITS31),\n/* harmony export */   BITS32: () => (/* binding */ BITS32),\n/* harmony export */   BITS4: () => (/* binding */ BITS4),\n/* harmony export */   BITS5: () => (/* binding */ BITS5),\n/* harmony export */   BITS6: () => (/* binding */ BITS6),\n/* harmony export */   BITS7: () => (/* binding */ BITS7),\n/* harmony export */   BITS8: () => (/* binding */ BITS8),\n/* harmony export */   BITS9: () => (/* binding */ BITS9)\n/* harmony export */ });\n/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nconst BIT1 = 1\nconst BIT2 = 2\nconst BIT3 = 4\nconst BIT4 = 8\nconst BIT5 = 16\nconst BIT6 = 32\nconst BIT7 = 64\nconst BIT8 = 128\nconst BIT9 = 256\nconst BIT10 = 512\nconst BIT11 = 1024\nconst BIT12 = 2048\nconst BIT13 = 4096\nconst BIT14 = 8192\nconst BIT15 = 16384\nconst BIT16 = 32768\nconst BIT17 = 65536\nconst BIT18 = 1 << 17\nconst BIT19 = 1 << 18\nconst BIT20 = 1 << 19\nconst BIT21 = 1 << 20\nconst BIT22 = 1 << 21\nconst BIT23 = 1 << 22\nconst BIT24 = 1 << 23\nconst BIT25 = 1 << 24\nconst BIT26 = 1 << 25\nconst BIT27 = 1 << 26\nconst BIT28 = 1 << 27\nconst BIT29 = 1 << 28\nconst BIT30 = 1 << 29\nconst BIT31 = 1 << 30\nconst BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nconst BITS0 = 0\nconst BITS1 = 1\nconst BITS2 = 3\nconst BITS3 = 7\nconst BITS4 = 15\nconst BITS5 = 31\nconst BITS6 = 63\nconst BITS7 = 127\nconst BITS8 = 255\nconst BITS9 = 511\nconst BITS10 = 1023\nconst BITS11 = 2047\nconst BITS12 = 4095\nconst BITS13 = 8191\nconst BITS14 = 16383\nconst BITS15 = 32767\nconst BITS16 = 65535\nconst BITS17 = BIT18 - 1\nconst BITS18 = BIT19 - 1\nconst BITS19 = BIT20 - 1\nconst BITS20 = BIT21 - 1\nconst BITS21 = BIT22 - 1\nconst BITS22 = BIT23 - 1\nconst BITS23 = BIT24 - 1\nconst BITS24 = BIT25 - 1\nconst BITS25 = BIT26 - 1\nconst BITS26 = BIT27 - 1\nconst BITS27 = BIT28 - 1\nconst BITS28 = BIT29 - 1\nconst BITS29 = BIT30 - 1\nconst BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nconst BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nconst BITS32 = 0xFFFFFFFF\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/binary.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/buffer.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/buffer.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   copyUint8Array: () => (/* binding */ copyUint8Array),\n/* harmony export */   createUint8ArrayFromArrayBuffer: () => (/* binding */ createUint8ArrayFromArrayBuffer),\n/* harmony export */   createUint8ArrayFromLen: () => (/* binding */ createUint8ArrayFromLen),\n/* harmony export */   createUint8ArrayViewFromArrayBuffer: () => (/* binding */ createUint8ArrayViewFromArrayBuffer),\n/* harmony export */   decodeAny: () => (/* binding */ decodeAny),\n/* harmony export */   encodeAny: () => (/* binding */ encodeAny),\n/* harmony export */   fromBase64: () => (/* binding */ fromBase64),\n/* harmony export */   fromBase64UrlEncoded: () => (/* binding */ fromBase64UrlEncoded),\n/* harmony export */   fromHexString: () => (/* binding */ fromHexString),\n/* harmony export */   shiftNBitsLeft: () => (/* binding */ shiftNBitsLeft),\n/* harmony export */   toBase64: () => (/* binding */ toBase64),\n/* harmony export */   toBase64UrlEncoded: () => (/* binding */ toBase64UrlEncoded),\n/* harmony export */   toHexString: () => (/* binding */ toHexString)\n/* harmony export */ });\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string.js */ \"../../node_modules/lib0/string.js\");\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ \"../../node_modules/lib0/environment.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ \"../../node_modules/lib0/array.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./encoding.js */ \"../../node_modules/lib0/encoding.js\");\n/* harmony import */ var _decoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./decoding.js */ \"../../node_modules/lib0/decoding.js\");\n/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\n\n\n\n\n\n\n\n/**\n * @param {number} len\n */\nconst createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nconst createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nconst createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* c8 ignore start */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += _string_js__WEBPACK_IMPORTED_MODULE_0__.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* c8 ignore start */\n/**\n * @param {string} s\n * @return {Uint8Array<ArrayBuffer>}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* c8 ignore next */\nconst toBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? toBase64Browser : toBase64Node\n\n/* c8 ignore next */\nconst fromBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Implements base64url - see https://datatracker.ietf.org/doc/html/rfc4648#section-5\n * @param {Uint8Array} buf\n */\nconst toBase64UrlEncoded = buf => toBase64(buf).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '')\n\n/**\n * @param {string} base64\n */\nconst fromBase64UrlEncoded = base64 => fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'))\n\n/**\n * Base64 is always a more efficient choice. This exists for utility purposes only.\n *\n * @param {Uint8Array} buf\n */\nconst toHexString = buf => _array_js__WEBPACK_IMPORTED_MODULE_2__.map(buf, b => b.toString(16).padStart(2, '0')).join('')\n\n/**\n * Note: This function expects that the hex doesn't start with 0x..\n *\n * @param {string} hex\n */\nconst fromHexString = hex => {\n  const hlen = hex.length\n  const buf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_3__.ceil(hlen / 2))\n  for (let i = 0; i < hlen; i += 2) {\n    buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16)\n  }\n  return buf\n}\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nconst copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nconst encodeAny = data =>\n  _encoding_js__WEBPACK_IMPORTED_MODULE_4__.encode(encoder => _encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny(encoder, data))\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nconst decodeAny = buf => _decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny(_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf))\n\n/**\n * Shift Byte Array {N} bits to the left. Does not expand byte array.\n *\n * @param {Uint8Array} bs\n * @param {number} N should be in the range of [0-7]\n */\nconst shiftNBitsLeft = (bs, N) => {\n  if (N === 0) return bs\n  bs = new Uint8Array(bs)\n  bs[0] <<= N\n  for (let i = 1; i < bs.length; i++) {\n    bs[i - 1] |= bs[i] >>> (8 - N)\n    bs[i] <<= N\n  }\n  return bs\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/buffer.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/conditions.js"
/*!*********************************************!*\
  !*** ../../node_modules/lib0/conditions.js ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   undefinedToNull: () => (/* binding */ undefinedToNull)\n/* harmony export */ });\n/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* c8 ignore next */\nconst undefinedToNull = v => v === undefined ? null : v\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/conditions.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/decoding.js"
/*!*******************************************!*\
  !*** ../../node_modules/lib0/decoding.js ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoder: () => (/* binding */ Decoder),\n/* harmony export */   IncUintOptRleDecoder: () => (/* binding */ IncUintOptRleDecoder),\n/* harmony export */   IntDiffDecoder: () => (/* binding */ IntDiffDecoder),\n/* harmony export */   IntDiffOptRleDecoder: () => (/* binding */ IntDiffOptRleDecoder),\n/* harmony export */   RleDecoder: () => (/* binding */ RleDecoder),\n/* harmony export */   RleIntDiffDecoder: () => (/* binding */ RleIntDiffDecoder),\n/* harmony export */   StringDecoder: () => (/* binding */ StringDecoder),\n/* harmony export */   UintOptRleDecoder: () => (/* binding */ UintOptRleDecoder),\n/* harmony export */   _readVarStringNative: () => (/* binding */ _readVarStringNative),\n/* harmony export */   _readVarStringPolyfill: () => (/* binding */ _readVarStringPolyfill),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   hasContent: () => (/* binding */ hasContent),\n/* harmony export */   peekUint16: () => (/* binding */ peekUint16),\n/* harmony export */   peekUint32: () => (/* binding */ peekUint32),\n/* harmony export */   peekUint8: () => (/* binding */ peekUint8),\n/* harmony export */   peekVarInt: () => (/* binding */ peekVarInt),\n/* harmony export */   peekVarString: () => (/* binding */ peekVarString),\n/* harmony export */   peekVarUint: () => (/* binding */ peekVarUint),\n/* harmony export */   readAny: () => (/* binding */ readAny),\n/* harmony export */   readBigInt64: () => (/* binding */ readBigInt64),\n/* harmony export */   readBigUint64: () => (/* binding */ readBigUint64),\n/* harmony export */   readFloat32: () => (/* binding */ readFloat32),\n/* harmony export */   readFloat64: () => (/* binding */ readFloat64),\n/* harmony export */   readFromDataView: () => (/* binding */ readFromDataView),\n/* harmony export */   readTailAsUint8Array: () => (/* binding */ readTailAsUint8Array),\n/* harmony export */   readTerminatedString: () => (/* binding */ readTerminatedString),\n/* harmony export */   readTerminatedUint8Array: () => (/* binding */ readTerminatedUint8Array),\n/* harmony export */   readUint16: () => (/* binding */ readUint16),\n/* harmony export */   readUint32: () => (/* binding */ readUint32),\n/* harmony export */   readUint32BigEndian: () => (/* binding */ readUint32BigEndian),\n/* harmony export */   readUint8: () => (/* binding */ readUint8),\n/* harmony export */   readUint8Array: () => (/* binding */ readUint8Array),\n/* harmony export */   readVarInt: () => (/* binding */ readVarInt),\n/* harmony export */   readVarString: () => (/* binding */ readVarString),\n/* harmony export */   readVarUint: () => (/* binding */ readVarUint),\n/* harmony export */   readVarUint8Array: () => (/* binding */ readVarUint8Array),\n/* harmony export */   skip8: () => (/* binding */ skip8)\n/* harmony export */ });\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary.js */ \"../../node_modules/lib0/binary.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ \"../../node_modules/lib0/number.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string.js */ \"../../node_modules/lib0/string.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./error.js */ \"../../node_modules/lib0/error.js\");\n/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./encoding.js */ \"../../node_modules/lib0/encoding.js\");\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\n\n\n\n\n\n\nconst errorUnexpectedEndOfArray = _error_js__WEBPACK_IMPORTED_MODULE_4__.create('Unexpected end of array')\nconst errorIntegerOutOfRange = _error_js__WEBPACK_IMPORTED_MODULE_4__.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n * @template {ArrayBufferLike} [Buf=ArrayBufferLike]\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array<Buf>} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array<Buf>}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @template {ArrayBufferLike} Buf\n * @param {Uint8Array<Buf>} uint8Array\n * @return {Decoder<Buf>}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nconst hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nconst clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @template {ArrayBufferLike} Buf\n * @param {Decoder<Buf>} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array<Buf>}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @template {ArrayBufferLike} Buf\n * @param {Decoder<Buf>} decoder\n * @return {Uint8Array<Buf>}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nconst skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_0__.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > _number_js__WEBPACK_IMPORTED_MODULE_2__.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS6\n  let mult = 64\n  const sign = (r & _binary_js__WEBPACK_IMPORTED_MODULE_0__.BIT7) > 0 ? -1 : 1\n  if ((r & _binary_js__WEBPACK_IMPORTED_MODULE_0__.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS7) * mult\n    mult *= 128\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_0__.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > _number_js__WEBPACK_IMPORTED_MODULE_2__.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (_string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = _string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readTerminatedUint8Array = decoder => {\n  const encoder = _encoding_js__WEBPACK_IMPORTED_MODULE_5__.createEncoder()\n  let b\n  while (true) {\n    b = readUint8(decoder)\n    if (b === 0) {\n      return _encoding_js__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)\n    }\n    if (b === 1) {\n      b = readUint8(decoder)\n    }\n    _encoding_js__WEBPACK_IMPORTED_MODULE_5__.write(encoder, b)\n  }\n}\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nconst readTerminatedString = decoder => _string_js__WEBPACK_IMPORTED_MODULE_3__.decodeUtf8(readTerminatedUint8Array(decoder))\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nconst readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nconst readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nclass RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nclass IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nclass RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_1__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_1__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nclass IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nclass StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/decoding.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/dom.js"
/*!**************************************!*\
  !*** ../../node_modules/lib0/dom.js ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $element: () => (/* binding */ $element),\n/* harmony export */   $fragment: () => (/* binding */ $fragment),\n/* harmony export */   $node: () => (/* binding */ $node),\n/* harmony export */   $text: () => (/* binding */ $text),\n/* harmony export */   CDATA_SECTION_NODE: () => (/* binding */ CDATA_SECTION_NODE),\n/* harmony export */   COMMENT_NODE: () => (/* binding */ COMMENT_NODE),\n/* harmony export */   DOCUMENT_FRAGMENT_NODE: () => (/* binding */ DOCUMENT_FRAGMENT_NODE),\n/* harmony export */   DOCUMENT_NODE: () => (/* binding */ DOCUMENT_NODE),\n/* harmony export */   DOCUMENT_TYPE_NODE: () => (/* binding */ DOCUMENT_TYPE_NODE),\n/* harmony export */   ELEMENT_NODE: () => (/* binding */ ELEMENT_NODE),\n/* harmony export */   TEXT_NODE: () => (/* binding */ TEXT_NODE),\n/* harmony export */   addEventListener: () => (/* binding */ addEventListener),\n/* harmony export */   addEventListeners: () => (/* binding */ addEventListeners),\n/* harmony export */   append: () => (/* binding */ append),\n/* harmony export */   appendChild: () => (/* binding */ appendChild),\n/* harmony export */   canvas: () => (/* binding */ canvas),\n/* harmony export */   checkNodeType: () => (/* binding */ checkNodeType),\n/* harmony export */   createDocumentFragment: () => (/* binding */ createDocumentFragment),\n/* harmony export */   createElement: () => (/* binding */ createElement),\n/* harmony export */   createTextNode: () => (/* binding */ createTextNode),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   domParser: () => (/* binding */ domParser),\n/* harmony export */   element: () => (/* binding */ element),\n/* harmony export */   emitCustomEvent: () => (/* binding */ emitCustomEvent),\n/* harmony export */   fragment: () => (/* binding */ fragment),\n/* harmony export */   getElementById: () => (/* binding */ getElementById),\n/* harmony export */   insertBefore: () => (/* binding */ insertBefore),\n/* harmony export */   isParentOf: () => (/* binding */ isParentOf),\n/* harmony export */   mapToStyleString: () => (/* binding */ mapToStyleString),\n/* harmony export */   pairToStyleString: () => (/* binding */ pairToStyleString),\n/* harmony export */   pairsToStyleString: () => (/* binding */ pairsToStyleString),\n/* harmony export */   parseElement: () => (/* binding */ parseElement),\n/* harmony export */   parseFragment: () => (/* binding */ parseFragment),\n/* harmony export */   querySelector: () => (/* binding */ querySelector),\n/* harmony export */   querySelectorAll: () => (/* binding */ querySelectorAll),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   removeEventListener: () => (/* binding */ removeEventListener),\n/* harmony export */   removeEventListeners: () => (/* binding */ removeEventListeners),\n/* harmony export */   replaceWith: () => (/* binding */ replaceWith),\n/* harmony export */   setAttributes: () => (/* binding */ setAttributes),\n/* harmony export */   setAttributesMap: () => (/* binding */ setAttributesMap),\n/* harmony export */   text: () => (/* binding */ text)\n/* harmony export */ });\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pair.js */ \"../../node_modules/lib0/pair.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ \"../../node_modules/lib0/map.js\");\n/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.js */ \"../../node_modules/lib0/schema.js\");\n/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\n\n\n\n\n/* c8 ignore start */\n/**\n * @type {Document}\n */\nconst doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\nconst createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\nconst createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @type {$.Schema<DocumentFragment>}\n */\nconst $fragment = _schema_js__WEBPACK_IMPORTED_MODULE_2__.$custom(el => el.nodeType === DOCUMENT_FRAGMENT_NODE)\n\n/**\n * @param {string} text\n * @return {Text}\n */\nconst createTextNode = text => doc.createTextNode(text)\n\nconst domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\nconst emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\nconst setAttributes = (el, attrs) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, '')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\nconst setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value) })\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\nconst fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\nconst append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\nconst remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\nconst addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\nconst removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\nconst addEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\nconst removeEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\nconst element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @type {$.Schema<Element>}\n */\nconst $element = _schema_js__WEBPACK_IMPORTED_MODULE_2__.$custom(el => el.nodeType === ELEMENT_NODE)\n\n/**\n * @param {number} width\n * @param {number} height\n */\nconst canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\nconst text = createTextNode\n\n/**\n * @type {$.Schema<Text>}\n */\nconst $text = _schema_js__WEBPACK_IMPORTED_MODULE_2__.$custom(el => el.nodeType === TEXT_NODE)\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\nconst pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\nconst pairsToStyleString = pairs => pairs.map(pairToStyleString).join('')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\nconst mapToStyleString = m => _map_js__WEBPACK_IMPORTED_MODULE_1__.map(m, (value, key) => `${key}:${value};`).join('')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\nconst querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\nconst querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\nconst getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\nconst parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\nconst parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\nconst replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\nconst insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\nconst appendChild = (parent, child) => parent.appendChild(child)\n\nconst ELEMENT_NODE = doc.ELEMENT_NODE\nconst TEXT_NODE = doc.TEXT_NODE\nconst CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nconst COMMENT_NODE = doc.COMMENT_NODE\nconst DOCUMENT_NODE = doc.DOCUMENT_NODE\nconst DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nconst DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @type {$.Schema<Node>}\n */\nconst $node = _schema_js__WEBPACK_IMPORTED_MODULE_2__.$custom(el => el.nodeType === DOCUMENT_NODE)\n\n/**\n * @param {any} node\n * @param {number} type\n */\nconst checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nconst isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n/* c8 ignore stop */\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/dom.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/encoding.js"
/*!*******************************************!*\
  !*** ../../node_modules/lib0/encoding.js ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Encoder: () => (/* binding */ Encoder),\n/* harmony export */   IncUintOptRleEncoder: () => (/* binding */ IncUintOptRleEncoder),\n/* harmony export */   IntDiffEncoder: () => (/* binding */ IntDiffEncoder),\n/* harmony export */   IntDiffOptRleEncoder: () => (/* binding */ IntDiffOptRleEncoder),\n/* harmony export */   RleEncoder: () => (/* binding */ RleEncoder),\n/* harmony export */   RleIntDiffEncoder: () => (/* binding */ RleIntDiffEncoder),\n/* harmony export */   StringEncoder: () => (/* binding */ StringEncoder),\n/* harmony export */   UintOptRleEncoder: () => (/* binding */ UintOptRleEncoder),\n/* harmony export */   _writeVarStringNative: () => (/* binding */ _writeVarStringNative),\n/* harmony export */   _writeVarStringPolyfill: () => (/* binding */ _writeVarStringPolyfill),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   hasContent: () => (/* binding */ hasContent),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setUint16: () => (/* binding */ setUint16),\n/* harmony export */   setUint32: () => (/* binding */ setUint32),\n/* harmony export */   setUint8: () => (/* binding */ setUint8),\n/* harmony export */   toUint8Array: () => (/* binding */ toUint8Array),\n/* harmony export */   verifyLen: () => (/* binding */ verifyLen),\n/* harmony export */   write: () => (/* binding */ write),\n/* harmony export */   writeAny: () => (/* binding */ writeAny),\n/* harmony export */   writeBigInt64: () => (/* binding */ writeBigInt64),\n/* harmony export */   writeBigUint64: () => (/* binding */ writeBigUint64),\n/* harmony export */   writeBinaryEncoder: () => (/* binding */ writeBinaryEncoder),\n/* harmony export */   writeFloat32: () => (/* binding */ writeFloat32),\n/* harmony export */   writeFloat64: () => (/* binding */ writeFloat64),\n/* harmony export */   writeOnDataView: () => (/* binding */ writeOnDataView),\n/* harmony export */   writeTerminatedString: () => (/* binding */ writeTerminatedString),\n/* harmony export */   writeTerminatedUint8Array: () => (/* binding */ writeTerminatedUint8Array),\n/* harmony export */   writeUint16: () => (/* binding */ writeUint16),\n/* harmony export */   writeUint32: () => (/* binding */ writeUint32),\n/* harmony export */   writeUint32BigEndian: () => (/* binding */ writeUint32BigEndian),\n/* harmony export */   writeUint8: () => (/* binding */ writeUint8),\n/* harmony export */   writeUint8Array: () => (/* binding */ writeUint8Array),\n/* harmony export */   writeVarInt: () => (/* binding */ writeVarInt),\n/* harmony export */   writeVarString: () => (/* binding */ writeVarString),\n/* harmony export */   writeVarUint: () => (/* binding */ writeVarUint),\n/* harmony export */   writeVarUint8Array: () => (/* binding */ writeVarUint8Array)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number.js */ \"../../node_modules/lib0/number.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary.js */ \"../../node_modules/lib0/binary.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string.js */ \"../../node_modules/lib0/string.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ \"../../node_modules/lib0/array.js\");\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n\n\n\n\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder()\n\n/**\n * @param {function(Encoder):void} f\n */\nconst encode = (f) => {\n  const encoder = createEncoder()\n  f(encoder)\n  return toUint8Array(encoder)\n}\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nconst hasContent = encoder => encoder.cpos > 0 || encoder.bufs.length > 0\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array<ArrayBuffer>} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_0__.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nconst set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint16 = (encoder, num) => {\n  write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  write(encoder, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) {\n    write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num = _math_js__WEBPACK_IMPORTED_MODULE_0__.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarInt = (encoder, num) => {\n  const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (isNegative ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT7 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 & num))\n  num = _math_js__WEBPACK_IMPORTED_MODULE_0__.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num = _math_js__WEBPACK_IMPORTED_MODULE_0__.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = _string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, _string_js__WEBPACK_IMPORTED_MODULE_3__.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (_string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder && /** @type {any} */ (_string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write a string terminated by a special byte sequence. This is not very performant and is\n * generally discouraged. However, the resulting byte arrays are lexiographically ordered which\n * makes this a nice feature for databases.\n *\n * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst writeTerminatedString = (encoder, str) =>\n  writeTerminatedUint8Array(encoder, _string_js__WEBPACK_IMPORTED_MODULE_3__.encodeUtf8(str))\n\n/**\n * Write a terminating Uint8Array. Note that this is not performant and is generally\n * discouraged. There are few situations when this is needed.\n *\n * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.\n *\n * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then\n * the result is terminated using the 0x0 character.\n *\n * This is basically how many systems implement null terminated strings. However, we use an escape\n * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key\n * encoder for NoSql databases).\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} buf The string that is to be encoded.\n */\nconst writeTerminatedUint8Array = (encoder, buf) => {\n  for (let i = 0; i < buf.length; i++) {\n    const b = buf[i]\n    if (b === 0 || b === 1) {\n      write(encoder, 1)\n    }\n    write(encoder, buf[i])\n  }\n  write(encoder, 0)\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nconst writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = _math_js__WEBPACK_IMPORTED_MODULE_0__.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_0__.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nconst writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * @typedef {Array<AnyEncodable>} AnyEncodableArray\n */\n\n/**\n * @typedef {undefined|null|number|bigint|boolean|string|{[k:string]:AnyEncodable}|AnyEncodableArray|Uint8Array} AnyEncodable\n */\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {AnyEncodable} data\n */\nconst writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (_number_js__WEBPACK_IMPORTED_MODULE_1__.isInteger(data) && _math_js__WEBPACK_IMPORTED_MODULE_0__.abs(data) <= _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (_array_js__WEBPACK_IMPORTED_MODULE_4__.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nclass RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nclass IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nclass RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nclass UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nclass IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nclass IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nclass StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/encoding.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/environment.js"
/*!**********************************************!*\
  !*** ../../node_modules/lib0/environment.js ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureConf: () => (/* binding */ ensureConf),\n/* harmony export */   getConf: () => (/* binding */ getConf),\n/* harmony export */   getParam: () => (/* binding */ getParam),\n/* harmony export */   getVariable: () => (/* binding */ getVariable),\n/* harmony export */   hasConf: () => (/* binding */ hasConf),\n/* harmony export */   hasParam: () => (/* binding */ hasParam),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   production: () => (/* binding */ production),\n/* harmony export */   supportsColor: () => (/* binding */ supportsColor)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"../../node_modules/lib0/map.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"../../node_modules/lib0/string.js\");\n/* harmony import */ var _conditions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conditions.js */ \"../../node_modules/lib0/conditions.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage.js */ \"../../node_modules/lib0/storage.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./function.js */ \"../../node_modules/lib0/function.js\");\n/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module environment\n */\n\n\n\n\n\n\n\n/* c8 ignore next 2 */\n// @ts-ignore\nconst isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n\n/* c8 ignore next */\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !isNode\n/* c8 ignore next 3 */\nconst isMac = typeof navigator !== 'undefined'\n  ? /Mac/.test(navigator.platform)\n  : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* c8 ignore start */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n      const pargs = process.argv\n      let currParamName = null\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n      // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create(); // eslint-disable-next-line no-undef\n      (location.search || '?').slice(1).split('&').forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n          params.set(`-${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n    }\n  }\n  return params\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next */\nconst hasParam = (name) => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* c8 ignore next 2 */\nconst getParam = (name, defaultVal) =>\n  computeParams().get(name) || defaultVal\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 4 */\nconst getVariable = (name) =>\n  isNode\n    ? _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(process.env[name.toUpperCase().replaceAll('-', '_')])\n    : _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(_storage_js__WEBPACK_IMPORTED_MODULE_3__.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 2 */\nconst getConf = (name) =>\n  computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {string}\n */\n/* c8 ignore next 5 */\nconst ensureConf = (name) => {\n  const c = getConf(name)\n  if (c == null) throw new Error(`Expected configuration \"${name.toUpperCase().replaceAll('-', '_')}\"`)\n  return c\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next 2 */\nconst hasConf = (name) =>\n  hasParam('--' + name) || getVariable(name) !== null\n\n/* c8 ignore next */\nconst production = hasConf('production')\n\n/* c8 ignore next 2 */\nconst forceColor = isNode &&\n  _function_js__WEBPACK_IMPORTED_MODULE_4__.isOneOf(process.env.FORCE_COLOR, ['true', '1', '2'])\n\n/* c8 ignore start */\n/**\n * Color is enabled by default if the terminal supports it.\n *\n * Explicitly enable color using `--color` parameter\n * Disable color using `--no-color` parameter or using `NO_COLOR=1` environment variable.\n * `FORCE_COLOR=1` enables color and takes precedence over all.\n */\nconst supportsColor = forceColor || (\n  !hasParam('--no-colors') && // @todo deprecate --no-colors\n  !hasConf('no-color') &&\n  (!isNode || process.stdout.isTTY) && (\n    !isNode ||\n    hasParam('--color') ||\n    getVariable('COLORTERM') !== null ||\n    (getVariable('TERM') || '').includes('color')\n  )\n)\n/* c8 ignore stop */\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/environment.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/error.js"
/*!****************************************!*\
  !*** ../../node_modules/lib0/error.js ***!
  \****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   methodUnimplemented: () => (/* binding */ methodUnimplemented),\n/* harmony export */   unexpectedCase: () => (/* binding */ unexpectedCase)\n/* harmony export */ });\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nconst methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nconst unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n\n/**\n * @param {boolean} property\n * @return {asserts property is true}\n */\nconst assert = property => { if (!property) throw create('Assert failed') }\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/error.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/eventloop.js"
/*!********************************************!*\
  !*** ../../node_modules/lib0/eventloop.js ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   animationFrame: () => (/* binding */ animationFrame),\n/* harmony export */   createDebouncer: () => (/* binding */ createDebouncer),\n/* harmony export */   enqueue: () => (/* binding */ enqueue),\n/* harmony export */   idleCallback: () => (/* binding */ idleCallback),\n/* harmony export */   interval: () => (/* binding */ interval),\n/* harmony export */   timeout: () => (/* binding */ timeout)\n/* harmony export */ });\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ \"../../node_modules/lib0/time.js\");\n/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\n\n\n/**\n * Utility module to work with EcmaScript's event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = []\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n}\n\n/**\n * @param {function():void} f\n */\nconst enqueue = f => {\n  queue.push(f)\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0)\n  }\n}\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId\n  }\n\n  destroy () {\n    clearFunction(this._)\n  }\n}\n\nconst Timeout = createTimeoutClass(clearTimeout)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout))\n\nconst Interval = createTimeoutClass(clearInterval)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst interval = (timeout, callback) => new Interval(setInterval(callback, timeout))\n\n/* c8 ignore next */\nconst Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg))\n\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next */\nconst animationFrame = cb => typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb))\n\n/* c8 ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg))\n\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next 2 */\n// @ts-ignore\nconst idleCallback = cb => typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb)\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @param {number} triggerAfter Optional. Trigger callback after a certain amount of time\n *                              without waiting for debounce.\n */\nconst createDebouncer = (timeout, triggerAfter = -1) => {\n  let timer = -1\n  /**\n   * @type {number?}\n    */\n  let lastCall = null\n  /**\n   * @param {((...args: any)=>void)?} cb function to trigger after debounce. If null, it will reset the\n   *                         debounce.\n   */\n  return cb => {\n    clearTimeout(timer)\n    if (cb) {\n      if (triggerAfter >= 0) {\n        const now = _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime()\n        if (lastCall === null) lastCall = now\n        if (now - lastCall > triggerAfter) {\n          lastCall = null\n          timer = /** @type {any} */ (setTimeout(cb, 0))\n          return\n        }\n      }\n      timer = /** @type {any} */ (setTimeout(() => { lastCall = null; cb() }, timeout))\n    } else {\n      lastCall = null\n    }\n  }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/eventloop.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/function.js"
/*!*******************************************!*\
  !*** ../../node_modules/lib0/function.js ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   callAll: () => (/* binding */ callAll),\n/* harmony export */   equalityDeep: () => (/* binding */ equalityDeep),\n/* harmony export */   equalityFlat: () => (/* binding */ equalityFlat),\n/* harmony export */   equalityStrict: () => (/* binding */ equalityStrict),\n/* harmony export */   id: () => (/* binding */ id),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isOneOf: () => (/* binding */ isOneOf),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTemplate: () => (/* binding */ isTemplate),\n/* harmony export */   nop: () => (/* binding */ nop)\n/* harmony export */ });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ \"../../node_modules/lib0/array.js\");\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./object.js */ \"../../node_modules/lib0/object.js\");\n/* harmony import */ var _trait_equality_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trait/equality.js */ \"../../node_modules/lib0/trait/equality.js\");\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n\n\n\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nconst callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nconst nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nconst apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nconst id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nconst equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((_array_js__WEBPACK_IMPORTED_MODULE_0__.isArray(a) && _array_js__WEBPACK_IMPORTED_MODULE_0__.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && _object_js__WEBPACK_IMPORTED_MODULE_1__.equalFlat(a, b))))\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a === b) {\n    return true\n  }\n  if (a == null || b == null || (a.constructor !== b.constructor && (a.constructor || Object) !== (b.constructor || Object))) {\n    return false\n  }\n  if (a[_trait_equality_js__WEBPACK_IMPORTED_MODULE_2__.EqualityTraitSymbol] != null) {\n    return a[_trait_equality_js__WEBPACK_IMPORTED_MODULE_2__.EqualityTraitSymbol](b)\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case undefined:\n    case Object:\n      if (_object_js__WEBPACK_IMPORTED_MODULE_1__.size(a) !== _object_js__WEBPACK_IMPORTED_MODULE_1__.size(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!_object_js__WEBPACK_IMPORTED_MODULE_1__.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nconst isOneOf = (value, options) => options.includes(value)\n/* c8 ignore stop */\n\nconst isArray = _array_js__WEBPACK_IMPORTED_MODULE_0__.isArray\n\n/**\n * @param {any} s\n * @return {s is String}\n */\nconst isString = (s) => s && s.constructor === String\n\n/**\n * @param {any} n\n * @return {n is Number}\n */\nconst isNumber = n => n != null && n.constructor === Number\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {any} n\n * @param {TYPE} T\n * @return {n is InstanceType<TYPE>}\n */\nconst is = (n, T) => n && n.constructor === T\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {TYPE} T\n */\nconst isTemplate = (T) =>\n  /**\n   * @param {any} n\n   * @return {n is InstanceType<TYPE>}\n   **/\n  n => n && n.constructor === T\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/function.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/iterator.js"
/*!*******************************************!*\
  !*** ../../node_modules/lib0/iterator.js ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createIterator: () => (/* binding */ createIterator),\n/* harmony export */   iteratorFilter: () => (/* binding */ iteratorFilter),\n/* harmony export */   iteratorMap: () => (/* binding */ iteratorMap),\n/* harmony export */   mapIterator: () => (/* binding */ mapIterator)\n/* harmony export */ });\n/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nconst mapIterator = (iterator, f) => ({\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next()\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n})\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nconst createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n})\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nconst iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res\n  do {\n    res = iterator.next()\n  } while (!res.done && !filter(res.value))\n  return res\n})\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nconst iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next()\n  return { done, value: done ? undefined : fmap(value) }\n})\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/iterator.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/json.js"
/*!***************************************!*\
  !*** ../../node_modules/lib0/json.js ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/**\n * JSON utility functions.\n *\n * @module json\n */\n\n/**\n * Transform JavaScript object to JSON.\n *\n * @param {any} object\n * @return {string}\n */\nconst stringify = JSON.stringify\n\n/**\n * Parse JSON object.\n *\n * @param {string} json\n * @return {any}\n */\nconst parse = JSON.parse\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/json.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/logging.common.js"
/*!*************************************************!*\
  !*** ../../node_modules/lib0/logging.common.js ***!
  \*************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLUE: () => (/* binding */ BLUE),\n/* harmony export */   BOLD: () => (/* binding */ BOLD),\n/* harmony export */   GREEN: () => (/* binding */ GREEN),\n/* harmony export */   GREY: () => (/* binding */ GREY),\n/* harmony export */   ORANGE: () => (/* binding */ ORANGE),\n/* harmony export */   PURPLE: () => (/* binding */ PURPLE),\n/* harmony export */   RED: () => (/* binding */ RED),\n/* harmony export */   UNBOLD: () => (/* binding */ UNBOLD),\n/* harmony export */   UNCOLOR: () => (/* binding */ UNCOLOR),\n/* harmony export */   computeNoColorLoggingArgs: () => (/* binding */ computeNoColorLoggingArgs),\n/* harmony export */   createModuleLogger: () => (/* binding */ createModuleLogger)\n/* harmony export */ });\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol.js */ \"../../node_modules/lib0/symbol.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./time.js */ \"../../node_modules/lib0/time.js\");\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./environment.js */ \"../../node_modules/lib0/environment.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function.js */ \"../../node_modules/lib0/function.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./json.js */ \"../../node_modules/lib0/json.js\");\n\n\n\n\n\n\nconst BOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNBOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst BLUE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREY = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREEN = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst RED = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst PURPLE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst ORANGE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNCOLOR = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\n\n/* c8 ignore start */\n/**\n * @param {Array<undefined|string|Symbol|Object|number|function():any>} args\n * @return {Array<string|object|number|undefined>}\n */\nconst computeNoColorLoggingArgs = args => {\n  if (args.length === 1 && args[0]?.constructor === Function) {\n    args = /** @type {Array<string|Symbol|Object|number>} */ (/** @type {[function]} */ (args)[0]())\n  }\n  const strBuilder = []\n  const logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (arg === undefined) {\n      break\n    } else if (arg.constructor === String || arg.constructor === Number) {\n      strBuilder.push(arg)\n    } else if (arg.constructor === Object) {\n      break\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs.push(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n/* c8 ignore stop */\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE]\nlet nextColor = 0\nlet lastLoggingTime = _time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n\n/* c8 ignore start */\n/**\n * @param {function(...any):void} _print\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nconst createModuleLogger = (_print, moduleName) => {\n  const color = loggingColors[nextColor]\n  const debugRegexVar = _environment_js__WEBPACK_IMPORTED_MODULE_2__.getVariable('log')\n  const doLogging = debugRegexVar !== null &&\n    (debugRegexVar === '*' || debugRegexVar === 'true' ||\n      new RegExp(debugRegexVar, 'gi').test(moduleName))\n  nextColor = (nextColor + 1) % loggingColors.length\n  moduleName += ': '\n  return !doLogging\n    ? _function_js__WEBPACK_IMPORTED_MODULE_3__.nop\n    : (...args) => {\n        if (args.length === 1 && args[0]?.constructor === Function) {\n          args = args[0]()\n        }\n        const timeNow = _time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n        const timeDiff = timeNow - lastLoggingTime\n        lastLoggingTime = timeNow\n        _print(\n          color,\n          moduleName,\n          UNCOLOR,\n          ...args.map((arg) => {\n            if (arg != null && arg.constructor === Uint8Array) {\n              arg = Array.from(arg)\n            }\n            const t = typeof arg\n            switch (t) {\n              case 'string':\n              case 'symbol':\n                return arg\n              default: {\n                return _json_js__WEBPACK_IMPORTED_MODULE_4__.stringify(arg)\n              }\n            }\n          }),\n          color,\n          ' +' + timeDiff + 'ms'\n        )\n      }\n}\n/* c8 ignore stop */\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/logging.common.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/logging.js"
/*!******************************************!*\
  !*** ../../node_modules/lib0/logging.js ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLUE: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.BLUE),\n/* harmony export */   BOLD: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.BOLD),\n/* harmony export */   GREEN: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.GREEN),\n/* harmony export */   GREY: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.GREY),\n/* harmony export */   ORANGE: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.ORANGE),\n/* harmony export */   PURPLE: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.PURPLE),\n/* harmony export */   RED: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.RED),\n/* harmony export */   UNBOLD: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.UNBOLD),\n/* harmony export */   UNCOLOR: () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.UNCOLOR),\n/* harmony export */   VConsole: () => (/* binding */ VConsole),\n/* harmony export */   createModuleLogger: () => (/* binding */ createModuleLogger),\n/* harmony export */   createVConsole: () => (/* binding */ createVConsole),\n/* harmony export */   group: () => (/* binding */ group),\n/* harmony export */   groupCollapsed: () => (/* binding */ groupCollapsed),\n/* harmony export */   groupEnd: () => (/* binding */ groupEnd),\n/* harmony export */   print: () => (/* binding */ print),\n/* harmony export */   printCanvas: () => (/* binding */ printCanvas),\n/* harmony export */   printDom: () => (/* binding */ printDom),\n/* harmony export */   printError: () => (/* binding */ printError),\n/* harmony export */   printImg: () => (/* binding */ printImg),\n/* harmony export */   printImgBase64: () => (/* binding */ printImgBase64),\n/* harmony export */   vconsoles: () => (/* binding */ vconsoles),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment.js */ \"../../node_modules/lib0/environment.js\");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set.js */ \"../../node_modules/lib0/set.js\");\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pair.js */ \"../../node_modules/lib0/pair.js\");\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ \"../../node_modules/lib0/dom.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./json.js */ \"../../node_modules/lib0/json.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./map.js */ \"../../node_modules/lib0/map.js\");\n/* harmony import */ var _eventloop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./eventloop.js */ \"../../node_modules/lib0/eventloop.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var _logging_common_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./logging.common.js */ \"../../node_modules/lib0/logging.common.js\");\n/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.BOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('font-weight', 'bold'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.UNBOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('font-weight', 'normal'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.BLUE]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('color', 'blue'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.GREEN]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('color', 'green'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.GREY]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('color', 'grey'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.RED]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('color', 'red'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.PURPLE]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('color', 'purple'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.ORANGE]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.UNCOLOR]: _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('color', 'black')\n}\n\n/**\n * @param {Array<string|Symbol|Object|number|function():any>} args\n * @return {Array<string|object|number>}\n */\n/* c8 ignore start */\nconst computeBrowserLoggingArgs = (args) => {\n  if (args.length === 1 && args[0]?.constructor === Function) {\n    args = /** @type {Array<string|Symbol|Object|number>} */ (/** @type {[function]} */ (args)[0]())\n  }\n  const strBuilder = []\n  const styles = []\n  const currentStyle = _map_js__WEBPACK_IMPORTED_MODULE_5__.create()\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg === undefined) {\n        break\n      }\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle)\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg)\n          styles.push(style)\n        } else {\n          strBuilder.push(arg)\n        }\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles\n    logArgs.unshift(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n/* c8 ignore stop */\n\n/* c8 ignore start */\nconst computeLoggingArgs = _environment_js__WEBPACK_IMPORTED_MODULE_0__.supportsColor\n  ? computeBrowserLoggingArgs\n  : _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.computeNoColorLoggingArgs\n/* c8 ignore stop */\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst print = (...args) => {\n  console.log(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.print(args))\n}\n\n/* c8 ignore start */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst warn = (...args) => {\n  console.warn(...computeLoggingArgs(args))\n  args.unshift(_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.ORANGE)\n  vconsoles.forEach((vc) => vc.print(args))\n}\n/* c8 ignore stop */\n\n/**\n * @param {Error} err\n */\n/* c8 ignore start */\nconst printError = (err) => {\n  console.error(err)\n  vconsoles.forEach((vc) => vc.printError(err))\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\n/* c8 ignore start */\nconst printImg = (url, height) => {\n  if (_environment_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {\n    console.log(\n      '%c                      ',\n      `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`\n    )\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach((vc) => vc.printImg(url, height))\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} base64\n * @param {number} height\n */\n/* c8 ignore next 2 */\nconst printImgBase64 = (base64, height) =>\n  printImg(`data:image/gif;base64,${base64}`, height)\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst group = (...args) => {\n  console.group(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.group(args))\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.groupCollapsed(args))\n}\n\nconst groupEnd = () => {\n  console.groupEnd()\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.groupEnd())\n}\n\n/**\n * @param {function():Node} createNode\n */\n/* c8 ignore next 2 */\nconst printDom = (createNode) =>\n  vconsoles.forEach((vc) => vc.printDom(createNode()))\n\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\n/* c8 ignore next 2 */\nconst printCanvas = (canvas, height) =>\n  printImg(canvas.toDataURL(), height)\n\nconst vconsoles = _set_js__WEBPACK_IMPORTED_MODULE_1__.create()\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\n/* c8 ignore start */\nconst _computeLineSpans = (args) => {\n  const spans = []\n  const currentStyle = new Map()\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    let arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg === undefined) {\n        arg = 'undefined '\n      }\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [\n          _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('style', _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle))\n        ], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(arg.toString())])\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;'\n        }\n        spans.push(span)\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i]\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + _json_js__WEBPACK_IMPORTED_MODULE_4__.stringify(content) + ' '\n      }\n      spans.push(\n        _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(/** @type {string} */ (content))])\n      )\n    }\n  }\n  return spans\n}\n/* c8 ignore stop */\n\nconst lineStyle =\n  'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'\n\n/* c8 ignore start */\nclass VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom\n    this.depth = 0\n    vconsoles.add(this)\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      const triangleDown = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [\n        _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('hidden', collapsed),\n        _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('style', 'color:grey;font-size:120%;')\n      ], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('')])\n      const triangleRight = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [\n        _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('hidden', !collapsed),\n        _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('style', 'color:grey;font-size:125%;')\n      ], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('')])\n      const content = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element(\n        'div',\n        [_pair_js__WEBPACK_IMPORTED_MODULE_2__.create(\n          'style',\n          `${lineStyle};padding-left:${this.depth * 10}px`\n        )],\n        [triangleDown, triangleRight, _dom_js__WEBPACK_IMPORTED_MODULE_3__.text(' ')].concat(\n          _computeLineSpans(args)\n        )\n      )\n      const nextContainer = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [\n        _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('hidden', collapsed)\n      ])\n      const nextLine = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [], [content, nextContainer])\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [nextLine])\n      this.ccontainer = nextContainer\n      this.depth++\n      // when header is clicked, collapse/uncollapse container\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.addEventListener(content, 'click', (_event) => {\n        nextContainer.toggleAttribute('hidden')\n        triangleDown.toggleAttribute('hidden')\n        triangleRight.toggleAttribute('hidden')\n      })\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true)\n  }\n\n  groupEnd () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement\n      }\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [\n        _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [\n          _pair_js__WEBPACK_IMPORTED_MODULE_2__.create(\n            'style',\n            `${lineStyle};padding-left:${this.depth * 10}px`\n          )\n        ], _computeLineSpans(args))\n      ])\n    })\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([_logging_common_js__WEBPACK_IMPORTED_MODULE_8__.RED, _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.BOLD, err.toString()])\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [\n        _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('img', [\n          _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('src', url),\n          _pair_js__WEBPACK_IMPORTED_MODULE_2__.create('height', `${_math_js__WEBPACK_IMPORTED_MODULE_7__.round(height * 1.5)}px`)\n        ])\n      ])\n    })\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [node])\n    })\n  }\n\n  destroy () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      vconsoles.delete(this)\n    })\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @param {Element} dom\n */\n/* c8 ignore next */\nconst createVConsole = (dom) => new VConsole(dom)\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nconst createModuleLogger = (moduleName) => _logging_common_js__WEBPACK_IMPORTED_MODULE_8__.createModuleLogger(print, moduleName)\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/logging.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/map.js"
/*!**************************************!*\
  !*** ../../node_modules/lib0/map.js ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   copy: () => (/* binding */ copy),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   setIfUndefined: () => (/* binding */ setIfUndefined)\n/* harmony export */ });\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * @template K\n * @template V\n * @typedef {Map<K,V>} GlobalMap\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template K,V\n * @param {Map<K,V>} m\n * @return {Map<K,V>}\n */\nconst copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nconst map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/map.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/math.js"
/*!***************************************!*\
  !*** ../../node_modules/lib0/math.js ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abs: () => (/* binding */ abs),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   ceil: () => (/* binding */ ceil),\n/* harmony export */   exp10: () => (/* binding */ exp10),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   imul: () => (/* binding */ imul),\n/* harmony export */   isNaN: () => (/* binding */ isNaN),\n/* harmony export */   isNegativeZero: () => (/* binding */ isNegativeZero),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   log10: () => (/* binding */ log10),\n/* harmony export */   log2: () => (/* binding */ log2),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   sqrt: () => (/* binding */ sqrt)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor\nconst ceil = Math.ceil\nconst abs = Math.abs\nconst imul = Math.imul\nconst round = Math.round\nconst log10 = Math.log10\nconst log2 = Math.log2\nconst log = Math.log\nconst sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nconst add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b\n\nconst isNaN = Number.isNaN\n\nconst pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nconst exp10 = exp => Math.pow(10, exp)\n\nconst sign = Math.sign\n\n/**\n * Check whether n is negative, while considering the -0 edge case. While `-0 < 0` is false, this\n * function returns true for -0,-1,,.. and returns false for 0,1,2,...\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also distinguishes between -0 and +0\n */\nconst isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/math.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/metric.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/metric.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atto: () => (/* binding */ atto),\n/* harmony export */   centi: () => (/* binding */ centi),\n/* harmony export */   deca: () => (/* binding */ deca),\n/* harmony export */   deci: () => (/* binding */ deci),\n/* harmony export */   exa: () => (/* binding */ exa),\n/* harmony export */   femto: () => (/* binding */ femto),\n/* harmony export */   giga: () => (/* binding */ giga),\n/* harmony export */   hecto: () => (/* binding */ hecto),\n/* harmony export */   kilo: () => (/* binding */ kilo),\n/* harmony export */   mega: () => (/* binding */ mega),\n/* harmony export */   micro: () => (/* binding */ micro),\n/* harmony export */   milli: () => (/* binding */ milli),\n/* harmony export */   nano: () => (/* binding */ nano),\n/* harmony export */   peta: () => (/* binding */ peta),\n/* harmony export */   pico: () => (/* binding */ pico),\n/* harmony export */   prefix: () => (/* binding */ prefix),\n/* harmony export */   tera: () => (/* binding */ tera),\n/* harmony export */   yocto: () => (/* binding */ yocto),\n/* harmony export */   yotta: () => (/* binding */ yotta),\n/* harmony export */   zepto: () => (/* binding */ zepto),\n/* harmony export */   zetta: () => (/* binding */ zetta)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/**\n * Utility module to convert metric values.\n *\n * @module metric\n */\n\n\n\nconst yotta = 1e24\nconst zetta = 1e21\nconst exa = 1e18\nconst peta = 1e15\nconst tera = 1e12\nconst giga = 1e9\nconst mega = 1e6\nconst kilo = 1e3\nconst hecto = 1e2\nconst deca = 10\nconst deci = 0.1\nconst centi = 0.01\nconst milli = 1e-3\nconst micro = 1e-6\nconst nano = 1e-9\nconst pico = 1e-12\nconst femto = 1e-15\nconst atto = 1e-18\nconst zepto = 1e-21\nconst yocto = 1e-24\n\nconst prefixUp = ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']\nconst prefixDown = ['', 'm', '', 'n', 'p', 'f', 'a', 'z', 'y']\n\n/**\n * Calculate the metric prefix for a number. Assumes E.g. `prefix(1000) = { n: 1, prefix: 'k' }`\n *\n * @param {number} n\n * @param {number} [baseMultiplier] Multiplier of the base (10^(3*baseMultiplier)). E.g. `convert(time, -3)` if time is already in milli seconds\n * @return {{n:number,prefix:string}}\n */\nconst prefix = (n, baseMultiplier = 0) => {\n  const nPow = n === 0 ? 0 : _math_js__WEBPACK_IMPORTED_MODULE_0__.log10(n)\n  let mult = 0\n  while (nPow < mult * 3 && baseMultiplier > -8) {\n    baseMultiplier--\n    mult--\n  }\n  while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {\n    baseMultiplier++\n    mult++\n  }\n  const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier]\n  return {\n    n: _math_js__WEBPACK_IMPORTED_MODULE_0__.round((mult > 0 ? n / _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * 3) : n * _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * -3)) * 1e12) / 1e12,\n    prefix\n  }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/metric.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/number.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/number.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HIGHEST_INT32: () => (/* binding */ HIGHEST_INT32),\n/* harmony export */   HIGHEST_UINT32: () => (/* binding */ HIGHEST_UINT32),\n/* harmony export */   LOWEST_INT32: () => (/* binding */ LOWEST_INT32),\n/* harmony export */   MAX_SAFE_INTEGER: () => (/* binding */ MAX_SAFE_INTEGER),\n/* harmony export */   MIN_SAFE_INTEGER: () => (/* binding */ MIN_SAFE_INTEGER),\n/* harmony export */   countBits: () => (/* binding */ countBits),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isNaN: () => (/* binding */ isNaN),\n/* harmony export */   parseInt: () => (/* binding */ parseInt)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ \"../../node_modules/lib0/binary.js\");\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nconst MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nconst LOWEST_INT32 = 1 << 31\nconst HIGHEST_INT32 = _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS31\nconst HIGHEST_UINT32 = _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS32\n\n/* c8 ignore next */\nconst isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && _math_js__WEBPACK_IMPORTED_MODULE_0__.floor(num) === num)\nconst isNaN = Number.isNaN\nconst parseInt = Number.parseInt\n\n/**\n * Count the number of \"1\" bits in an unsigned 32bit number.\n *\n * Super fun bitcount algorithm by Brian Kernighan.\n *\n * @param {number} n\n */\nconst countBits = n => {\n  n &= _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS32\n  let count = 0\n  while (n) {\n    n &= (n - 1)\n    count++\n  }\n  return count\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/number.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/object.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/object.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   deepFreeze: () => (/* binding */ deepFreeze),\n/* harmony export */   equalFlat: () => (/* binding */ equalFlat),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   hasProperty: () => (/* binding */ hasProperty),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   setIfUndefined: () => (/* binding */ setIfUndefined),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   values: () => (/* binding */ values)\n/* harmony export */ });\n/* harmony import */ var _trait_equality_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trait/equality.js */ \"../../node_modules/lib0/trait/equality.js\");\n\n\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nconst create = () => Object.create(null)\n\n/**\n * @param {any} o\n * @return {o is { [k:string]:any }}\n */\nconst isObject = o => typeof o === 'object'\n\n/**\n * Object.assign\n */\nconst assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys\n\n/**\n * @template V\n * @param {{[key:string]: V}} obj\n * @return {Array<V>}\n */\nconst values = Object.values\n\n/**\n * @template V\n * @param {{[k:string]:V}} obj\n * @param {function(V,string):any} f\n */\nconst forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nconst map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst size = obj => keys(obj).length\n\n/**\n * @template {{ [key:string|number|symbol]: any }} T\n * @param {T} obj\n * @param {(v:T[keyof T],k:keyof T)=>boolean} f\n * @return {boolean}\n */\nconst some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object|null|undefined} obj\n */\nconst isEmpty = obj => {\n  // eslint-disable-next-line no-unreachable-loop\n  for (const _k in obj) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {{ [key:string|number|symbol]: any }} T\n * @param {T} obj\n * @param {(v:T[keyof T],k:keyof T)=>boolean} f\n * @return {boolean}\n */\nconst every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|number|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a === b || (size(a) === size(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && _trait_equality_js__WEBPACK_IMPORTED_MODULE_0__.equals(b[key], val)))\n\n/**\n * Make an object immutable. This hurts performance and is usually not needed if you perform good\n * coding practices.\n */\nconst freeze = Object.freeze\n\n/**\n * Make an object and all its children immutable.\n * This *really* hurts performance and is usually not needed if you perform good coding practices.\n *\n * @template {any} T\n * @param {T} o\n * @return {Readonly<T>}\n */\nconst deepFreeze = (o) => {\n  for (const key in o) {\n    const c = o[key]\n    if (typeof c === 'object' || typeof c === 'function') {\n      deepFreeze(o[key])\n    }\n  }\n  return freeze(o)\n}\n\n/**\n * Get object property. Create T if property is undefined and set T on object.\n *\n * @function\n * @template {object} KV\n * @template {keyof KV} [K=keyof KV]\n * @param {KV} o\n * @param {K} key\n * @param {() => KV[K]} createT\n * @return {KV[K]}\n */\nconst setIfUndefined = (o, key, createT) => hasProperty(o, key) ? o[key] : (o[key] = createT())\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/object.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/observable.js"
/*!*********************************************!*\
  !*** ../../node_modules/lib0/observable.js ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: () => (/* binding */ Observable),\n/* harmony export */   ObservableV2: () => (/* binding */ ObservableV2)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"../../node_modules/lib0/map.js\");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set.js */ \"../../node_modules/lib0/set.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ \"../../node_modules/lib0/array.js\");\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n\n\n\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nclass ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    _map_js__WEBPACK_IMPORTED_MODULE_0__.setIfUndefined(this._observers, /** @type {string} */ (name), _set_js__WEBPACK_IMPORTED_MODULE_1__.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return _array_js__WEBPACK_IMPORTED_MODULE_2__.from((this._observers.get(name) || _map_js__WEBPACK_IMPORTED_MODULE_0__.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    _map_js__WEBPACK_IMPORTED_MODULE_0__.setIfUndefined(this._observers, name, _set_js__WEBPACK_IMPORTED_MODULE_1__.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return _array_js__WEBPACK_IMPORTED_MODULE_2__.from((this._observers.get(name) || _map_js__WEBPACK_IMPORTED_MODULE_0__.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n}\n/* c8 ignore end */\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/observable.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/pair.js"
/*!***************************************!*\
  !*** ../../node_modules/lib0/pair.js ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pair: () => (/* binding */ Pair),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   createReversed: () => (/* binding */ createReversed),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   map: () => (/* binding */ map)\n/* harmony export */ });\n/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nclass Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left\n    this.right = right\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nconst create = (left, right) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nconst createReversed = (right, left) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nconst forEach = (arr, f) => arr.forEach(p => f(p.left, p.right))\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nconst map = (arr, f) => arr.map(p => f(p.left, p.right))\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/pair.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/prng.js"
/*!***************************************!*\
  !*** ../../node_modules/lib0/prng.js ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultPRNG: () => (/* binding */ DefaultPRNG),\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   char: () => (/* binding */ char),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   int31: () => (/* binding */ int31),\n/* harmony export */   int32: () => (/* binding */ int32),\n/* harmony export */   int53: () => (/* binding */ int53),\n/* harmony export */   letter: () => (/* binding */ letter),\n/* harmony export */   oneOf: () => (/* binding */ oneOf),\n/* harmony export */   real53: () => (/* binding */ real53),\n/* harmony export */   uint16Array: () => (/* binding */ uint16Array),\n/* harmony export */   uint32: () => (/* binding */ uint32),\n/* harmony export */   uint32Array: () => (/* binding */ uint32Array),\n/* harmony export */   uint53: () => (/* binding */ uint53),\n/* harmony export */   uint8Array: () => (/* binding */ uint8Array),\n/* harmony export */   utf16Rune: () => (/* binding */ utf16Rune),\n/* harmony export */   utf16String: () => (/* binding */ utf16String),\n/* harmony export */   word: () => (/* binding */ word)\n/* harmony export */ });\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary.js */ \"../../node_modules/lib0/binary.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"../../node_modules/lib0/string.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var _prng_Xoroshiro128plus_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prng/Xoroshiro128plus.js */ \"../../node_modules/lib0/prng/Xoroshiro128plus.js\");\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buffer.js */ \"../../node_modules/lib0/buffer.js\");\n/**\n * Fast Pseudo Random Number Generators.\n *\n * Given a seed a PRNG generates a sequence of numbers that cannot be reasonably predicted.\n * Two PRNGs must generate the same random sequence of numbers if  given the same seed.\n *\n * @module prng\n */\n\n\n\n\n\n\n\n/**\n * Description of the function\n *  @callback generatorNext\n *  @return {number} A random float in the cange of [0,1)\n */\n\n/**\n * A random type generator.\n *\n * @typedef {Object} PRNG\n * @property {generatorNext} next Generate new number\n */\nconst DefaultPRNG = _prng_Xoroshiro128plus_js__WEBPACK_IMPORTED_MODULE_3__.Xoroshiro128plus\n\n/**\n * Create a Xoroshiro128plus Pseudo-Random-Number-Generator.\n * This is the fastest full-period generator passing BigCrush without systematic failures.\n * But there are more PRNGs available in ./PRNG/.\n *\n * @param {number} seed A positive 32bit integer. Do not use negative numbers.\n * @return {PRNG}\n */\nconst create = seed => new DefaultPRNG(seed)\n\n/**\n * Generates a single random bool.\n *\n * @param {PRNG} gen A random number generator.\n * @return {Boolean} A random boolean\n */\nconst bool = gen => (gen.next() >= 0.5)\n\n/**\n * Generates a random integer with 53 bit resolution.\n *\n * @param {PRNG} gen A random number generator.\n * @param {Number} min The lower bound of the allowed return values (inclusive).\n * @param {Number} max The upper bound of the allowed return values (inclusive).\n * @return {Number} A random integer on [min, max]\n */\nconst int53 = (gen, min, max) => _math_js__WEBPACK_IMPORTED_MODULE_2__.floor(gen.next() * (max + 1 - min) + min)\n\n/**\n * Generates a random integer with 53 bit resolution.\n *\n * @param {PRNG} gen A random number generator.\n * @param {Number} min The lower bound of the allowed return values (inclusive).\n * @param {Number} max The upper bound of the allowed return values (inclusive).\n * @return {Number} A random integer on [min, max]\n */\nconst uint53 = (gen, min, max) => _math_js__WEBPACK_IMPORTED_MODULE_2__.abs(int53(gen, min, max))\n\n/**\n * Generates a random integer with 32 bit resolution.\n *\n * @param {PRNG} gen A random number generator.\n * @param {Number} min The lower bound of the allowed return values (inclusive).\n * @param {Number} max The upper bound of the allowed return values (inclusive).\n * @return {Number} A random integer on [min, max]\n */\nconst int32 = (gen, min, max) => _math_js__WEBPACK_IMPORTED_MODULE_2__.floor(gen.next() * (max + 1 - min) + min)\n\n/**\n * Generates a random integer with 53 bit resolution.\n *\n * @param {PRNG} gen A random number generator.\n * @param {Number} min The lower bound of the allowed return values (inclusive).\n * @param {Number} max The upper bound of the allowed return values (inclusive).\n * @return {Number} A random integer on [min, max]\n */\nconst uint32 = (gen, min, max) => int32(gen, min, max) >>> 0\n\n/**\n * @deprecated\n * Optimized version of prng.int32. It has the same precision as prng.int32, but should be preferred when\n * openaring on smaller ranges.\n *\n * @param {PRNG} gen A random number generator.\n * @param {Number} min The lower bound of the allowed return values (inclusive).\n * @param {Number} max The upper bound of the allowed return values (inclusive). The max inclusive number is `binary.BITS31-1`\n * @return {Number} A random integer on [min, max]\n */\nconst int31 = (gen, min, max) => int32(gen, min, max)\n\n/**\n * Generates a random real on [0, 1) with 53 bit resolution.\n *\n * @param {PRNG} gen A random number generator.\n * @return {Number} A random real number on [0, 1).\n */\nconst real53 = gen => gen.next() // (((gen.next() >>> 5) * binary.BIT26) + (gen.next() >>> 6)) / MAX_SAFE_INTEGER\n\n/**\n * Generates a random character from char code 32 - 126. I.e. Characters, Numbers, special characters, and Space:\n *\n * @param {PRNG} gen A random number generator.\n * @return {string}\n *\n * (Space)!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[/]^_`abcdefghijklmnopqrstuvwxyz{|}~\n */\nconst char = gen => (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCharCode)(int31(gen, 32, 126))\n\n/**\n * @param {PRNG} gen\n * @return {string} A single letter (a-z)\n */\nconst letter = gen => (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCharCode)(int31(gen, 97, 122))\n\n/**\n * @param {PRNG} gen\n * @param {number} [minLen=0]\n * @param {number} [maxLen=20]\n * @return {string} A random word (0-20 characters) without spaces consisting of letters (a-z)\n */\nconst word = (gen, minLen = 0, maxLen = 20) => {\n  const len = int31(gen, minLen, maxLen)\n  let str = ''\n  for (let i = 0; i < len; i++) {\n    str += letter(gen)\n  }\n  return str\n}\n\n/**\n * TODO: this function produces invalid runes. Does not cover all of utf16!!\n *\n * @param {PRNG} gen\n * @return {string}\n */\nconst utf16Rune = gen => {\n  const codepoint = int31(gen, 0, 256)\n  return (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(codepoint)\n}\n\n/**\n * @param {PRNG} gen\n * @param {number} [maxlen = 20]\n */\nconst utf16String = (gen, maxlen = 20) => {\n  const len = int31(gen, 0, maxlen)\n  let str = ''\n  for (let i = 0; i < len; i++) {\n    str += utf16Rune(gen)\n  }\n  return str\n}\n\n/**\n * Returns one element of a given array.\n *\n * @param {PRNG} gen A random number generator.\n * @param {Array<T>} array Non empty Array of possible values.\n * @return {T} One of the values of the supplied Array.\n * @template T\n */\nconst oneOf = (gen, array) => array[int31(gen, 0, array.length - 1)]\n\n/**\n * @param {PRNG} gen\n * @param {number} len\n * @return {Uint8Array<ArrayBuffer>}\n */\nconst uint8Array = (gen, len) => {\n  const buf = _buffer_js__WEBPACK_IMPORTED_MODULE_4__.createUint8ArrayFromLen(len)\n  for (let i = 0; i < buf.length; i++) {\n    buf[i] = int32(gen, 0, _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS8)\n  }\n  return buf\n}\n\n/* c8 ignore start */\n/**\n * @param {PRNG} gen\n * @param {number} len\n * @return {Uint16Array}\n */\nconst uint16Array = (gen, len) => new Uint16Array(uint8Array(gen, len * 2).buffer)\n\n/**\n * @param {PRNG} gen\n * @param {number} len\n * @return {Uint32Array}\n */\nconst uint32Array = (gen, len) => new Uint32Array(uint8Array(gen, len * 4).buffer)\n/* c8 ignore stop */\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/prng.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/prng/Xoroshiro128plus.js"
/*!********************************************************!*\
  !*** ../../node_modules/lib0/prng/Xoroshiro128plus.js ***!
  \********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Xoroshiro128plus: () => (/* binding */ Xoroshiro128plus)\n/* harmony export */ });\n/* harmony import */ var _Xorshift32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Xorshift32.js */ \"../../node_modules/lib0/prng/Xorshift32.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../binary.js */ \"../../node_modules/lib0/binary.js\");\n/**\n * @module prng\n */\n\n\n\n\n/**\n * This is a variant of xoroshiro128plus - the fastest full-period generator passing BigCrush without systematic failures.\n *\n * This implementation follows the idea of the original xoroshiro128plus implementation,\n * but is optimized for the JavaScript runtime. I.e.\n * * The operations are performed on 32bit integers (the original implementation works with 64bit values).\n * * The initial 128bit state is computed based on a 32bit seed and Xorshift32.\n * * This implementation returns two 32bit values based on the 64bit value that is computed by xoroshiro128plus.\n *   Caution: The last addition step works slightly different than in the original implementation - the add carry of the\n *   first 32bit addition is not carried over to the last 32bit.\n *\n * [Reference implementation](http://vigna.di.unimi.it/xorshift/xoroshiro128plus.c)\n */\nclass Xoroshiro128plus {\n  /**\n   * @param {number} seed Unsigned 32 bit number\n   */\n  constructor (seed) {\n    this.seed = seed\n    // This is a variant of Xoroshiro128plus to fill the initial state\n    const xorshift32 = new _Xorshift32_js__WEBPACK_IMPORTED_MODULE_0__.Xorshift32(seed)\n    this.state = new Uint32Array(4)\n    for (let i = 0; i < 4; i++) {\n      this.state[i] = xorshift32.next() * _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS32\n    }\n    this._fresh = true\n  }\n\n  /**\n   * @return {number} Float/Double in [0,1)\n   */\n  next () {\n    const state = this.state\n    if (this._fresh) {\n      this._fresh = false\n      return ((state[0] + state[2]) >>> 0) / (_binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS32 + 1)\n    } else {\n      this._fresh = true\n      const s0 = state[0]\n      const s1 = state[1]\n      const s2 = state[2] ^ s0\n      const s3 = state[3] ^ s1\n      // function js_rotl (x, k) {\n      //   k = k - 32\n      //   const x1 = x[0]\n      //   const x2 = x[1]\n      //   x[0] = x2 << k | x1 >>> (32 - k)\n      //   x[1] = x1 << k | x2 >>> (32 - k)\n      // }\n      // rotl(s0, 55) // k = 23 = 55 - 32; j = 9 =  32 - 23\n      state[0] = (s1 << 23 | s0 >>> 9) ^ s2 ^ (s2 << 14 | s3 >>> 18)\n      state[1] = (s0 << 23 | s1 >>> 9) ^ s3 ^ (s3 << 14)\n      // rol(s1, 36) // k = 4 = 36 - 32; j = 23 = 32 - 9\n      state[2] = s3 << 4 | s2 >>> 28\n      state[3] = s2 << 4 | s3 >>> 28\n      return (((state[1] + state[3]) >>> 0) / (_binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS32 + 1))\n    }\n  }\n}\n\n/*\n// Reference implementation\n// Source: http://vigna.di.unimi.it/xorshift/xoroshiro128plus.c\n// By David Blackman and Sebastiano Vigna\n// Who published the reference implementation under Public Domain (CC0)\n\n#include <stdint.h>\n#include <stdio.h>\n\nuint64_t s[2];\n\nstatic inline uint64_t rotl(const uint64_t x, int k) {\n    return (x << k) | (x >> (64 - k));\n}\n\nuint64_t next(void) {\n    const uint64_t s0 = s[0];\n    uint64_t s1 = s[1];\n    s1 ^= s0;\n    s[0] = rotl(s0, 55) ^ s1 ^ (s1 << 14); // a, b\n    s[1] = rotl(s1, 36); // c\n    return (s[0] + s[1]) & 0xFFFFFFFF;\n}\n\nint main(void)\n{\n    int i;\n    s[0] = 1111 | (1337ul << 32);\n    s[1] = 1234 | (9999ul << 32);\n\n    printf(\"1000 outputs of genrand_int31()\\n\");\n    for (i=0; i<100; i++) {\n        printf(\"%10lu \", i);\n        printf(\"%10lu \", next());\n        printf(\"- %10lu \", s[0] >> 32);\n        printf(\"%10lu \", (s[0] << 32) >> 32);\n        printf(\"%10lu \", s[1] >> 32);\n        printf(\"%10lu \", (s[1] << 32) >> 32);\n        printf(\"\\n\");\n        // if (i%5==4) printf(\"\\n\");\n    }\n    return 0;\n}\n*/\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/prng/Xoroshiro128plus.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/prng/Xorshift32.js"
/*!**************************************************!*\
  !*** ../../node_modules/lib0/prng/Xorshift32.js ***!
  \**************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Xorshift32: () => (/* binding */ Xorshift32)\n/* harmony export */ });\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary.js */ \"../../node_modules/lib0/binary.js\");\n/**\n * @module prng\n */\n\n\n\n/**\n * Xorshift32 is a very simple but elegang PRNG with a period of `2^32-1`.\n */\nclass Xorshift32 {\n  /**\n   * @param {number} seed Unsigned 32 bit number\n   */\n  constructor (seed) {\n    this.seed = seed\n    /**\n     * @type {number}\n     */\n    this._state = seed\n  }\n\n  /**\n   * Generate a random signed integer.\n   *\n   * @return {Number} A 32 bit signed integer.\n   */\n  next () {\n    let x = this._state\n    x ^= x << 13\n    x ^= x >> 17\n    x ^= x << 5\n    this._state = x\n    return (x >>> 0) / (_binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS32 + 1)\n  }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/prng/Xorshift32.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/promise.js"
/*!******************************************!*\
  !*** ../../node_modules/lib0/promise.js ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   createEmpty: () => (/* binding */ createEmpty),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   reject: () => (/* binding */ reject),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   resolveWith: () => (/* binding */ resolveWith),\n/* harmony export */   until: () => (/* binding */ until),\n/* harmony export */   untilAsync: () => (/* binding */ untilAsync),\n/* harmony export */   wait: () => (/* binding */ wait)\n/* harmony export */ });\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ \"../../node_modules/lib0/time.js\");\n/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\n\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nconst create = f => /** @type {Promise<T>} */ (new Promise(f))\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nconst createEmpty = f => new Promise(f)\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template {unknown[] | []} PS\n *\n * @param {PS} ps\n * @return {Promise<{ -readonly [P in keyof PS]: Awaited<PS[P]> }>}\n */\nconst all = Promise.all.bind(Promise)\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nconst reject = reason => Promise.reject(reason)\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nconst resolve = res => Promise.resolve(res)\n\n/**\n * @template T\n * @param {T} res\n * @return {Promise<T>}\n */\nconst resolveWith = res => Promise.resolve(res)\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n * @deprecated use untilAsync instead\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nconst until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime()\n  const hasTimeout = timeout > 0\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle)\n      resolve()\n    } else if (hasTimeout) {\n      /* c8 ignore else */\n      if (_time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle)\n        reject(new Error('Timeout'))\n      }\n    }\n  }\n  const intervalHandle = setInterval(untilInterval, intervalResolution)\n})\n\n/**\n * @param {()=>Promise<boolean>|boolean} check\n * @param {number} timeout\n * @param {number} intervalResolution\n * @return {Promise<void>}\n */\nconst untilAsync = async (check, timeout = 0, intervalResolution = 10) => {\n  const startTime = _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime()\n  const noTimeout = timeout <= 0\n  // eslint-disable-next-line no-unmodified-loop-condition\n  while (noTimeout || _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime() - startTime <= timeout) {\n    if (await check()) return\n    await wait(intervalResolution)\n  }\n  throw new Error('Timeout')\n}\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nconst wait = timeout => create((resolve, _reject) => setTimeout(resolve, timeout))\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nconst isPromise = p => p instanceof Promise || (p && p.then && p.catch && p.finally)\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/promise.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/random.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/random.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   oneOf: () => (/* binding */ oneOf),\n/* harmony export */   rand: () => (/* binding */ rand),\n/* harmony export */   uint32: () => (/* binding */ uint32),\n/* harmony export */   uint53: () => (/* binding */ uint53),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ \"../../node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_webcrypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/webcrypto */ \"../../node_modules/lib0/webcrypto.js\");\n/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\n\n\n\n\nconst rand = Math.random\n\nconst uint32 = () => (0,lib0_webcrypto__WEBPACK_IMPORTED_MODULE_2__.getRandomValues)(new Uint32Array(1))[0]\n\nconst uint53 = () => {\n  const arr = (0,lib0_webcrypto__WEBPACK_IMPORTED_MODULE_2__.getRandomValues)(new Uint32Array(8))\n  return (arr[0] & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS21) * (_binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS32 + 1) + (arr[1] >>> 0)\n}\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nconst oneOf = arr => arr[_math_js__WEBPACK_IMPORTED_MODULE_0__.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\n\n/**\n * @return {string}\n */\nconst uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/random.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/schema.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/schema.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ $),\n/* harmony export */   $$any: () => (/* binding */ $$any),\n/* harmony export */   $$array: () => (/* binding */ $$array),\n/* harmony export */   $$bigint: () => (/* binding */ $$bigint),\n/* harmony export */   $$boolean: () => (/* binding */ $$boolean),\n/* harmony export */   $$constructedBy: () => (/* binding */ $$constructedBy),\n/* harmony export */   $$custom: () => (/* binding */ $$custom),\n/* harmony export */   $$instanceOf: () => (/* binding */ $$instanceOf),\n/* harmony export */   $$intersect: () => (/* binding */ $$intersect),\n/* harmony export */   $$lambda: () => (/* binding */ $$lambda),\n/* harmony export */   $$literal: () => (/* binding */ $$literal),\n/* harmony export */   $$never: () => (/* binding */ $$never),\n/* harmony export */   $$null: () => (/* binding */ $$null),\n/* harmony export */   $$number: () => (/* binding */ $$number),\n/* harmony export */   $$object: () => (/* binding */ $$object),\n/* harmony export */   $$optional: () => (/* binding */ $$optional),\n/* harmony export */   $$record: () => (/* binding */ $$record),\n/* harmony export */   $$schema: () => (/* binding */ $$schema),\n/* harmony export */   $$string: () => (/* binding */ $$string),\n/* harmony export */   $$stringTemplate: () => (/* binding */ $$stringTemplate),\n/* harmony export */   $$symbol: () => (/* binding */ $$symbol),\n/* harmony export */   $$tuple: () => (/* binding */ $$tuple),\n/* harmony export */   $$uint8Array: () => (/* binding */ $$uint8Array),\n/* harmony export */   $$undefined: () => (/* binding */ $$undefined),\n/* harmony export */   $$union: () => (/* binding */ $$union),\n/* harmony export */   $$void: () => (/* binding */ $$void),\n/* harmony export */   $Array: () => (/* binding */ $Array),\n/* harmony export */   $ConstructedBy: () => (/* binding */ $ConstructedBy),\n/* harmony export */   $Custom: () => (/* binding */ $Custom),\n/* harmony export */   $InstanceOf: () => (/* binding */ $InstanceOf),\n/* harmony export */   $Intersection: () => (/* binding */ $Intersection),\n/* harmony export */   $Lambda: () => (/* binding */ $Lambda),\n/* harmony export */   $Literal: () => (/* binding */ $Literal),\n/* harmony export */   $Object: () => (/* binding */ $Object),\n/* harmony export */   $Record: () => (/* binding */ $Record),\n/* harmony export */   $StringTemplate: () => (/* binding */ $StringTemplate),\n/* harmony export */   $Tuple: () => (/* binding */ $Tuple),\n/* harmony export */   $Union: () => (/* binding */ $Union),\n/* harmony export */   $any: () => (/* binding */ $any),\n/* harmony export */   $array: () => (/* binding */ $array),\n/* harmony export */   $arrayAny: () => (/* binding */ $arrayAny),\n/* harmony export */   $bigint: () => (/* binding */ $bigint),\n/* harmony export */   $boolean: () => (/* binding */ $boolean),\n/* harmony export */   $constructedBy: () => (/* binding */ $constructedBy),\n/* harmony export */   $custom: () => (/* binding */ $custom),\n/* harmony export */   $function: () => (/* binding */ $function),\n/* harmony export */   $instanceOf: () => (/* binding */ $instanceOf),\n/* harmony export */   $intersect: () => (/* binding */ $intersect),\n/* harmony export */   $json: () => (/* binding */ $json),\n/* harmony export */   $lambda: () => (/* binding */ $lambda),\n/* harmony export */   $literal: () => (/* binding */ $literal),\n/* harmony export */   $never: () => (/* binding */ $never),\n/* harmony export */   $null: () => (/* binding */ $null),\n/* harmony export */   $number: () => (/* binding */ $number),\n/* harmony export */   $object: () => (/* binding */ $object),\n/* harmony export */   $objectAny: () => (/* binding */ $objectAny),\n/* harmony export */   $primitive: () => (/* binding */ $primitive),\n/* harmony export */   $record: () => (/* binding */ $record),\n/* harmony export */   $string: () => (/* binding */ $string),\n/* harmony export */   $stringTemplate: () => (/* binding */ $stringTemplate),\n/* harmony export */   $symbol: () => (/* binding */ $symbol),\n/* harmony export */   $tuple: () => (/* binding */ $tuple),\n/* harmony export */   $uint8Array: () => (/* binding */ $uint8Array),\n/* harmony export */   $undefined: () => (/* binding */ $undefined),\n/* harmony export */   $union: () => (/* binding */ $union),\n/* harmony export */   $void: () => (/* binding */ $void),\n/* harmony export */   PatternMatcher: () => (/* binding */ PatternMatcher),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object.js */ \"../../node_modules/lib0/object.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ \"../../node_modules/lib0/array.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./error.js */ \"../../node_modules/lib0/error.js\");\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./environment.js */ \"../../node_modules/lib0/environment.js\");\n/* harmony import */ var _trait_equality_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./trait/equality.js */ \"../../node_modules/lib0/trait/equality.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function.js */ \"../../node_modules/lib0/function.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ \"../../node_modules/lib0/string.js\");\n/* harmony import */ var _prng_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./prng.js */ \"../../node_modules/lib0/prng.js\");\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./number.js */ \"../../node_modules/lib0/number.js\");\n/**\n * @experimental WIP\n *\n * Simple & efficient schemas for your data.\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {string|number|bigint|boolean|null|undefined|symbol} Primitive\n */\n\n/**\n * @typedef {{ [k:string|number|symbol]: any }} AnyObject\n */\n\n/**\n * @template T\n * @typedef {T extends Schema<infer X> ? X : T} Unwrap\n */\n\n/**\n * @template T\n * @typedef {T extends Schema<infer X> ? X : T} TypeOf\n */\n\n/**\n * @template {readonly unknown[]} T\n * @typedef {T extends readonly [Schema<infer First>, ...infer Rest] ? [First, ...UnwrapArray<Rest>] : [] } UnwrapArray\n */\n\n/**\n * @template T\n * @typedef {T extends Schema<infer S> ? Schema<S> : never} CastToSchema\n */\n\n/**\n * @template {unknown[]} Arr\n * @typedef {Arr extends [...unknown[], infer L] ? L : never} TupleLast\n */\n\n/**\n * @template {unknown[]} Arr\n * @typedef {Arr extends [...infer Fs, unknown] ? Fs : never} TuplePop\n */\n\n/**\n * @template {readonly unknown[]} T\n * @typedef {T extends []\n *   ? {}\n *   : T extends [infer First]\n *   ? First\n *   : T extends [infer First, ...infer Rest]\n *   ? First & Intersect<Rest>\n *   : never\n * } Intersect\n */\n\nconst schemaSymbol = Symbol('0schema')\n\nclass ValidationError {\n  constructor () {\n    /**\n     * Reverse errors\n     * @type {Array<{ path: string?, expected: string, has: string, message: string? }>}\n     */\n    this._rerrs = []\n  }\n\n  /**\n   * @param {string?} path\n   * @param {string} expected\n   * @param {string} has\n   * @param {string?} message\n   */\n  extend (path, expected, has, message = null) {\n    this._rerrs.push({ path, expected, has, message })\n  }\n\n  toString () {\n    const s = []\n    for (let i = this._rerrs.length - 1; i > 0; i--) {\n      const r = this._rerrs[i]\n      /* c8 ignore next */\n      s.push(_string_js__WEBPACK_IMPORTED_MODULE_6__.repeat(' ', (this._rerrs.length - i) * 2) + `${r.path != null ? `[${r.path}] ` : ''}${r.has} doesn't match ${r.expected}. ${r.message}`)\n    }\n    return s.join('\\n')\n  }\n}\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst shapeExtends = (a, b) => {\n  if (a === b) return true\n  if (a == null || b == null || a.constructor !== b.constructor) return false\n  if (a[_trait_equality_js__WEBPACK_IMPORTED_MODULE_4__.EqualityTraitSymbol]) return _trait_equality_js__WEBPACK_IMPORTED_MODULE_4__.equals(a, b) // last resort: check equality (do this before array and obj check which don't implement the equality trait)\n  if (_array_js__WEBPACK_IMPORTED_MODULE_1__.isArray(a)) {\n    return _array_js__WEBPACK_IMPORTED_MODULE_1__.every(a, aitem =>\n      _array_js__WEBPACK_IMPORTED_MODULE_1__.some(b, bitem => shapeExtends(aitem, bitem))\n    )\n  } else if (_object_js__WEBPACK_IMPORTED_MODULE_0__.isObject(a)) {\n    return _object_js__WEBPACK_IMPORTED_MODULE_0__.every(a, (aitem, akey) =>\n      shapeExtends(aitem, b[akey])\n    )\n  }\n  /* c8 ignore next */\n  return false\n}\n\n/**\n * @template T\n * @implements {equalityTraits.EqualityTrait}\n */\nclass Schema {\n  // this.shape must not be defined on Schema. Otherwise typecheck on metatypes (e.g. $$object) won't work as expected anymore\n  /**\n   * If true, the more things are added to the shape the more objects this schema will accept (e.g.\n   * union). By default, the more objects are added, the the fewer objects this schema will accept.\n   * @protected\n   */\n  static _dilutes = false\n\n  /**\n   * @param {Schema<any>} other\n   */\n  extends (other) {\n    let [a, b] = [/** @type {any} */(this).shape, /** @type {any} */ (other).shape]\n    if (/** @type {typeof Schema<any>} */ (this.constructor)._dilutes) [b, a] = [a, b]\n    return shapeExtends(a, b)\n  }\n\n  /**\n   * Overwrite this when necessary. By default, we only check the `shape` property which every shape\n   * should have.\n   * @param {Schema<any>} other\n   */\n  equals (other) {\n    // @ts-ignore\n    return this.constructor === other.constructor && _function_js__WEBPACK_IMPORTED_MODULE_5__.equalityDeep(this.shape, other.shape)\n  }\n\n  [schemaSymbol] () { return true }\n\n  /**\n   * @param {object} other\n   */\n  [_trait_equality_js__WEBPACK_IMPORTED_MODULE_4__.EqualityTraitSymbol] (other) {\n    return this.equals(/** @type {any} */ (other))\n  }\n\n  /**\n   * Use `schema.validate(obj)` with a typed parameter that is already of typed to be an instance of\n   * Schema. Validate will check the structure of the parameter and return true iff the instance\n   * really is an instance of Schema.\n   *\n   * @param {T} o\n   * @return {boolean}\n   */\n  validate (o) {\n    return this.check(o)\n  }\n\n  /* c8 ignore start */\n  /**\n   * Similar to validate, but this method accepts untyped parameters.\n   *\n   * @param {any} _o\n   * @param {ValidationError} [_err]\n   * @return {_o is T}\n   */\n  check (_o, _err) {\n    _error_js__WEBPACK_IMPORTED_MODULE_2__.methodUnimplemented()\n  }\n  /* c8 ignore stop */\n\n  /**\n   * @type {Schema<T?>}\n   */\n  get nullable () {\n    // @ts-ignore\n    return $union(this, $null)\n  }\n\n  /**\n   * @type {$Optional<Schema<T>>}\n   */\n  get optional () {\n    return new $Optional(/** @type {Schema<T>} */ (this))\n  }\n\n  /**\n   * Cast a variable to a specific type. Returns the casted value, or throws an exception otherwise.\n   * Use this if you know that the type is of a specific type and you just want to convince the type\n   * system.\n   *\n   * **Do not rely on these error messages!**\n   * Performs an assertion check only if not in a production environment.\n   *\n   * @template OO\n   * @param {OO} o\n   * @return {Extract<OO, T> extends never ? T : (OO extends Array<never> ? T : Extract<OO,T>)}\n   */\n  cast (o) {\n    assert(o, this)\n    return /** @type {any} */ (o)\n  }\n\n  /**\n   * EXPECTO PATRONUM!! \n   * This function protects against type errors. Though it may not work in the real world.\n   *\n   * \"After all this time?\"\n   * \"Always.\" - Snape, talking about type safety\n   *\n   * Ensures that a variable is a a specific type. Returns the value, or throws an exception if the assertion check failed.\n   * Use this if you know that the type is of a specific type and you just want to convince the type\n   * system.\n   *\n   * Can be useful when defining lambdas: `s.lambda(s.$number, s.$void).expect((n) => n + 1)`\n   *\n   * **Do not rely on these error messages!**\n   * Performs an assertion check if not in a production environment.\n   *\n   * @param {T} o\n   * @return {o extends T ? T : never}\n   */\n  expect (o) {\n    assert(o, this)\n    return o\n  }\n}\n\n/**\n * @template {(new (...args:any[]) => any) | ((...args:any[]) => any)} Constr\n * @typedef {Constr extends ((...args:any[]) => infer T) ? T : (Constr extends (new (...args:any[]) => any) ? InstanceType<Constr> : never)} Instance\n */\n\n/**\n * @template {(new (...args:any[]) => any) | ((...args:any[]) => any)} C\n * @extends {Schema<Instance<C>>}\n */\nclass $ConstructedBy extends Schema {\n  /**\n   * @param {C} c\n   * @param {((o:Instance<C>)=>boolean)|null} check\n   */\n  constructor (c, check) {\n    super()\n    this.shape = c\n    this._c = check\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is C extends ((...args:any[]) => infer T) ? T : (C extends (new (...args:any[]) => any) ? InstanceType<C> : never)} o\n   */\n  check (o, err = undefined) {\n    const c = o?.constructor === this.shape && (this._c == null || this._c(o))\n    /* c8 ignore next */\n    !c && err?.extend(null, this.shape.name, o?.constructor.name, o?.constructor !== this.shape ? 'Constructor match failed' : 'Check failed')\n    return c\n  }\n}\n\n/**\n * @template {(new (...args:any[]) => any) | ((...args:any[]) => any)} C\n * @param {C} c\n * @param {((o:Instance<C>) => boolean)|null} check\n * @return {CastToSchema<$ConstructedBy<C>>}\n */\nconst $constructedBy = (c, check = null) => new $ConstructedBy(c, check)\nconst $$constructedBy = $constructedBy($ConstructedBy)\n\n/**\n * Check custom properties on any object. You may want to overwrite the generated Schema<any>.\n *\n * @extends {Schema<any>}\n */\nclass $Custom extends Schema {\n  /**\n   * @param {(o:any) => boolean} check\n   */\n  constructor (check) {\n    super()\n    /**\n     * @type {(o:any) => boolean}\n     */\n    this.shape = check\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is any}\n   */\n  check (o, err) {\n    const c = this.shape(o)\n    /* c8 ignore next */\n    !c && err?.extend(null, 'custom prop', o?.constructor.name, 'failed to check custom prop')\n    return c\n  }\n}\n\n/**\n * @param {(o:any) => boolean} check\n * @return {Schema<any>}\n */\nconst $custom = (check) => new $Custom(check)\nconst $$custom = $constructedBy($Custom)\n\n/**\n * @template {Primitive} T\n * @extends {Schema<T>}\n */\nclass $Literal extends Schema {\n  /**\n   * @param {Array<T>} literals\n   */\n  constructor (literals) {\n    super()\n    this.shape = literals\n  }\n\n  /**\n   *\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is T}\n   */\n  check (o, err) {\n    const c = this.shape.some(a => a === o)\n    /* c8 ignore next */\n    !c && err?.extend(null, this.shape.join(' | '), o.toString())\n    return c\n  }\n}\n\n/**\n * @template {Primitive[]} T\n * @param {T} literals\n * @return {CastToSchema<$Literal<T[number]>>}\n */\nconst $literal = (...literals) => new $Literal(literals)\nconst $$literal = $constructedBy($Literal)\n\n/**\n * @template {Array<string|Schema<string|number>>} Ts\n * @typedef {Ts extends [] ? `` : (Ts extends [infer T] ? (Unwrap<T> extends (string|number) ? Unwrap<T> : never) : (Ts extends [infer T1, ...infer Rest] ? `${Unwrap<T1> extends (string|number) ? Unwrap<T1> : never}${Rest extends Array<string|Schema<string|number>> ? CastStringTemplateArgsToTemplate<Rest> : never}` : never))} CastStringTemplateArgsToTemplate\n */\n\n/**\n * @param {string} str\n * @return {string}\n */\nconst _regexEscape = /** @type {any} */ (RegExp).escape || /** @type {(str:string) => string} */ (str =>\n  str.replace(/[().|&,$^[\\]]/g, s => '\\\\' + s)\n)\n\n/**\n * @param {string|Schema<any>} s\n * @return {string[]}\n */\nconst _schemaStringTemplateToRegex = s => {\n  if ($string.check(s)) {\n    return [_regexEscape(s)]\n  }\n  if ($$literal.check(s)) {\n    return /** @type {Array<string|number>} */ (s.shape).map(v => v + '')\n  }\n  if ($$number.check(s)) {\n    return ['[+-]?\\\\d+.?\\\\d*']\n  }\n  if ($$string.check(s)) {\n    return ['.*']\n  }\n  if ($$union.check(s)) {\n    return s.shape.map(_schemaStringTemplateToRegex).flat(1)\n  }\n  /* c8 ignore next 2 */\n  // unexpected schema structure (only supports unions and string in literal types)\n  _error_js__WEBPACK_IMPORTED_MODULE_2__.unexpectedCase()\n}\n\n/**\n * @template {Array<string|Schema<string|number>>} T\n * @extends {Schema<CastStringTemplateArgsToTemplate<T>>}\n */\nclass $StringTemplate extends Schema {\n  /**\n   * @param {T} shape\n   */\n  constructor (shape) {\n    super()\n    this.shape = shape\n    this._r = new RegExp('^' + shape.map(_schemaStringTemplateToRegex).map(opts => `(${opts.join('|')})`).join('') + '$')\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is CastStringTemplateArgsToTemplate<T>}\n   */\n  check (o, err) {\n    const c = this._r.exec(o) != null\n    /* c8 ignore next */\n    !c && err?.extend(null, this._r.toString(), o.toString(), 'String doesn\\'t match string template.')\n    return c\n  }\n}\n\n/**\n * @template {Array<string|Schema<string|number>>} T\n * @param {T} literals\n * @return {CastToSchema<$StringTemplate<T>>}\n */\nconst $stringTemplate = (...literals) => new $StringTemplate(literals)\nconst $$stringTemplate = $constructedBy($StringTemplate)\n\nconst isOptionalSymbol = Symbol('optional')\n/**\n * @template {Schema<any>} S\n * @extends Schema<Unwrap<S>|undefined>\n */\nclass $Optional extends Schema {\n  /**\n   * @param {S} shape\n   */\n  constructor (shape) {\n    super()\n    this.shape = shape\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is (Unwrap<S>|undefined)}\n   */\n  check (o, err) {\n    const c = o === undefined || this.shape.check(o)\n    /* c8 ignore next */\n    !c && err?.extend(null, 'undefined (optional)', '()')\n    return c\n  }\n\n  get [isOptionalSymbol] () { return true }\n}\nconst $$optional = $constructedBy($Optional)\n\n/**\n * @extends Schema<never>\n */\nclass $Never extends Schema {\n  /**\n   * @param {any} _o\n   * @param {ValidationError} [err]\n   * @return {_o is never}\n   */\n  check (_o, err) {\n    /* c8 ignore next */\n    err?.extend(null, 'never', typeof _o)\n    return false\n  }\n}\n\n/**\n * @type {Schema<never>}\n */\nconst $never = new $Never()\nconst $$never = $constructedBy($Never)\n\n/**\n * @template {{ [key: string|symbol|number]: Schema<any> }} S\n * @typedef {{ [Key in keyof S as S[Key] extends $Optional<Schema<any>> ? Key : never]?: S[Key] extends $Optional<Schema<infer Type>> ? Type : never } & { [Key in keyof S as S[Key] extends $Optional<Schema<any>> ? never : Key]: S[Key] extends Schema<infer Type> ? Type : never }} $ObjectToType\n */\n\n/**\n * @template {{[key:string|symbol|number]: Schema<any>}} S\n * @extends {Schema<$ObjectToType<S>>}\n */\nclass $Object extends Schema {\n  /**\n   * @param {S} shape\n   * @param {boolean} partial\n   */\n  constructor (shape, partial = false) {\n    super()\n    /**\n     * @type {S}\n     */\n    this.shape = shape\n    this._isPartial = partial\n  }\n\n  static _dilutes = true\n\n  /**\n   * @type {Schema<Partial<$ObjectToType<S>>>}\n   */\n  get partial () {\n    return new $Object(this.shape, true)\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is $ObjectToType<S>}\n   */\n  check (o, err) {\n    if (o == null) {\n      /* c8 ignore next */\n      err?.extend(null, 'object', 'null')\n      return false\n    }\n    return _object_js__WEBPACK_IMPORTED_MODULE_0__.every(this.shape, (vv, vk) => {\n      const c = (this._isPartial && !_object_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty(o, vk)) || vv.check(o[vk], err)\n      !c && err?.extend(vk.toString(), vv.toString(), typeof o[vk], 'Object property does not match')\n      return c\n    })\n  }\n}\n\n/**\n * @template S\n * @typedef {Schema<{ [Key in keyof S as S[Key] extends $Optional<Schema<any>> ? Key : never]?: S[Key] extends $Optional<Schema<infer Type>> ? Type : never } & { [Key in keyof S as S[Key] extends $Optional<Schema<any>> ? never : Key]: S[Key] extends Schema<infer Type> ? Type : never }>} _ObjectDefToSchema\n */\n\n// I used an explicit type annotation instead of $ObjectToType, so that the user doesn't see the\n// weird type definitions when inspecting type definions.\n/**\n * @template {{ [key:string|symbol|number]: Schema<any> }} S\n * @param {S} def\n * @return {_ObjectDefToSchema<S> extends Schema<infer S> ? Schema<{ [K in keyof S]: S[K] }> : never}\n */\nconst $object = def => /** @type {any} */ (new $Object(def))\nconst $$object = $constructedBy($Object)\n/**\n * @type {Schema<{[key:string]: any}>}\n */\nconst $objectAny = $custom(o => o != null && (o.constructor === Object || o.constructor == null))\n\n/**\n * @template {Schema<string|number|symbol>} Keys\n * @template {Schema<any>} Values\n * @extends {Schema<{ [key in Unwrap<Keys>]: Unwrap<Values> }>}\n */\nclass $Record extends Schema {\n  /**\n   * @param {Keys} keys\n   * @param {Values} values\n   */\n  constructor (keys, values) {\n    super()\n    this.shape = {\n      keys, values\n    }\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is { [key in Unwrap<Keys>]: Unwrap<Values> }}\n   */\n  check (o, err) {\n    return o != null && _object_js__WEBPACK_IMPORTED_MODULE_0__.every(o, (vv, vk) => {\n      const ck = this.shape.keys.check(vk, err)\n      /* c8 ignore next */\n      !ck && err?.extend(vk + '', 'Record', typeof o, ck ? 'Key doesn\\'t match schema' : 'Value doesn\\'t match value')\n      return ck && this.shape.values.check(vv, err)\n    })\n  }\n}\n\n/**\n * @template {Schema<string|number|symbol>} Keys\n * @template {Schema<any>} Values\n * @param {Keys} keys\n * @param {Values} values\n * @return {CastToSchema<$Record<Keys,Values>>}\n */\nconst $record = (keys, values) => new $Record(keys, values)\nconst $$record = $constructedBy($Record)\n\n/**\n * @template {Schema<any>[]} S\n * @extends {Schema<{ [Key in keyof S]: S[Key] extends Schema<infer Type> ? Type : never }>}\n */\nclass $Tuple extends Schema {\n  /**\n   * @param {S} shape\n   */\n  constructor (shape) {\n    super()\n    this.shape = shape\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is { [K in keyof S]: S[K] extends Schema<infer Type> ? Type : never }}\n   */\n  check (o, err) {\n    return o != null && _object_js__WEBPACK_IMPORTED_MODULE_0__.every(this.shape, (vv, vk) => {\n      const c = /** @type {Schema<any>} */ (vv).check(o[vk], err)\n      /* c8 ignore next */\n      !c && err?.extend(vk.toString(), 'Tuple', typeof vv)\n      return c\n    })\n  }\n}\n\n/**\n * @template {Array<Schema<any>>} T\n * @param {T} def\n * @return {CastToSchema<$Tuple<T>>}\n */\nconst $tuple = (...def) => new $Tuple(def)\nconst $$tuple = $constructedBy($Tuple)\n\n/**\n * @template {Schema<any>} S\n * @extends {Schema<Array<S extends Schema<infer T> ? T : never>>}\n */\nclass $Array extends Schema {\n  /**\n   * @param {Array<S>} v\n   */\n  constructor (v) {\n    super()\n    /**\n     * @type {Schema<S extends Schema<infer T> ? T : never>}\n     */\n    this.shape = v.length === 1 ? v[0] : new $Union(v)\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is Array<S extends Schema<infer T> ? T : never>} o\n   */\n  check (o, err) {\n    const c = _array_js__WEBPACK_IMPORTED_MODULE_1__.isArray(o) && _array_js__WEBPACK_IMPORTED_MODULE_1__.every(o, oi => this.shape.check(oi))\n    /* c8 ignore next */\n    !c && err?.extend(null, 'Array', '')\n    return c\n  }\n}\n\n/**\n * @template {Array<Schema<any>>} T\n * @param {T} def\n * @return {Schema<Array<T extends Array<Schema<infer S>> ? S : never>>}\n */\nconst $array = (...def) => new $Array(def)\nconst $$array = $constructedBy($Array)\n/**\n * @type {Schema<Array<any>>}\n */\nconst $arrayAny = $custom(o => _array_js__WEBPACK_IMPORTED_MODULE_1__.isArray(o))\n\n/**\n * @template T\n * @extends {Schema<T>}\n */\nclass $InstanceOf extends Schema {\n  /**\n   * @param {new (...args:any) => T} constructor\n   * @param {((o:T) => boolean)|null} check\n   */\n  constructor (constructor, check) {\n    super()\n    this.shape = constructor\n    this._c = check\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is T}\n   */\n  check (o, err) {\n    const c = o instanceof this.shape && (this._c == null || this._c(o))\n    /* c8 ignore next */\n    !c && err?.extend(null, this.shape.name, o?.constructor.name)\n    return c\n  }\n}\n\n/**\n * @template T\n * @param {new (...args:any) => T} c\n * @param {((o:T) => boolean)|null} check\n * @return {Schema<T>}\n */\nconst $instanceOf = (c, check = null) => new $InstanceOf(c, check)\nconst $$instanceOf = $constructedBy($InstanceOf)\n\nconst $$schema = $instanceOf(Schema)\n\n/**\n * @template {Schema<any>[]} Args\n * @typedef {(...args:UnwrapArray<TuplePop<Args>>)=>Unwrap<TupleLast<Args>>} _LArgsToLambdaDef\n */\n\n/**\n * @template {Array<Schema<any>>} Args\n * @extends {Schema<_LArgsToLambdaDef<Args>>}\n */\nclass $Lambda extends Schema {\n  /**\n   * @param {Args} args\n   */\n  constructor (args) {\n    super()\n    this.len = args.length - 1\n    this.args = $tuple(...args.slice(-1))\n    this.res = args[this.len]\n  }\n\n  /**\n   * @param {any} f\n   * @param {ValidationError} err\n   * @return {f is _LArgsToLambdaDef<Args>}\n   */\n  check (f, err) {\n    const c = f.constructor === Function && f.length <= this.len\n    /* c8 ignore next */\n    !c && err?.extend(null, 'function', typeof f)\n    return c\n  }\n}\n\n/**\n * @template {Schema<any>[]} Args\n * @param {Args} args\n * @return {Schema<(...args:UnwrapArray<TuplePop<Args>>)=>Unwrap<TupleLast<Args>>>}\n */\nconst $lambda = (...args) => new $Lambda(args.length > 0 ? args : [$void])\nconst $$lambda = $constructedBy($Lambda)\n\n/**\n * @type {Schema<Function>}\n */\nconst $function = $custom(o => typeof o === 'function')\n\n/**\n * @template {Array<Schema<any>>} T\n * @extends {Schema<Intersect<UnwrapArray<T>>>}\n */\nclass $Intersection extends Schema {\n  /**\n   * @param {T} v\n   */\n  constructor (v) {\n    super()\n    /**\n     * @type {T}\n     */\n    this.shape = v\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is Intersect<UnwrapArray<T>>}\n   */\n  check (o, err) {\n    // @ts-ignore\n    const c = _array_js__WEBPACK_IMPORTED_MODULE_1__.every(this.shape, check => check.check(o, err))\n    /* c8 ignore next */\n    !c && err?.extend(null, 'Intersectinon', typeof o)\n    return c\n  }\n}\n\n/**\n * @template {Schema<any>[]} T\n * @param {T} def\n * @return {CastToSchema<$Intersection<T>>}\n */\nconst $intersect = (...def) => new $Intersection(def)\nconst $$intersect = $constructedBy($Intersection, o => o.shape.length > 0) // Intersection with length=0 is considered \"any\"\n\n/**\n * @template S\n * @extends {Schema<S>}\n */\nclass $Union extends Schema {\n  static _dilutes = true\n\n  /**\n   * @param {Array<Schema<S>>} v\n   */\n  constructor (v) {\n    super()\n    this.shape = v\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is S}\n   */\n  check (o, err) {\n    const c = _array_js__WEBPACK_IMPORTED_MODULE_1__.some(this.shape, (vv) => vv.check(o, err))\n    err?.extend(null, 'Union', typeof o)\n    return c\n  }\n}\n\n/**\n * @template {Array<any>} T\n * @param {T} schemas\n * @return {CastToSchema<$Union<Unwrap<ReadSchema<T>>>>}\n */\nconst $union = (...schemas) => schemas.findIndex($s => $$union.check($s)) >= 0\n  ? $union(...schemas.map($s => $($s)).map($s => $$union.check($s) ? $s.shape : [$s]).flat(1))\n  : (schemas.length === 1\n      ? schemas[0]\n      : new $Union(schemas))\nconst $$union = /** @type {Schema<$Union<any>>} */ ($constructedBy($Union))\n\nconst _t = () => true\n/**\n * @type {Schema<any>}\n */\nconst $any = $custom(_t)\nconst $$any = /** @type {Schema<Schema<any>>} */ ($constructedBy($Custom, o => o.shape === _t))\n\n/**\n * @type {Schema<bigint>}\n */\nconst $bigint = $custom(o => typeof o === 'bigint')\nconst $$bigint = /** @type {Schema<Schema<BigInt>>} */ ($custom(o => o === $bigint))\n\n/**\n * @type {Schema<symbol>}\n */\nconst $symbol = $custom(o => typeof o === 'symbol')\nconst $$symbol = /** @type {Schema<Schema<Symbol>>} */ ($custom(o => o === $symbol))\n\n/**\n * @type {Schema<number>}\n */\nconst $number = $custom(o => typeof o === 'number')\nconst $$number = /** @type {Schema<Schema<number>>} */ ($custom(o => o === $number))\n\n/**\n * @type {Schema<string>}\n */\nconst $string = $custom(o => typeof o === 'string')\nconst $$string = /** @type {Schema<Schema<string>>} */ ($custom(o => o === $string))\n\n/**\n * @type {Schema<boolean>}\n */\nconst $boolean = $custom(o => typeof o === 'boolean')\nconst $$boolean = /** @type {Schema<Schema<Boolean>>} */ ($custom(o => o === $boolean))\n\n/**\n * @type {Schema<undefined>}\n */\nconst $undefined = $literal(undefined)\nconst $$undefined = /** @type {Schema<Schema<undefined>>} */ ($constructedBy($Literal, o => o.shape.length === 1 && o.shape[0] === undefined))\n\n/**\n * @type {Schema<void>}\n */\nconst $void = $literal(undefined)\nconst $$void = /** @type {Schema<Schema<void>>} */ ($$undefined)\n\nconst $null = $literal(null)\nconst $$null = /** @type {Schema<Schema<null>>} */ ($constructedBy($Literal, o => o.shape.length === 1 && o.shape[0] === null))\n\nconst $uint8Array = $constructedBy(Uint8Array)\nconst $$uint8Array = /** @type {Schema<Schema<Uint8Array>>} */ ($constructedBy($ConstructedBy, o => o.shape === Uint8Array))\n\n/**\n * @type {Schema<Primitive>}\n */\nconst $primitive = $union($number, $string, $null, $undefined, $bigint, $boolean, $symbol)\n\n/**\n * @typedef {JSON[]} JSONArray\n */\n/**\n * @typedef {Primitive|JSONArray|{ [key:string]:JSON }} JSON\n */\n/**\n * @type {Schema<null|number|string|boolean|JSON[]|{[key:string]:JSON}>}\n */\nconst $json = (() => {\n  const $jsonArr = /** @type {$Array<$any>} */ ($array($any))\n  const $jsonRecord = /** @type {$Record<$string,$any>} */ ($record($string, $any))\n  const $json = $union($number, $string, $null, $boolean, $jsonArr, $jsonRecord)\n  $jsonArr.shape = $json\n  $jsonRecord.shape.values = $json\n  return $json\n})()\n\n/**\n * @template {any} IN\n * @typedef {IN extends Schema<any> ? IN\n *   : (IN extends string|number|boolean|null ? Schema<IN>\n *     : (IN extends new (...args:any[])=>any ? Schema<InstanceType<IN>>\n *       : (IN extends any[] ? Schema<{ [K in keyof IN]: Unwrap<ReadSchema<IN[K]>> }[number]>\n   *       : (IN extends object ? (_ObjectDefToSchema<{[K in keyof IN]:ReadSchema<IN[K]>}> extends Schema<infer S> ? Schema<{ [K in keyof S]: S[K] }> : never)\n   *         : never)\n *         )\n *       )\n *     )\n * } ReadSchemaOld\n */\n\n/**\n * @template {any} IN\n * @typedef {[Extract<IN,Schema<any>>,Extract<IN,string|number|boolean|null>,Extract<IN,new (...args:any[])=>any>,Extract<IN,any[]>,Extract<Exclude<IN,Schema<any>|string|number|boolean|null|(new (...args:any[])=>any)|any[]>,object>] extends [infer Schemas, infer Primitives, infer Constructors, infer Arrs, infer Obj]\n *   ? Schema<\n *       (Schemas extends Schema<infer S> ? S : never)\n *     | Primitives\n *     | (Constructors extends new (...args:any[])=>any ? InstanceType<Constructors> : never)\n *     | (Arrs extends any[] ? { [K in keyof Arrs]: Unwrap<ReadSchema<Arrs[K]>> }[number] : never)\n *     | (Obj extends object ? Unwrap<(_ObjectDefToSchema<{[K in keyof Obj]:ReadSchema<Obj[K]>}> extends Schema<infer S> ? Schema<{ [K in keyof S]: S[K] }> : never)> : never)>\n *   : never\n * } ReadSchema\n */\n\n/**\n * @typedef {ReadSchema<{x:42}|{y:99}|Schema<string>|[1,2,{}]>} Q\n */\n\n/**\n * @template IN\n * @param {IN} o\n * @return {ReadSchema<IN>}\n */\nconst $ = o => {\n  if ($$schema.check(o)) {\n    return /** @type {any} */ (o)\n  } else if ($objectAny.check(o)) {\n    /**\n     * @type {any}\n     */\n    const o2 = {}\n    for (const k in o) {\n      o2[k] = $(o[k])\n    }\n    return /** @type {any} */ ($object(o2))\n  } else if ($arrayAny.check(o)) {\n    return /** @type {any} */ ($union(...o.map($)))\n  } else if ($primitive.check(o)) {\n    return /** @type {any} */ ($literal(o))\n  } else if ($function.check(o)) {\n    return /** @type {any} */ ($constructedBy(/** @type {any} */ (o)))\n  }\n  /* c8 ignore next */\n  _error_js__WEBPACK_IMPORTED_MODULE_2__.unexpectedCase()\n}\n\n/* c8 ignore start */\n/**\n * Assert that a variable is of this specific type.\n * The assertion check is only performed in non-production environments.\n *\n * @type {<T>(o:any,schema:Schema<T>) => asserts o is T}\n */\nconst assert = _environment_js__WEBPACK_IMPORTED_MODULE_3__.production\n  ? () => {}\n  : (o, schema) => {\n      const err = new ValidationError()\n      if (!schema.check(o, err)) {\n        throw _error_js__WEBPACK_IMPORTED_MODULE_2__.create(`Expected value to be of type ${schema.constructor.name}.\\n${err.toString()}`)\n      }\n    }\n/* c8 ignore end */\n\n/**\n * @template In\n * @template Out\n * @typedef {{ if: Schema<In>, h: (o:In,state?:any)=>Out }} Pattern\n */\n\n/**\n * @template {Pattern<any,any>} P\n * @template In\n * @typedef {ReturnType<Extract<P,Pattern<In extends number ? number : (In extends string ? string : In),any>>['h']>} PatternMatchResult\n */\n\n/**\n * @todo move this to separate library\n * @template {any} [State=undefined]\n * @template {Pattern<any,any>} [Patterns=never]\n */\nclass PatternMatcher {\n  /**\n   * @param {Schema<State>} [$state]\n   */\n  constructor ($state) {\n    /**\n     * @type {Array<Patterns>}\n     */\n    this.patterns = []\n    this.$state = $state\n  }\n\n  /**\n   * @template P\n   * @template R\n   * @param {P} pattern\n   * @param {(o:NoInfer<Unwrap<ReadSchema<P>>>,s:State)=>R} handler\n   * @return {PatternMatcher<State,Patterns|Pattern<Unwrap<ReadSchema<P>>,R>>}\n   */\n  if (pattern, handler) {\n    // @ts-ignore\n    this.patterns.push({ if: $(pattern), h: handler })\n    // @ts-ignore\n    return this\n  }\n\n  /**\n   * @template R\n   * @param {(o:any,s:State)=>R} h\n   */\n  else (h) {\n    return this.if($any, h)\n  }\n\n  /**\n   * @return {State extends undefined\n   *   ? <In extends Unwrap<Patterns['if']>>(o:In,state?:undefined)=>PatternMatchResult<Patterns,In>\n   *   : <In extends Unwrap<Patterns['if']>>(o:In,state:State)=>PatternMatchResult<Patterns,In>}\n   */\n  done () {\n    // @ts-ignore\n    return /** @type {any} */ (o, s) => {\n      for (let i = 0; i < this.patterns.length; i++) {\n        const p = this.patterns[i]\n        if (p.if.check(o)) {\n          // @ts-ignore\n          return p.h(o, s)\n        }\n      }\n      throw _error_js__WEBPACK_IMPORTED_MODULE_2__.create('Unhandled pattern')\n    }\n  }\n}\n\n/**\n * @template [State=undefined]\n * @param {State} [state]\n * @return {PatternMatcher<State extends undefined ? undefined : Unwrap<ReadSchema<State>>>}\n */\nconst match = state => new PatternMatcher(/** @type {any} */ (state))\n\n/**\n * Helper function to generate a (non-exhaustive) sample set from a gives schema.\n *\n * @type {<T>(o:T,gen:prng.PRNG)=>T}\n */\nconst _random = /** @type {any} */ (match(/** @type {Schema<prng.PRNG>} */ ($any))\n  .if($$number, (_o, gen) => _prng_js__WEBPACK_IMPORTED_MODULE_7__.int53(gen, _number_js__WEBPACK_IMPORTED_MODULE_8__.MIN_SAFE_INTEGER, _number_js__WEBPACK_IMPORTED_MODULE_8__.MAX_SAFE_INTEGER))\n  .if($$string, (_o, gen) => _prng_js__WEBPACK_IMPORTED_MODULE_7__.word(gen))\n  .if($$boolean, (_o, gen) => _prng_js__WEBPACK_IMPORTED_MODULE_7__.bool(gen))\n  .if($$bigint, (_o, gen) => BigInt(_prng_js__WEBPACK_IMPORTED_MODULE_7__.int53(gen, _number_js__WEBPACK_IMPORTED_MODULE_8__.MIN_SAFE_INTEGER, _number_js__WEBPACK_IMPORTED_MODULE_8__.MAX_SAFE_INTEGER)))\n  .if($$union, (o, gen) => random(gen, _prng_js__WEBPACK_IMPORTED_MODULE_7__.oneOf(gen, o.shape)))\n  .if($$object, (o, gen) => {\n    /**\n     * @type {any}\n     */\n    const res = {}\n    for (const k in o.shape) {\n      let prop = o.shape[k]\n      if ($$optional.check(prop)) {\n        if (_prng_js__WEBPACK_IMPORTED_MODULE_7__.bool(gen)) { continue }\n        prop = prop.shape\n      }\n      res[k] = _random(prop, gen)\n    }\n    return res\n  })\n  .if($$array, (o, gen) => {\n    const arr = []\n    const n = _prng_js__WEBPACK_IMPORTED_MODULE_7__.int32(gen, 0, 42)\n    for (let i = 0; i < n; i++) {\n      arr.push(random(gen, o.shape))\n    }\n    return arr\n  })\n  .if($$literal, (o, gen) => {\n    return _prng_js__WEBPACK_IMPORTED_MODULE_7__.oneOf(gen, o.shape)\n  })\n  .if($$null, (o, gen) => {\n    return null\n  })\n  .if($$lambda, (o, gen) => {\n    const res = random(gen, o.res)\n    return () => res\n  })\n  .if($$any, (o, gen) => random(gen, _prng_js__WEBPACK_IMPORTED_MODULE_7__.oneOf(gen, [\n    $number, $string, $null, $undefined, $bigint, $boolean,\n    $array($number),\n    $record($union('a', 'b', 'c'), $number)\n  ])))\n  .if($$record, (o, gen) => {\n    /**\n     * @type {any}\n     */\n    const res = {}\n    const keysN = _prng_js__WEBPACK_IMPORTED_MODULE_7__.int53(gen, 0, 3)\n    for (let i = 0; i < keysN; i++) {\n      const key = random(gen, o.shape.keys)\n      const val = random(gen, o.shape.values)\n      res[key] = val\n    }\n    return res\n  })\n  .done())\n\n/**\n * @template S\n * @param {prng.PRNG} gen\n * @param {S} schema\n * @return {Unwrap<ReadSchema<S>>}\n */\nconst random = (gen, schema) => /** @type {any} */ (_random($(schema), gen))\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/schema.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/set.js"
/*!**************************************!*\
  !*** ../../node_modules/lib0/set.js ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   toArray: () => (/* binding */ toArray)\n/* harmony export */ });\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nconst toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T|undefined}\n */\nconst first = set => set.values().next().value\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nconst from = entries => new Set(entries)\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/set.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/storage.js"
/*!******************************************!*\
  !*** ../../node_modules/lib0/storage.js ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   offChange: () => (/* binding */ offChange),\n/* harmony export */   onChange: () => (/* binding */ onChange),\n/* harmony export */   varStorage: () => (/* binding */ varStorage)\n/* harmony export */ });\n/* eslint-env browser */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* c8 ignore start */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\n/* c8 ignore start */\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  if (typeof localStorage !== 'undefined' && localStorage) {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n/* c8 ignore stop */\n\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\n/* c8 ignore next */\nconst varStorage = _localStorage\n\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nconst onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n\n/**\n * A polyfill for `removeEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nconst offChange = eventHandler => usePolyfill || removeEventListener('storage', /** @type {any} */ (eventHandler))\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/storage.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/string.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/string.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_UTF16_CHARACTER: () => (/* binding */ MAX_UTF16_CHARACTER),\n/* harmony export */   _decodeUtf8Native: () => (/* binding */ _decodeUtf8Native),\n/* harmony export */   _decodeUtf8Polyfill: () => (/* binding */ _decodeUtf8Polyfill),\n/* harmony export */   _encodeUtf8Native: () => (/* binding */ _encodeUtf8Native),\n/* harmony export */   _encodeUtf8Polyfill: () => (/* binding */ _encodeUtf8Polyfill),\n/* harmony export */   decodeUtf8: () => (/* binding */ decodeUtf8),\n/* harmony export */   encodeUtf8: () => (/* binding */ encodeUtf8),\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   fromCamelCase: () => (/* binding */ fromCamelCase),\n/* harmony export */   fromCharCode: () => (/* binding */ fromCharCode),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint),\n/* harmony export */   repeat: () => (/* binding */ repeat),\n/* harmony export */   splice: () => (/* binding */ splice),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   unescapeHTML: () => (/* binding */ unescapeHTML),\n/* harmony export */   utf8ByteLength: () => (/* binding */ utf8ByteLength),\n/* harmony export */   utf8TextDecoder: () => (/* binding */ utf8TextDecoder),\n/* harmony export */   utf8TextEncoder: () => (/* binding */ utf8TextEncoder)\n/* harmony export */ });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ \"../../node_modules/lib0/array.js\");\n\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nconst fromCharCode = String.fromCharCode\nconst fromCodePoint = String.fromCodePoint\n\n/**\n * The largest utf16 character.\n * Corresponds to Uint8Array([255, 255]) or charcodeof(2x2^8)\n */\nconst MAX_UTF16_CHARACTER = fromCharCode(65535)\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nconst fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nconst utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array<ArrayBuffer>}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array<ArrayBuffer>}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* c8 ignore next */\nconst decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nconst splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n\n/**\n * @param {string} source\n * @param {number} n\n */\nconst repeat = (source, n) => _array_js__WEBPACK_IMPORTED_MODULE_0__.unfold(n, () => source).join('')\n\n/**\n * Escape HTML characters &,<,>,',\" to their respective HTML entities &amp;,&lt;,&gt;,&#39;,&quot;\n *\n * @param {string} str\n */\nconst escapeHTML = str =>\n  str.replace(/[&<>'\"]/g, r => /** @type {string} */ ({\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    \"'\": '&#39;',\n    '\"': '&quot;'\n  }[r]))\n\n/**\n * Reverse of `escapeHTML`\n *\n * @param {string} str\n */\nconst unescapeHTML = str =>\n  str.replace(/&amp;|&lt;|&gt;|&#39;|&quot;/g, r => /** @type {string} */ ({\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&#39;': \"'\",\n    '&quot;': '\"'\n  }[r]))\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/string.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/symbol.js"
/*!*****************************************!*\
  !*** ../../node_modules/lib0/symbol.js ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   isSymbol: () => (/* binding */ isSymbol)\n/* harmony export */ });\n/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n */\nconst create = Symbol\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nconst isSymbol = s => typeof s === 'symbol'\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/symbol.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/time.js"
/*!***************************************!*\
  !*** ../../node_modules/lib0/time.js ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDate: () => (/* binding */ getDate),\n/* harmony export */   getUnixTime: () => (/* binding */ getUnixTime),\n/* harmony export */   humanizeDuration: () => (/* binding */ humanizeDuration)\n/* harmony export */ });\n/* harmony import */ var _metric_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metric.js */ \"../../node_modules/lib0/metric.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"../../node_modules/lib0/math.js\");\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n\n\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nconst getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nconst humanizeDuration = d => {\n  if (d < 60000) {\n    const p = _metric_js__WEBPACK_IMPORTED_MODULE_0__.prefix(d, -1)\n    return _math_js__WEBPACK_IMPORTED_MODULE_1__.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 60) % 60\n  const hours = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 3600) % 24\n  const days = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* c8 ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/time.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/trait/equality.js"
/*!*************************************************!*\
  !*** ../../node_modules/lib0/trait/equality.js ***!
  \*************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EqualityTraitSymbol: () => (/* binding */ EqualityTraitSymbol),\n/* harmony export */   equals: () => (/* binding */ equals)\n/* harmony export */ });\nconst EqualityTraitSymbol = Symbol('Equality')\n\n/**\n * @typedef {{ [EqualityTraitSymbol]:(other:EqualityTrait)=>boolean }} EqualityTrait\n */\n\n/**\n *\n * Utility function to compare any two objects.\n *\n * Note that it is expected that the first parameter is more specific than the latter one.\n *\n * @example js\n *     class X { [traits.EqualityTraitSymbol] (other) { return other === this }  }\n *     class X2 { [traits.EqualityTraitSymbol] (other) { return other === this }, x2 () { return 2 }  }\n *     // this is fine\n *     traits.equals(new X2(), new X())\n *     // this is not, because the left type is less specific than the right one\n *     traits.equals(new X(), new X2())\n *\n * @template {EqualityTrait} T\n * @param {NoInfer<T>} a\n * @param {T} b\n * @return {boolean}\n */\nconst equals = (a, b) => a === b || a[EqualityTraitSymbol]?.(b) || false\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/trait/equality.js?\n}");

/***/ },

/***/ "../../node_modules/lib0/webcrypto.js"
/*!********************************************!*\
  !*** ../../node_modules/lib0/webcrypto.js ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRandomValues: () => (/* binding */ getRandomValues),\n/* harmony export */   subtle: () => (/* binding */ subtle)\n/* harmony export */ });\n/* eslint-env browser */\n\nconst subtle = crypto.subtle\nconst getRandomValues = crypto.getRandomValues.bind(crypto)\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/lib0/webcrypto.js?\n}");

/***/ },

/***/ "../../node_modules/uuid/dist/esm-browser/regex.js"
/*!*********************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/regex.js ***!
  \*********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/uuid/dist/esm-browser/regex.js?\n}");

/***/ },

/***/ "../../node_modules/uuid/dist/esm-browser/rng.js"
/*!*******************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/rng.js ***!
  \*******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/uuid/dist/esm-browser/rng.js?\n}");

/***/ },

/***/ "../../node_modules/uuid/dist/esm-browser/stringify.js"
/*!*************************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"../../node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/uuid/dist/esm-browser/stringify.js?\n}");

/***/ },

/***/ "../../node_modules/uuid/dist/esm-browser/v4.js"
/*!******************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/v4.js ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"../../node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"../../node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/uuid/dist/esm-browser/v4.js?\n}");

/***/ },

/***/ "../../node_modules/uuid/dist/esm-browser/validate.js"
/*!************************************************************!*\
  !*** ../../node_modules/uuid/dist/esm-browser/validate.js ***!
  \************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"../../node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/uuid/dist/esm-browser/validate.js?\n}");

/***/ },

/***/ "../../node_modules/y-protocols/awareness.js"
/*!***************************************************!*\
  !*** ../../node_modules/y-protocols/awareness.js ***!
  \***************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Awareness: () => (/* binding */ Awareness),\n/* harmony export */   applyAwarenessUpdate: () => (/* binding */ applyAwarenessUpdate),\n/* harmony export */   encodeAwarenessUpdate: () => (/* binding */ encodeAwarenessUpdate),\n/* harmony export */   modifyAwarenessUpdate: () => (/* binding */ modifyAwarenessUpdate),\n/* harmony export */   outdatedTimeout: () => (/* binding */ outdatedTimeout),\n/* harmony export */   removeAwarenessStates: () => (/* binding */ removeAwarenessStates)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/encoding */ \"../../node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/decoding */ \"../../node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/time */ \"../../node_modules/lib0/time.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/math */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/observable */ \"../../node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/function */ \"../../node_modules/lib0/function.js\");\n/**\n * @module awareness-protocol\n */\n\n\n\n\n\n\n\n // eslint-disable-line\n\nconst outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends lib0_observable__WEBPACK_IMPORTED_MODULE_4__.Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, lib0_math__WEBPACK_IMPORTED_MODULE_3__.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!lib0_function__WEBPACK_IMPORTED_MODULE_5__.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.createEncoder()\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, clientID)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, clock)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.writeVarString(encoder, JSON.stringify(state))\n  }\n  return lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nconst modifyAwarenessUpdate = (update, modify) => {\n  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.createDecoder(update)\n  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.createEncoder()\n  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)\n    const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.readVarString(decoder))\n    const modifiedState = modify(state)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, clientID)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, clock)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return lib0_encoding__WEBPACK_IMPORTED_MODULE_0__.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.createDecoder(update)\n  const timestamp = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)\n    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_1__.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!lib0_function__WEBPACK_IMPORTED_MODULE_5__.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/y-protocols/awareness.js?\n}");

/***/ },

/***/ "../../node_modules/yjs/dist/yjs.mjs"
/*!*******************************************!*\
  !*** ../../node_modules/yjs/dist/yjs.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsolutePosition: () => (/* binding */ AbsolutePosition),\n/* harmony export */   AbstractConnector: () => (/* binding */ AbstractConnector),\n/* harmony export */   AbstractStruct: () => (/* binding */ AbstractStruct),\n/* harmony export */   AbstractType: () => (/* binding */ AbstractType),\n/* harmony export */   Array: () => (/* binding */ YArray),\n/* harmony export */   ContentAny: () => (/* binding */ ContentAny),\n/* harmony export */   ContentBinary: () => (/* binding */ ContentBinary),\n/* harmony export */   ContentDeleted: () => (/* binding */ ContentDeleted),\n/* harmony export */   ContentDoc: () => (/* binding */ ContentDoc),\n/* harmony export */   ContentEmbed: () => (/* binding */ ContentEmbed),\n/* harmony export */   ContentFormat: () => (/* binding */ ContentFormat),\n/* harmony export */   ContentJSON: () => (/* binding */ ContentJSON),\n/* harmony export */   ContentString: () => (/* binding */ ContentString),\n/* harmony export */   ContentType: () => (/* binding */ ContentType),\n/* harmony export */   Doc: () => (/* binding */ Doc),\n/* harmony export */   GC: () => (/* binding */ GC),\n/* harmony export */   ID: () => (/* binding */ ID),\n/* harmony export */   Item: () => (/* binding */ Item),\n/* harmony export */   Map: () => (/* binding */ YMap),\n/* harmony export */   PermanentUserData: () => (/* binding */ PermanentUserData),\n/* harmony export */   RelativePosition: () => (/* binding */ RelativePosition),\n/* harmony export */   Skip: () => (/* binding */ Skip),\n/* harmony export */   Snapshot: () => (/* binding */ Snapshot),\n/* harmony export */   Text: () => (/* binding */ YText),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   UndoManager: () => (/* binding */ UndoManager),\n/* harmony export */   UpdateDecoderV1: () => (/* binding */ UpdateDecoderV1),\n/* harmony export */   UpdateDecoderV2: () => (/* binding */ UpdateDecoderV2),\n/* harmony export */   UpdateEncoderV1: () => (/* binding */ UpdateEncoderV1),\n/* harmony export */   UpdateEncoderV2: () => (/* binding */ UpdateEncoderV2),\n/* harmony export */   XmlElement: () => (/* binding */ YXmlElement),\n/* harmony export */   XmlFragment: () => (/* binding */ YXmlFragment),\n/* harmony export */   XmlHook: () => (/* binding */ YXmlHook),\n/* harmony export */   XmlText: () => (/* binding */ YXmlText),\n/* harmony export */   YArrayEvent: () => (/* binding */ YArrayEvent),\n/* harmony export */   YEvent: () => (/* binding */ YEvent),\n/* harmony export */   YMapEvent: () => (/* binding */ YMapEvent),\n/* harmony export */   YTextEvent: () => (/* binding */ YTextEvent),\n/* harmony export */   YXmlEvent: () => (/* binding */ YXmlEvent),\n/* harmony export */   applyUpdate: () => (/* binding */ applyUpdate),\n/* harmony export */   applyUpdateV2: () => (/* binding */ applyUpdateV2),\n/* harmony export */   cleanupYTextFormatting: () => (/* binding */ cleanupYTextFormatting),\n/* harmony export */   compareIDs: () => (/* binding */ compareIDs),\n/* harmony export */   compareRelativePositions: () => (/* binding */ compareRelativePositions),\n/* harmony export */   convertUpdateFormatV1ToV2: () => (/* binding */ convertUpdateFormatV1ToV2),\n/* harmony export */   convertUpdateFormatV2ToV1: () => (/* binding */ convertUpdateFormatV2ToV1),\n/* harmony export */   createAbsolutePositionFromRelativePosition: () => (/* binding */ createAbsolutePositionFromRelativePosition),\n/* harmony export */   createDeleteSet: () => (/* binding */ createDeleteSet),\n/* harmony export */   createDeleteSetFromStructStore: () => (/* binding */ createDeleteSetFromStructStore),\n/* harmony export */   createDocFromSnapshot: () => (/* binding */ createDocFromSnapshot),\n/* harmony export */   createID: () => (/* binding */ createID),\n/* harmony export */   createRelativePositionFromJSON: () => (/* binding */ createRelativePositionFromJSON),\n/* harmony export */   createRelativePositionFromTypeIndex: () => (/* binding */ createRelativePositionFromTypeIndex),\n/* harmony export */   createSnapshot: () => (/* binding */ createSnapshot),\n/* harmony export */   decodeRelativePosition: () => (/* binding */ decodeRelativePosition),\n/* harmony export */   decodeSnapshot: () => (/* binding */ decodeSnapshot),\n/* harmony export */   decodeSnapshotV2: () => (/* binding */ decodeSnapshotV2),\n/* harmony export */   decodeStateVector: () => (/* binding */ decodeStateVector),\n/* harmony export */   decodeUpdate: () => (/* binding */ decodeUpdate),\n/* harmony export */   decodeUpdateV2: () => (/* binding */ decodeUpdateV2),\n/* harmony export */   diffUpdate: () => (/* binding */ diffUpdate),\n/* harmony export */   diffUpdateV2: () => (/* binding */ diffUpdateV2),\n/* harmony export */   emptySnapshot: () => (/* binding */ emptySnapshot),\n/* harmony export */   encodeRelativePosition: () => (/* binding */ encodeRelativePosition),\n/* harmony export */   encodeSnapshot: () => (/* binding */ encodeSnapshot),\n/* harmony export */   encodeSnapshotV2: () => (/* binding */ encodeSnapshotV2),\n/* harmony export */   encodeStateAsUpdate: () => (/* binding */ encodeStateAsUpdate),\n/* harmony export */   encodeStateAsUpdateV2: () => (/* binding */ encodeStateAsUpdateV2),\n/* harmony export */   encodeStateVector: () => (/* binding */ encodeStateVector),\n/* harmony export */   encodeStateVectorFromUpdate: () => (/* binding */ encodeStateVectorFromUpdate),\n/* harmony export */   encodeStateVectorFromUpdateV2: () => (/* binding */ encodeStateVectorFromUpdateV2),\n/* harmony export */   equalDeleteSets: () => (/* binding */ equalDeleteSets),\n/* harmony export */   equalSnapshots: () => (/* binding */ equalSnapshots),\n/* harmony export */   findIndexSS: () => (/* binding */ findIndexSS),\n/* harmony export */   findRootTypeKey: () => (/* binding */ findRootTypeKey),\n/* harmony export */   getItem: () => (/* binding */ getItem),\n/* harmony export */   getItemCleanEnd: () => (/* binding */ getItemCleanEnd),\n/* harmony export */   getItemCleanStart: () => (/* binding */ getItemCleanStart),\n/* harmony export */   getState: () => (/* binding */ getState),\n/* harmony export */   getTypeChildren: () => (/* binding */ getTypeChildren),\n/* harmony export */   isDeleted: () => (/* binding */ isDeleted),\n/* harmony export */   isParentOf: () => (/* binding */ isParentOf),\n/* harmony export */   iterateDeletedStructs: () => (/* binding */ iterateDeletedStructs),\n/* harmony export */   logType: () => (/* binding */ logType),\n/* harmony export */   logUpdate: () => (/* binding */ logUpdate),\n/* harmony export */   logUpdateV2: () => (/* binding */ logUpdateV2),\n/* harmony export */   mergeDeleteSets: () => (/* binding */ mergeDeleteSets),\n/* harmony export */   mergeUpdates: () => (/* binding */ mergeUpdates),\n/* harmony export */   mergeUpdatesV2: () => (/* binding */ mergeUpdatesV2),\n/* harmony export */   obfuscateUpdate: () => (/* binding */ obfuscateUpdate),\n/* harmony export */   obfuscateUpdateV2: () => (/* binding */ obfuscateUpdateV2),\n/* harmony export */   parseUpdateMeta: () => (/* binding */ parseUpdateMeta),\n/* harmony export */   parseUpdateMetaV2: () => (/* binding */ parseUpdateMetaV2),\n/* harmony export */   readUpdate: () => (/* binding */ readUpdate),\n/* harmony export */   readUpdateV2: () => (/* binding */ readUpdateV2),\n/* harmony export */   relativePositionToJSON: () => (/* binding */ relativePositionToJSON),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   snapshotContainsUpdate: () => (/* binding */ snapshotContainsUpdate),\n/* harmony export */   transact: () => (/* binding */ transact),\n/* harmony export */   tryGc: () => (/* binding */ tryGc),\n/* harmony export */   typeListToArraySnapshot: () => (/* binding */ typeListToArraySnapshot),\n/* harmony export */   typeMapGetAllSnapshot: () => (/* binding */ typeMapGetAllSnapshot),\n/* harmony export */   typeMapGetSnapshot: () => (/* binding */ typeMapGetSnapshot)\n/* harmony export */ });\n/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable */ \"../../node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/array */ \"../../node_modules/lib0/array.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/math */ \"../../node_modules/lib0/math.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/map */ \"../../node_modules/lib0/map.js\");\n/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding */ \"../../node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding */ \"../../node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/random */ \"../../node_modules/lib0/random.js\");\n/* harmony import */ var lib0_promise__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/promise */ \"../../node_modules/lib0/promise.js\");\n/* harmony import */ var lib0_buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/buffer */ \"../../node_modules/lib0/buffer.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/error */ \"../../node_modules/lib0/error.js\");\n/* harmony import */ var lib0_binary__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/binary */ \"../../node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/function */ \"../../node_modules/lib0/function.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/set */ \"../../node_modules/lib0/set.js\");\n/* harmony import */ var lib0_logging__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/logging */ \"../../node_modules/lib0/logging.js\");\n/* harmony import */ var lib0_logging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/logging */ \"../../node_modules/lib0/logging.common.js\");\n/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/time */ \"../../node_modules/lib0/time.js\");\n/* harmony import */ var lib0_string__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lib0/string */ \"../../node_modules/lib0/string.js\");\n/* harmony import */ var lib0_iterator__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lib0/iterator */ \"../../node_modules/lib0/iterator.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lib0/object */ \"../../node_modules/lib0/object.js\");\n/* harmony import */ var lib0_environment__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! lib0/environment */ \"../../node_modules/lib0/environment.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {ObservableV2<any>}\n */\nclass AbstractConnector extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.ObservableV2 {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n}\n\nclass DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock;\n    /**\n     * @type {number}\n     */\n    this.len = len;\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nclass DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map();\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));\n    if (structs != null) {\n      const lastStruct = structs[structs.length - 1];\n      const clockState = lastStruct.id.clock + lastStruct.length;\n      for (let i = 0, del = deletes[i]; i < deletes.length && del.clock < clockState; del = deletes[++i]) {\n        iterateStructs(transaction, structs, del.clock, del.len, f);\n      }\n    }\n  });\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nconst findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = lib0_math__WEBPACK_IMPORTED_MODULE_2__.floor((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client);\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n};\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock);\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len >= right.clock) {\n        left.len = lib0_math__WEBPACK_IMPORTED_MODULE_2__.max(left.len, right.clock + right.len - left.clock);\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nconst mergeDeleteSets = dss => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          lib0_array__WEBPACK_IMPORTED_MODULE_1__.appendTo(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nconst addToDeleteSet = (ds, client, clock, length) => {\n  lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, () => /** @type {Array<DeleteItem>} */ ([])).push(new DeleteItem(clock, length));\n};\n\nconst createDeleteSet = () => new DeleteSet();\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nconst createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst writeDeleteSet = (encoder, ds) => {\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, ds.clients.size);\n\n  // Ensure that the delete set is written in a deterministic order\n  lib0_array__WEBPACK_IMPORTED_MODULE_1__.from(ds.clients.entries())\n    .sort((a, b) => b[0] - a[0])\n    .forEach(([client, dsitems]) => {\n      encoder.resetDsCurVal();\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client);\n      const len = dsitems.length;\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, len);\n      for (let i = 0; i < len; i++) {\n        const item = dsitems[i];\n        encoder.writeDsClock(item.clock);\n        encoder.writeDsLen(item.len);\n      }\n    });\n};\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nconst readDeleteSet = decoder => {\n  const ds = new DeleteSet();\n  const numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, () => /** @type {Array<DeleteItem>} */ ([]));\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds\n};\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nconst readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index];\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++; // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2();\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(ds.restEncoder, 0); // encode 0 structs\n    writeDeleteSet(ds, unappliedDS);\n    return ds.toUint8Array()\n  }\n  return null\n};\n\n/**\n * @param {DeleteSet} ds1\n * @param {DeleteSet} ds2\n */\nconst equalDeleteSets = (ds1, ds2) => {\n  if (ds1.clients.size !== ds2.clients.size) return false\n  for (const [client, deleteItems1] of ds1.clients.entries()) {\n    const deleteItems2 = /** @type {Array<import('../internals.js').DeleteItem>} */ (ds2.clients.get(client));\n    if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false\n    for (let i = 0; i < deleteItems1.length; i++) {\n      const di1 = deleteItems1[i];\n      const di2 = deleteItems2[i];\n      if (di1.clock !== di2.clock || di1.len !== di2.len) {\n        return false\n      }\n    }\n  }\n  return true\n};\n\n/**\n * @module Y\n */\n\n\nconst generateNewClientId = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uint32;\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()\n */\n\n/**\n * @typedef {Object} DocEvents\n * @property {function(Doc):void} DocEvents.destroy\n * @property {function(Doc):void} DocEvents.load\n * @property {function(boolean, Doc):void} DocEvents.sync\n * @property {function(Uint8Array, any, Doc, Transaction):void} DocEvents.update\n * @property {function(Uint8Array, any, Doc, Transaction):void} DocEvents.updateV2\n * @property {function(Doc):void} DocEvents.beforeAllTransactions\n * @property {function(Transaction, Doc):void} DocEvents.beforeTransaction\n * @property {function(Transaction, Doc):void} DocEvents.beforeObserverCalls\n * @property {function(Transaction, Doc):void} DocEvents.afterTransaction\n * @property {function(Transaction, Doc):void} DocEvents.afterTransactionCleanup\n * @property {function(Doc, Array<Transaction>):void} DocEvents.afterAllTransactions\n * @property {function({ loaded: Set<Doc>, added: Set<Doc>, removed: Set<Doc> }, Doc, Transaction):void} DocEvents.subdocs\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends ObservableV2<DocEvents>\n */\nclass Doc extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.ObservableV2 {\n  /**\n   * @param {DocOpts} opts configuration\n   */\n  constructor ({ guid = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    this.collectionid = collectionid;\n    /**\n     * @type {Map<string, AbstractType<YEvent<any>>>}\n     */\n    this.share = new Map();\n    this.store = new StructStore();\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null;\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = [];\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set();\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null;\n    this.shouldLoad = shouldLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n    /**\n     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.\n     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.\n     *\n     * @type {boolean}\n     */\n    this.isLoaded = false;\n    /**\n     * This is set to true when the connection provider has successfully synced with a backend.\n     * Note that when using peer-to-peer providers this event may not provide very useful.\n     * Also note that not all providers implement this feature. Provider authors are encouraged to fire\n     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is\n     * lost (with false as a parameter).\n     */\n    this.isSynced = false;\n    this.isDestroyed = false;\n    /**\n     * Promise that resolves once the document has been loaded from a persistence provider.\n     */\n    this.whenLoaded = lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create(resolve => {\n      this.on('load', () => {\n        this.isLoaded = true;\n        resolve(this);\n      });\n    });\n    const provideSyncedPromise = () => lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create(resolve => {\n      /**\n       * @param {boolean} isSynced\n       */\n      const eventHandler = (isSynced) => {\n        if (isSynced === undefined || isSynced === true) {\n          this.off('sync', eventHandler);\n          resolve();\n        }\n      };\n      this.on('sync', eventHandler);\n    });\n    this.on('sync', isSynced => {\n      if (isSynced === false && this.isSynced) {\n        this.whenSynced = provideSyncedPromise();\n      }\n      this.isSynced = isSynced === undefined || isSynced === true;\n      if (this.isSynced && !this.isLoaded) {\n        this.emit('load', [this]);\n      }\n    });\n    /**\n     * Promise that resolves once the document has been synced with a backend.\n     * This promise is recreated when the connection is lost.\n     * Note the documentation about the `isSynced` property.\n     */\n    this.whenSynced = provideSyncedPromise();\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this);\n      }, null, true);\n    }\n    this.shouldLoad = true;\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(lib0_array__WEBPACK_IMPORTED_MODULE_1__.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @template T\n   * @param {function(Transaction):T} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   * @return T\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    return transact(this, f, origin)\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `ydoc.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Y.Doc instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @template {typeof AbstractType<any>} Type\n   * @example\n   *   const ydoc = new Y.Doc(..)\n   *   const appState = {\n   *     document: ydoc.getText('document')\n   *     comments: ydoc.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = /** @type {any} */ (AbstractType)) {\n    const type = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t;\n          }\n        });\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return /** @type {InstanceType<Type>} */ (t)\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return /** @type {InstanceType<Type>} */ (type)\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    return /** @type {YArray<T>} */ (this.get(name, YArray))\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    return this.get(name, YText)\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YMap<T>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    return /** @type {YMap<T>} */ (this.get(name, YMap))\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlElement}\n   *\n   * @public\n   */\n  getXmlElement (name = '') {\n    return /** @type {YXmlElement<{[key:string]:string}>} */ (this.get(name, YXmlElement))\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {};\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON();\n    });\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    this.isDestroyed = true;\n    lib0_array__WEBPACK_IMPORTED_MODULE_1__.from(this.subdocs).forEach(subdoc => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = /** @type {ContentDoc} */ (item.content);\n      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });\n      content.doc._item = item;\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        const doc = content.doc;\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(doc);\n        }\n        transaction.subdocsRemoved.add(this);\n      }, null, true);\n    }\n    // @ts-ignore\n    this.emit('destroyed', [true]); // DEPRECATED!\n    this.emit('destroy', [this]);\n    super.destroy();\n  }\n}\n\nclass DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n}\n\nclass UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return lib0_buffer__WEBPACK_IMPORTED_MODULE_8__.copyUint8Array(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder)\n  }\n}\n\nclass DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff\n  }\n}\n\nclass UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder);\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = [];\n    lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder); // read feature flag - currently unused\n    this.keyClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.clientDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.leftClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.rightClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.infoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.stringDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.StringDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.parentInfoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.typeRefDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.lenDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key\n    }\n  }\n}\n\nclass DSEncoderV1 {\n  constructor () {\n    this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n  }\n\n  toUint8Array () {\n    return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, clock);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);\n  }\n}\n\nclass UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(this.restEncoder, info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, JSON.stringify(embed));\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, key);\n  }\n}\n\nclass DSEncoderV2 {\n  constructor () {\n    this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder(); // encodes all the rest / non-optimized\n    this.dsCurrVal = 0;\n  }\n\n  toUint8Array () {\n    return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, diff);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n}\n\nclass UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super();\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map();\n    /**\n     * Refers to the next unique key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0;\n    this.keyClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.clientEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.leftClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.rightClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.infoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.stringEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.StringEncoder();\n    this.parentInfoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.typeRefEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.lenEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n  }\n\n  toUint8Array () {\n    const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.infoEncoder));\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.parentInfoEncoder));\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n    // @note The rest encoder is appended! (note the missing var)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder));\n    return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client);\n    this.leftClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client);\n    this.rightClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, embed);\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key);\n    if (clock === undefined) {\n      /**\n       * @todo uncomment to introduce this feature finally\n       *\n       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.\n       * Furthermore, I forgot to set the keyclock. So everything was working fine.\n       *\n       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).\n       *\n       * I don't know yet how to reintroduce this feature..\n       *\n       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.\n       *\n       */\n      // this.keyMap.set(key, this.keyClock)\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(clock);\n    }\n  }\n}\n\n/**\n * @module encoding\n */\n/*\n * We use the first five bits in the info flag for determining the type of the struct.\n *\n * 0: GC\n * 1: Item with Deleted content\n * 2: Item with JSON content\n * 3: Item with Binary content\n * 4: Item with String content\n * 5: Item with Embed content (for richtext content)\n * 6: Item with Format content (a formatting marker for richtext content)\n * 7: Item with Type\n */\n\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  clock = lib0_math__WEBPACK_IMPORTED_MODULE_2__.max(clock, structs[0].id.clock); // make sure the first id exists\n  const startNewStructs = findIndexSS(structs, clock);\n  // write # encoded structs\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nconst writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map();\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((_clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  // write # states that were updated\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sm.size);\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  lib0_array__WEBPACK_IMPORTED_MODULE_1__.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    writeStructs(encoder, /** @type {Array<GC|Item>} */ (store.clients.get(client)), client, clock);\n  });\n};\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */\nconst readClientsStructRefs = (decoder, doc) => {\n  /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */\n  const clientRefs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  const numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    // const start = performance.now()\n    clientRefs.set(client, { i: 0, refs });\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      switch (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen();\n          refs[i] = new GC(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n          refs[i] = new Skip(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // left\n            (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          );\n          /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // left\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */\n          refs[i] = struct;\n          clock += struct.length;\n        }\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n};\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is equal to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = [];\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = lib0_array__WEBPACK_IMPORTED_MODULE_1__.from(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore();\n  const missingSV = new Map();\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client);\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock);\n    }\n  };\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];\n  // caching the state because it is used very often\n  const state = new Map();\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client;\n      const inapplicableItems = clientsStructRefs.get(client);\n      if (inapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        inapplicableItems.i--;\n        restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));\n        clientsStructRefs.delete(client);\n        inapplicableItems.i = 0;\n        inapplicableItems.refs = [];\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item]);\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client);\n    }\n    stack.length = 0;\n  };\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n      const offset = localClock - stackHead.id.clock;\n      if (offset < 0) {\n        // update from the same client is missing\n        stack.push(stackHead);\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n        // hid a dead wall, add all items from stack to restSS\n        addStackToRestSS();\n      } else {\n        const missing = stackHead.getMissing(transaction, store);\n        if (missing !== null) {\n          stack.push(stackHead);\n          // get the struct reader that has the missing struct\n          /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */\n          const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };\n          if (structRefs.refs.length === structRefs.i) {\n            // This update message causally depends on another update message that doesn't exist yet\n            updateMissingSv(/** @type {number} */ (missing), getState(store, missing));\n            addStackToRestSS();\n          } else {\n            stackHead = structRefs.refs[structRefs.i++];\n            continue\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          // all fine, apply the stackhead\n          stackHead.integrate(transaction, offset);\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n        }\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop());\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n    } else {\n      curStructsTarget = getNextStructTarget();\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2();\n    writeClientsStructs(encoder, restStructs, new Map());\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nconst writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts a decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nconst readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    // force that transaction.local is set to non-local\n    transaction.local = false;\n    let retry = false;\n    const doc = transaction.doc;\n    const store = doc.store;\n    // let start = performance.now()\n    const ss = readClientsStructRefs(structDecoder, doc);\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss);\n    const pending = store.pendingStructs;\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry = true;\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client);\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock);\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n      }\n    } else {\n      store.pendingStructs = restStructs;\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(store.pendingDs));\n      lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2;\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest;\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;\n      store.pendingStructs = null;\n      applyUpdateV2(transaction.doc, update);\n    }\n  }, transactionOrigin, false);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts a decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nconst applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nconst writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc, targetStateVector);\n  const updates = [encoder.toUint8Array()];\n  // also add the pending updates (if there are any)\n  if (doc.store.pendingDs) {\n    updates.push(doc.store.pendingDs);\n  }\n  if (doc.store.pendingStructs) {\n    updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));\n  }\n  if (updates.length > 1) {\n    if (encoder.constructor === UpdateEncoderV1) {\n      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)))\n    } else if (encoder.constructor === UpdateEncoderV2) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst readStateVector = decoder => {\n  const ss = new Map();\n  const ssLength = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss\n};\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst decodeStateVector = decodedState => readStateVector(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(decodedState)));\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nconst writeStateVector = (encoder, sv) => {\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sv.size);\n  lib0_array__WEBPACK_IMPORTED_MODULE_1__.from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);\n  });\n  return encoder\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nconst writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc);\n  } else {\n    writeDocumentStateVector(encoder, doc);\n  }\n  return encoder.toUint8Array()\n};\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVector = doc => encodeStateVectorV2(doc, new DSEncoderV1());\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nclass EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = [];\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nconst createEventHandler = () => new EventHandler();\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nconst addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f);\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nconst removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter(g => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.');\n  }\n};\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nconst callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll(eventHandler.l, [arg0, arg1]);\n\nclass ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client;\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock;\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock);\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nconst createID = (client, clock) => new ID(client, clock);\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nconst writeID = (encoder, id) => {\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.client);\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.clock);\n};\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nconst readID = decoder =>\n  createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder));\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nconst findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n};\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nconst isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item;\n  }\n  return false\n};\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nconst logType = type => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log('Children: ', res);\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content));\n};\n\nclass PermanentUserData {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor (doc, storeType = doc.getMap('users')) {\n    /**\n     * @type {Map<string,DeleteSet>}\n     */\n    const dss = new Map();\n    this.yusers = storeType;\n    this.doc = doc;\n    /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */\n    this.clients = new Map();\n    this.dss = dss;\n    /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */\n    const initUser = (user, userDescription) => {\n      /**\n       * @type {YArray<Uint8Array>}\n       */\n      const ds = user.get('ds');\n      const ids = user.get('ids');\n      const addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription);\n      ds.observe(/** @param {YArrayEvent<any>} event */ event => {\n        event.changes.added.forEach(item => {\n          item.content.getContent().forEach(encodedDs => {\n            if (encodedDs instanceof Uint8Array) {\n              this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs)))]));\n            }\n          });\n        });\n      });\n      this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs => readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs))))));\n      ids.observe(/** @param {YArrayEvent<any>} event */ event =>\n        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    // observe users\n    storeType.observe(event => {\n      event.keysChanged.forEach(userDescription =>\n        initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    // add initial data\n    storeType.forEach(initUser);\n  }\n\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} conf\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set('ids', new YArray());\n      user.set('ds', new YArray());\n      users.set(userDescription, user);\n    }\n    user.get('ids').push([clientid]);\n    users.observe(_event => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          // user was overwritten, port all data over to the next user object\n          // @todo Experiment with Y.Sets here\n          user = userOverwrite;\n          // @todo iterate over old type\n          this.clients.forEach((_userDescription, clientid) => {\n            if (userDescription === _userDescription) {\n              user.get('ids').push([clientid]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get('ds').push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      setTimeout(() => {\n        const yds = user.get('ds');\n        const ds = transaction.deleteSet;\n        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n          const encoder = new DSEncoderV1();\n          writeDeleteSet(encoder, ds);\n          yds.push([encoder.toUint8Array()]);\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId (clientid) {\n    return this.clients.get(clientid) || null\n  }\n\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId (id) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id)) {\n        return userDescription\n      }\n    }\n    return null\n  }\n}\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nclass RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type;\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname;\n    /**\n     * @type {ID | null}\n     */\n    this.item = item;\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the character\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */\nconst relativePositionToJSON = rpos => {\n  const json = {};\n  if (rpos.type) {\n    json.type = rpos.type;\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname;\n  }\n  if (rpos.item) {\n    json.item = rpos.item;\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc;\n  }\n  return json\n};\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\n\nclass AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n    /**\n     * @type {number}\n     */\n    this.index = index;\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nconst createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nconst createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n};\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        // case 1: found position somewhere in the linked list\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc)\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */\nconst writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos;\n  if (item !== null) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0);\n    writeID(encoder, item);\n  } else if (tname !== null) {\n    // case 2: found position at the end of the list and type is stored in y.share\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 1);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, tname);\n  } else if (type !== null) {\n    // case 3: found position at the end of the list and type is attached to an item\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 2);\n    writeID(encoder, type);\n  } else {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n  }\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarInt(encoder, assoc);\n  return encoder\n};\n\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */\nconst encodeRelativePosition = rpos => {\n  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n  writeRelativePosition(encoder, rpos);\n  return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n};\n\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */\nconst readRelativePosition = decoder => {\n  let type = null;\n  let tname = null;\n  let itemID = null;\n  switch (lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)) {\n    case 0:\n      // case 1: found position somewhere in the linked list\n      itemID = readID(decoder);\n      break\n    case 1:\n      // case 2: found position at the end of the list and type is stored in y.share\n      tname = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder);\n      break\n    case 2: {\n      // case 3: found position at the end of the list and type is attached to an item\n      type = readID(decoder);\n    }\n  }\n  const assoc = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.hasContent(decoder) ? lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarInt(decoder) : 0;\n  return new RelativePosition(type, tname, itemID, assoc)\n};\n\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */\nconst decodeRelativePosition = uint8Array => readRelativePosition(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(uint8Array));\n\n/**\n * @param {StructStore} store\n * @param {ID} id\n */\nconst getItemWithOffset = (store, id) => {\n  const item = getItem(store, id);\n  const diff = id.clock - item.id.clock;\n  return {\n    item, diff\n  }\n};\n\n/**\n * Transform a relative position to an absolute position.\n *\n * If you want to share the relative position with other users, you should set\n * `followUndoneDeletions` to false to get consistent results across all clients.\n *\n * When calculating the absolute position, we try to follow the \"undone deletions\". This yields\n * better results for the user who performed undo. However, only the user who performed the undo\n * will get the better results, the other users don't know which operations recreated a deleted\n * range of content. There is more information in this ticket: https://github.com/yjs/yjs/issues/638\n *\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @param {boolean} followUndoneDeletions - whether to follow undone deletions - see https://github.com/yjs/yjs/issues/638\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nconst createAbsolutePositionFromRelativePosition = (rpos, doc, followUndoneDeletions = true) => {\n  const store = doc.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent);\n    if (type._item === null || !type._item.deleted) {\n      index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)); // adjust position based on left association if necessary\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n};\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n);\n\nclass Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds;\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv;\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nconst equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nconst encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds);\n  writeStateVector(encoder, snapshot.sv);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nconst encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DSEncoderV1());\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nconst decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n};\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nconst decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)));\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nconst createSnapshot = (ds, sm) => new Snapshot(ds, sm);\n\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nconst snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nconst isVisible = (item, snapshot) => snapshot === undefined\n  ? !item.deleted\n  : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nconst splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create);\n  const store = transaction.doc.store;\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot.ds, _item => {});\n    meta.add(snapshot);\n  }\n};\n\n/**\n * @example\n *  const ydoc = new Y.Doc({ gc: false })\n *  ydoc.getText().insert(0, 'world!')\n *  const snapshot = Y.snapshot(ydoc)\n *  ydoc.getText().insert(0, 'hello ')\n *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)\n *  assert(restored.getText().toString() === 'world!')\n *\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nconst createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('Garbage-collection must be disabled in `originDoc`!')\n  }\n  const { sv, ds } = snapshot;\n\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact(transaction => {\n    let size = 0;\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, size);\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      // write # encoded structs\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      // first clock written is 0\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');\n  return newDoc\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n */\nconst snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2) => {\n  const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {\n      return false\n    }\n  }\n  const mergedDS = mergeDeleteSets([snapshot.ds, readDeleteSet(updateDecoder)]);\n  return equalDeleteSets(snapshot.ds, mergedDS)\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {Uint8Array} update\n */\nconst snapshotContainsUpdate = (snapshot, update) => snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);\n\nclass StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map();\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */\n    this.pendingStructs = null;\n    /**\n     * @type {null | Uint8Array}\n     */\n    this.pendingDs = null;\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nconst getStateVector = store => {\n  const sm = new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm\n};\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nconst getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length\n};\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nconst addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === undefined) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n    }\n  }\n  structs.push(struct);\n};\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nconst findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = lib0_math__WEBPACK_IMPORTED_MODULE_2__.floor((clock / (midclock + mid.length - 1)) * right); // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = lib0_math__WEBPACK_IMPORTED_MODULE_2__.floor((left + right) / 2);\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nconst find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  return structs[findIndexSS(structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nconst getItem = /** @type {function(StructStore,ID):Item} */ (find);\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nconst findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1\n  }\n  return index\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client));\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  const index = findIndexSS(structs, id.clock);\n  const struct = structs[index];\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n  }\n  return struct\n};\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nconst replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client));\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n};\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const ydoc = new Y.Doc()\n * const map = ydoc.getMap('map')\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * ydoc.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nclass Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet();\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store);\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map();\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}\n     */\n    this.changed = new Map();\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}\n     */\n    this.changedParentTypes = new Map();\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = [];\n    /**\n     * @type {any}\n     */\n    this.origin = origin;\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map();\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local;\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set();\n    /**\n     * @type {boolean}\n     */\n    this._needFormattingCleanup = false;\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nconst writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !lib0_map__WEBPACK_IMPORTED_MODULE_3__.any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true\n};\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent<any>>} type\n * @param {string|null} parentSub\n */\nconst addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.changed, type, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create).add(parentSub);\n  }\n};\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n * @return {number} # of merged structs\n */\nconst tryToMergeWithLefts = (structs, pos) => {\n  let right = structs[pos];\n  let left = structs[pos - 1];\n  let i = pos;\n  for (; i > 0; right = left, left = structs[--i - 1]) {\n    if (left.deleted === right.deleted && left.constructor === right.constructor) {\n      if (left.mergeWith(right)) {\n        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n          /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));\n        }\n        continue\n      }\n    }\n    break\n  }\n  const merged = pos - i;\n  if (merged) {\n    // remove all merged structs from the array\n    structs.splice(pos + 1 - merged, merged);\n  }\n  return merged\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiency and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = lib0_math__WEBPACK_IMPORTED_MODULE_2__.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[si]\n      ) {\n        si -= 1 + tryToMergeWithLefts(structs, si);\n      }\n    }\n  });\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc.emit('beforeObserverCalls', [transaction, doc]);\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = [];\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) => {\n          // We need to think about the possibility that the user transforms the\n          // Y.Doc in the event.\n          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {\n            events = events\n              .filter(event =>\n                event.target._item === null || !event.target._item.deleted\n              );\n            events\n              .forEach(event => {\n                event.currentTarget = type;\n                // path is relative to the current target\n                event._path = null;\n              });\n            // sort events by path length so that top-level events are fired first.\n            events\n              .sort((event1, event2) => event1.path.length - event2.path.length);\n            // We don't need to check for events.length\n            // because we know it has at least one element\n            callEventHandlerListeners(type._dEH, events, transaction);\n          }\n        });\n      });\n      fs.push(() => doc.emit('afterTransaction', [transaction, doc]));\n      (0,lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll)(fs, []);\n      if (transaction._needFormattingCleanup) {\n        cleanupYTextAfterTransaction(transaction);\n      }\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = lib0_math__WEBPACK_IMPORTED_MODULE_2__.max(findIndexSS(structs, beforeClock), 1);\n          for (let i = structs.length - 1; i >= firstChangePos;) {\n            i -= 1 + tryToMergeWithLefts(structs, i);\n          }\n        }\n      });\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = mergeStructs.length - 1; i >= 0; i--) {\n        const { client, clock } = mergeStructs[i].id;\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {\n            continue // no need to perform next check, both are already merged\n          }\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLefts(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(lib0_logging__WEBPACK_IMPORTED_MODULE_14__.ORANGE, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.BOLD, '[yjs] ', lib0_logging__WEBPACK_IMPORTED_MODULE_14__.UNBOLD, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.RED, 'Changed the client-id because another client seems to be using it.');\n        doc.clientID = generateNewClientId();\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc]);\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;\n      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {\n        subdocsAdded.forEach(subdoc => {\n          subdoc.clientID = doc.clientID;\n          if (subdoc.collectionid == null) {\n            subdoc.collectionid = doc.collectionid;\n          }\n          doc.subdocs.add(subdoc);\n        });\n        subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc));\n        doc.emit('subdocs', [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc, transaction]);\n        subdocsRemoved.forEach(subdoc => subdoc.destroy());\n      }\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = [];\n        doc.emit('afterAllTransactions', [doc, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @template T\n * @param {Doc} doc\n * @param {function(Transaction):T} f\n * @param {any} [origin=true]\n * @return {T}\n *\n * @function\n */\nconst transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups;\n  let initialCall = false;\n  /**\n   * @type {any}\n   */\n  let result = null;\n  if (doc._transaction === null) {\n    initialCall = true;\n    doc._transaction = new Transaction(doc, origin, local);\n    transactionCleanups.push(doc._transaction);\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc]);\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc]);\n  }\n  try {\n    result = f(doc._transaction);\n  } finally {\n    if (initialCall) {\n      const finishCleanup = doc._transaction === transactionCleanups[0];\n      doc._transaction = null;\n      if (finishCleanup) {\n        // The first transaction ended, now process observer calls.\n        // Observer call may create new transactions for which we need to call the observers and do cleanup.\n        // We don't want to nest these calls, so we execute these calls one after\n        // another.\n        // Also we need to ensure that all cleanups are called, even if the\n        // observes throw errors.\n        // This file is full of hacky try {} finally {} blocks to ensure that an\n        // event can throw errors and also that the cleanup is called.\n        cleanupTransactions(transactionCleanups, 0);\n      }\n    }\n  }\n  return result\n};\n\nclass StackItem {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor (deletions, insertions) {\n    this.insertions = insertions;\n    this.deletions = deletions;\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map();\n  }\n}\n/**\n * @param {Transaction} tr\n * @param {UndoManager} um\n * @param {StackItem} stackItem\n */\nconst clearUndoManagerStackItem = (tr, um, stackItem) => {\n  iterateDeletedStructs(tr, stackItem.deletions, item => {\n    if (item instanceof Item && um.scope.some(type => type === tr.doc || isParentOf(/** @type {AbstractType<any>} */ (type), item))) {\n      keepItem(item, false);\n    }\n  });\n};\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {'undo'|'redo'} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */\n  let _tr = null;\n  const doc = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc, transaction => {\n    while (stack.length > 0 && undoManager.currStackItem === null) {\n      const store = doc.store;\n      const stackItem = /** @type {StackItem} */ (stack.pop());\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set();\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = [];\n      let performedChange = false;\n      iterateDeletedStructs(transaction, stackItem.insertions, struct => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id);\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n            }\n            struct = item;\n          }\n          if (!struct.deleted && scope.some(type => type === transaction.doc || isParentOf(/** @type {AbstractType<any>} */ (type), /** @type {Item} */ (struct)))) {\n            itemsToDelete.push(struct);\n          }\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.deletions, struct => {\n        if (\n          struct instanceof Item &&\n          scope.some(type => type === transaction.doc || isParentOf(/** @type {AbstractType<any>} */ (type), struct)) &&\n          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !isDeleted(stackItem.insertions, struct.id)\n        ) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;\n      });\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      undoManager.currStackItem = performedChange ? stackItem : null;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n    _tr = transaction;\n  }, undoManager);\n  const res = undoManager.currStackItem;\n  if (res != null) {\n    const changedParentTypes = _tr.changedParentTypes;\n    undoManager.emit('stack-item-popped', [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);\n    undoManager.currStackItem = null;\n  }\n  return res\n};\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter what an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).\n * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.\n */\n\n/**\n * @typedef {Object} StackItemEvent\n * @property {StackItem} StackItemEvent.stackItem\n * @property {any} StackItemEvent.origin\n * @property {'undo'|'redo'} StackItemEvent.type\n * @property {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>} StackItemEvent.changedParentTypes\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {ObservableV2<{'stack-item-added':function(StackItemEvent, UndoManager):void, 'stack-item-popped': function(StackItemEvent, UndoManager):void, 'stack-cleared': function({ undoStackCleared: boolean, redoStackCleared: boolean }):void, 'stack-item-updated': function(StackItemEvent, UndoManager):void }>}\n */\nclass UndoManager extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.ObservableV2 {\n  /**\n   * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, {\n    captureTimeout = 500,\n    captureTransaction = _tr => true,\n    deleteFilter = () => true,\n    trackedOrigins = new Set([null]),\n    ignoreRemoteMapChanges = false,\n    doc = /** @type {Doc} */ (lib0_array__WEBPACK_IMPORTED_MODULE_1__.isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc)\n  } = {}) {\n    super();\n    /**\n     * @type {Array<AbstractType<any> | Doc>}\n     */\n    this.scope = [];\n    this.doc = doc;\n    this.addToScope(typeScope);\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    this.captureTransaction = captureTransaction;\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = [];\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = [];\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false;\n    this.redoing = false;\n    /**\n     * The currently popped stack item if UndoManager.undoing or UndoManager.redoing\n     *\n     * @type {StackItem|null}\n     */\n    this.currStackItem = null;\n    this.lastChange = 0;\n    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;\n    this.captureTimeout = captureTimeout;\n    /**\n     * @param {Transaction} transaction\n     */\n    this.afterTransactionHandler = transaction => {\n      // Only track certain transactions\n      if (\n        !this.captureTransaction(transaction) ||\n        !this.scope.some(type => transaction.changedParentTypes.has(/** @type {AbstractType<any>} */ (type)) || type === this.doc) ||\n        (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))\n      ) {\n        return\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing(); // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.clear(false, true);\n      }\n      const insertions = new DeleteSet();\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len);\n        }\n      });\n      const now = lib0_time__WEBPACK_IMPORTED_MODULE_15__.getUnixTime();\n      let didAdd = false;\n      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1];\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, insertions));\n        didAdd = true;\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      // make sure that deleted structs are not gc'd\n      iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => type === transaction.doc || isParentOf(/** @type {AbstractType<any>} */ (type), item))) {\n          keepItem(item, true);\n        }\n      });\n      /**\n       * @type {[StackItemEvent, UndoManager]}\n       */\n      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this];\n      if (didAdd) {\n        this.emit('stack-item-added', changeEvent);\n      } else {\n        this.emit('stack-item-updated', changeEvent);\n      }\n    };\n    this.doc.on('afterTransaction', this.afterTransactionHandler);\n    this.doc.on('destroy', () => {\n      this.destroy();\n    });\n  }\n\n  /**\n   * Extend the scope.\n   *\n   * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes\n   */\n  addToScope (ytypes) {\n    const tmpSet = new Set(this.scope);\n    ytypes = lib0_array__WEBPACK_IMPORTED_MODULE_1__.isArray(ytypes) ? ytypes : [ytypes];\n    ytypes.forEach(ytype => {\n      if (!tmpSet.has(ytype)) {\n        tmpSet.add(ytype);\n        if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) lib0_logging__WEBPACK_IMPORTED_MODULE_13__.warn('[yjs#509] Not same Y.Doc'); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509\n        this.scope.push(ytype);\n      }\n    });\n  }\n\n  /**\n   * @param {any} origin\n   */\n  addTrackedOrigin (origin) {\n    this.trackedOrigins.add(origin);\n  }\n\n  /**\n   * @param {any} origin\n   */\n  removeTrackedOrigin (origin) {\n    this.trackedOrigins.delete(origin);\n  }\n\n  clear (clearUndoStack = true, clearRedoStack = true) {\n    if ((clearUndoStack && this.canUndo()) || (clearRedoStack && this.canRedo())) {\n      this.doc.transact(tr => {\n        if (clearUndoStack) {\n          this.undoStack.forEach(item => clearUndoManagerStackItem(tr, this, item));\n          this.undoStack = [];\n        }\n        if (clearRedoStack) {\n          this.redoStack.forEach(item => clearUndoManagerStackItem(tr, this, item));\n          this.redoStack = [];\n        }\n        this.emit('stack-cleared', [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);\n      });\n    }\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0;\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, 'undo');\n    } finally {\n      this.undoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, 'redo');\n    } finally {\n      this.redoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Are undo steps available?\n   *\n   * @return {boolean} `true` if undo is possible\n   */\n  canUndo () {\n    return this.undoStack.length > 0\n  }\n\n  /**\n   * Are redo steps available?\n   *\n   * @return {boolean} `true` if redo is possible\n   */\n  canRedo () {\n    return this.redoStack.length > 0\n  }\n\n  destroy () {\n    this.trackedOrigins.delete(this);\n    this.doc.off('afterTransaction', this.afterTransactionHandler);\n    super.destroy();\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const client = decoder.readClient();\n    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        yield new Skip(createID(client, clock), len);\n        clock += len;\n      } else if ((lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        );\n        yield struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        yield new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n  }\n}\n\nclass LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder);\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null;\n    this.done = false;\n    this.filterSkips = filterSkips;\n    this.next();\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null;\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nconst logUpdate = update => logUpdateV2(update, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nconst logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print('Structs: ', structs);\n  const ds = readDeleteSet(updateDecoder);\n  lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print('DeleteSet: ', ds);\n};\n\n/**\n * @param {Uint8Array} update\n *\n */\nconst decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nconst decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  return {\n    structs,\n    ds: readDeleteSet(updateDecoder)\n  }\n};\n\nclass LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0;\n    this.startClock = 0;\n    this.written = 0;\n    this.encoder = encoder;\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = [];\n  }\n}\n\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */\nconst mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder();\n  const updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let size = 0;\n    let currClient = curr.id.client;\n    let stopCounting = curr.id.clock !== 0; // must start at 0\n    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        if (currClock !== 0) {\n          size++;\n          // We found a new client\n          // write what we have to the encoder\n          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);\n          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);\n        }\n        currClient = curr.id.client;\n        currClock = 0;\n        stopCounting = curr.id.clock !== 0;\n      }\n      // we ignore skips\n      if (curr.constructor === Skip) {\n        stopCounting = true;\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length;\n      }\n    }\n    // write what we have\n    if (currClock !== 0) {\n      size++;\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);\n    }\n    // prepend the size of the state vector\n    const enc = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(enc, size);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeBinaryEncoder(enc, encoder.restEncoder);\n    encoder.restEncoder = enc;\n    return encoder.toUint8Array()\n  } else {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);\n    return encoder.toUint8Array()\n  }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  /**\n   * @type {Map<number, number>}\n   */\n  const from = new Map();\n  /**\n   * @type {Map<number, number>}\n   */\n  const to = new Map();\n  const updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    // write the beginning to `from`\n    from.set(currClient, currClock);\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        // We found a new client\n        // write the end to `to`\n        to.set(currClient, currClock);\n        // write the beginning to `from`\n        from.set(curr.id.client, curr.id.clock);\n        // update currClient\n        currClient = curr.id.client;\n      }\n      currClock = curr.id.clock + curr.length;\n    }\n    // write the end to `to`\n    to.set(currClient, currClock);\n  }\n  return { from, to }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMeta = update => parseUpdateMetaV2(update, UpdateDecoderV1);\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id;\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id;\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left);\n    const { client, clock } = leftItem.id;\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n};\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */\nconst mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  if (updates.length === 1) {\n    return updates[0]\n  }\n  const updateDecoders = updates.map(update => new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)));\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true));\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null;\n\n  const updateEncoder = new YEncoder();\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first  sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null);\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n          if (clockDiff === 0) {\n            // @todo remove references to skip since the structDecoders must filter Skips.\n            return dec1.curr.constructor === dec2.curr.constructor\n              ? 0\n              : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    );\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0];\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr);\n      let iterated = false;\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next();\n        iterated = true;\n      }\n      if (\n        curr === null || // current decoder is empty\n        curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n        (iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) // the above while loop was used and we are potentially missing updates\n      ) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: curr, offset: 0 };\n        currDecoder.next();\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n            currWrite = { struct, offset: 0 };\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff;\n            } else {\n              curr = sliceStruct(curr, diff);\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = { struct: curr, offset: 0 };\n            currDecoder.next();\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 };\n      currDecoder.next();\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = { struct: next, offset: 0 };\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n    currWrite = null;\n  }\n  finishLazyStructWriting(lazyStructEncoder);\n\n  const dss = updateDecoders.map(decoder => readDeleteSet(decoder));\n  const ds = mergeDeleteSets(dss);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nconst diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv);\n  const encoder = new YEncoder();\n  const lazyStructWriter = new LazyStructWriter(encoder);\n  const decoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const reader = new LazyStructReader(decoder, false);\n  while (reader.curr) {\n    const curr = reader.curr;\n    const currClient = curr.id.client;\n    const svClock = state.get(currClient) || 0;\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next();\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, lib0_math__WEBPACK_IMPORTED_MODULE_2__.max(svClock - curr.id.clock, 0));\n      reader.next();\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n        reader.next();\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next();\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter);\n  // write ds\n  const ds = readDeleteSet(decoder);\n  writeDeleteSet(encoder, ds);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nconst diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(lazyWriter.encoder.restEncoder) });\n    lazyWriter.encoder.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    lazyWriter.written = 0;\n  }\n};\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter);\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client;\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client);\n    // write startClock\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n  }\n  struct.write(lazyWriter.encoder, offset);\n  lazyWriter.written++;\n};\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter);\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder;\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i];\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, partStructs.written);\n    // write the rest of the fragment\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(restEncoder, partStructs.restEncoder);\n  }\n};\n\n/**\n * @param {Uint8Array} update\n * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder\n * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder\n */\nconst convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {\n  const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  const updateEncoder = new YEncoder();\n  const lazyWriter = new LazyStructWriter(updateEncoder);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);\n  }\n  finishLazyStructWriting(lazyWriter);\n  const ds = readDeleteSet(updateDecoder);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array()\n};\n\n/**\n * @typedef {Object} ObfuscatorOptions\n * @property {boolean} [ObfuscatorOptions.formatting=true]\n * @property {boolean} [ObfuscatorOptions.subdocs=true]\n * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName\n */\n\n/**\n * @param {ObfuscatorOptions} obfuscator\n */\nconst createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {\n  let i = 0;\n  const mapKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  const nodeNameCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  const formattingKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  const formattingValueCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range\n  /**\n   * @param {Item|GC|Skip} block\n   * @return {Item|GC|Skip}\n   */\n  return block => {\n    switch (block.constructor) {\n      case GC:\n      case Skip:\n        return block\n      case Item: {\n        const item = /** @type {Item} */ (block);\n        const content = item.content;\n        switch (content.constructor) {\n          case ContentDeleted:\n            break\n          case ContentType: {\n            if (yxml) {\n              const type = /** @type {ContentType} */ (content).type;\n              if (type instanceof YXmlElement) {\n                type.nodeName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.nodeName, () => 'node-' + i);\n              }\n              if (type instanceof YXmlHook) {\n                type.hookName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.hookName, () => 'hook-' + i);\n              }\n            }\n            break\n          }\n          case ContentAny: {\n            const c = /** @type {ContentAny} */ (content);\n            c.arr = c.arr.map(() => i);\n            break\n          }\n          case ContentBinary: {\n            const c = /** @type {ContentBinary} */ (content);\n            c.content = new Uint8Array([i]);\n            break\n          }\n          case ContentDoc: {\n            const c = /** @type {ContentDoc} */ (content);\n            if (subdocs) {\n              c.opts = {};\n              c.doc.guid = i + '';\n            }\n            break\n          }\n          case ContentEmbed: {\n            const c = /** @type {ContentEmbed} */ (content);\n            c.embed = {};\n            break\n          }\n          case ContentFormat: {\n            const c = /** @type {ContentFormat} */ (content);\n            if (formatting) {\n              c.key = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingKeyCache, c.key, () => i + '');\n              c.value = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingValueCache, c.value, () => ({ i }));\n            }\n            break\n          }\n          case ContentJSON: {\n            const c = /** @type {ContentJSON} */ (content);\n            c.arr = c.arr.map(() => i);\n            break\n          }\n          case ContentString: {\n            const c = /** @type {ContentString} */ (content);\n            c.str = lib0_string__WEBPACK_IMPORTED_MODULE_16__.repeat((i % 10) + '', c.str.length);\n            break\n          }\n          default:\n            // unknown content type\n            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        if (item.parentSub) {\n          item.parentSub = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(mapKeyCache, item.parentSub, () => i + '');\n        }\n        i++;\n        return block\n      }\n      default:\n        // unknown block-type\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n  }\n};\n\n/**\n * This function obfuscates the content of a Yjs update. This is useful to share\n * buggy Yjs documents while significantly limiting the possibility that a\n * developer can on the user. Note that it might still be possible to deduce\n * some information by analyzing the \"structure\" of the document or by analyzing\n * the typing behavior using the CRDT-related metadata that is still kept fully\n * intact.\n *\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */\nconst obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */\nconst obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);\n\n/**\n * @param {Uint8Array} update\n */\nconst convertUpdateFormatV1ToV2 = update => convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV1, UpdateEncoderV2);\n\n/**\n * @param {Uint8Array} update\n */\nconst convertUpdateFormatV2ToV1 = update => convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV2, UpdateEncoderV1);\n\nconst errorComputeChanges = 'You must not compute changes after the event-handler fired.';\n\n/**\n * @template {AbstractType<any>} T\n * YEvent describes the changes on a YType.\n */\nclass YEvent {\n  /**\n   * @param {T} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {T}\n     */\n    this.target = target;\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target;\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction;\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null;\n    /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any }>}\n     */\n    this._keys = null;\n    /**\n     * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */\n    this._delta = null;\n    /**\n     * @type {Array<string|number>|null}\n     */\n    this._path = null;\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    return this._path || (this._path = getPathTo(this.currentTarget, this.target))\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any }>}\n   */\n  get keys () {\n    if (this._keys === null) {\n      if (this.transaction.doc._transactionCleanups.length === 0) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(errorComputeChanges)\n      }\n      const keys = new Map();\n      const target = this.target;\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key));\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete';\n                oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_1__.last(prev.content.getContent());\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update';\n                oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_1__.last(prev.content.getContent());\n              } else {\n                action = 'add';\n                oldValue = undefined;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete';\n              oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_1__.last(/** @type {Item} */ item.content.getContent());\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue });\n        }\n      });\n      this._keys = keys;\n    }\n    return this._keys\n  }\n\n  /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta () {\n    return this.changes.delta\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    let changes = this._changes;\n    if (changes === null) {\n      if (this.transaction.doc._transactionCleanups.length === 0) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(errorComputeChanges)\n      }\n      const target = this.target;\n      const added = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();\n      const deleted = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = [];\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      };\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp();\n        }\n      }\n      this._changes = changes;\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub);\n    } else {\n      // parent is array-ish\n      let i = 0;\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start;\n      while (c !== child._item && c !== null) {\n        if (!c.deleted && c.countable) {\n          i += c.length;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent);\n  }\n  return path\n};\n\n/**\n * https://docs.yjs.dev/getting-started/working-with-shared-types#caveats\n */\nconst warnPrematureAccess = () => { lib0_logging__WEBPACK_IMPORTED_MODULE_13__.warn('Invalid access: Add Yjs type to a document before reading data.'); };\n\nconst maxSearchMarker = 80;\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0;\n\nclass ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++; };\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm\n  }\n};\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nconst findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => lib0_math__WEBPACK_IMPORTED_MODULE_2__.abs(index - a.index) < lib0_math__WEBPACK_IMPORTED_MODULE_2__.abs(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengths == null) {\n  //     window.lengths = []\n  //     window.getLengths = () => window.lengths.sort((a, b) => a - b)\n  //   }\n  //   window.lengths.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && lib0_math__WEBPACK_IMPORTED_MODULE_2__.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex);\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n};\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nconst updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p;\n      p.marker = false;\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1);\n        continue\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = lib0_math__WEBPACK_IMPORTED_MODULE_2__.max(index, m.index + len);\n    }\n  }\n};\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nconst getTypeChildren = t => {\n  t.doc ?? warnPrematureAccess();\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr\n};\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nconst callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    // @ts-ignore\n    lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent);\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nclass AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null;\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map();\n    /**\n     * @type {Item|null}\n     */\n    this._start = null;\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null;\n    this._length = 0;\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler();\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent<any>>,Transaction>}\n     */\n    this._dEH = createEventHandler();\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null;\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n   */\n  _write (_encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, _parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListSlice = (type, start, end) => {\n  type.doc ?? warnPrematureAccess();\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArray = type => {\n  type.doc ?? warnPrematureAccess();\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArraySnapshot = (type, snapshot) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * Executes a provided function on once on every element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nconst typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  type.doc ?? warnPrematureAccess();\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nconst typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nconst typeListCreateIterator = type => {\n  let n = type._start;\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right; // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++];\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nconst typeListGet = (type, index) => {\n  type.doc ?? warnPrematureAccess();\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length;\n    }\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const store = doc.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  /**\n   * @type {Array<Object|Array<any>|number|null>}\n   */\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach(c => {\n    if (c === null) {\n      jsonContent.push(c);\n    } else {\n      switch (c.constructor) {\n        case Number:\n        case Object:\n        case Boolean:\n        case Array:\n        case String:\n          jsonContent.push(c);\n          break\n        default:\n          packJsonContent();\n          switch (c.constructor) {\n            case Uint8Array:\n            case ArrayBuffer:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));\n              left.integrate(transaction, 0);\n              break\n            case Doc:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));\n              left.integrate(transaction, 0);\n              break\n            default:\n              if (c instanceof AbstractType) {\n                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n                left.integrate(transaction, 0);\n              } else {\n                throw new Error('Unexpected content type in insert operation')\n              }\n          }\n      }\n    }\n  });\n  packJsonContent();\n};\n\nconst lengthExceeded = () => lib0_error__WEBPACK_IMPORTED_MODULE_9__.create('Length exceeded!');\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index > parent._length) {\n    throw lengthExceeded()\n  }\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * Pushing content is special as we generally want to push after the last item. So we don't have to update\n * the search marker.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListPushGenerics = (transaction, parent, content) => {\n  // Use the marker with the highest index and iterate to the right.\n  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });\n  let n = marker.p;\n  if (n) {\n    while (n.right) {\n      n = n.right;\n    }\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nconst typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index;\n  const startLength = length;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n      }\n      n.delete(transaction);\n      length -= n.length;\n    }\n    n = n.right;\n  }\n  if (length > 0) {\n    throw lengthExceeded()\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nconst typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== undefined) {\n    c.delete(transaction);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nconst typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n      case Date:\n      case BigInt:\n        content = new ContentAny([value]);\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value));\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value));\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGet = (parent, key) => {\n  parent.doc ?? warnPrematureAccess();\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nconst typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {};\n  parent.doc ?? warnPrematureAccess();\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst typeMapHas = (parent, key) => {\n  parent.doc ?? warnPrematureAccess();\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {Snapshot} snapshot\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nconst typeMapGetAllSnapshot = (parent, snapshot) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {};\n  parent._map.forEach((value, key) => {\n    /**\n     * @type {Item|null}\n     */\n    let v = value;\n    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n      v = v.left;\n    }\n    if (v !== null && isVisible(v, snapshot)) {\n      res[key] = v.content.getContent()[v.length - 1];\n    }\n  });\n  return res\n};\n\n/**\n * @param {AbstractType<any> & { _map: Map<string, Item> }} type\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nconst createMapIterator = type => {\n  type.doc ?? warnPrematureAccess();\n  return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorFilter(type._map.entries(), /** @param {any} entry */ entry => !entry[1].deleted)\n};\n\n/**\n * @module YArray\n */\n\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n * @extends YEvent<YArray<T>>\n */\nclass YArrayEvent extends YEvent {}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YArray extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    /**\n     * @type {YArray<T>}\n     */\n    const a = new YArray();\n    a.push(items);\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YArray<T>}\n   */\n  clone () {\n    /**\n     * @type {YArray<T>}\n     */\n    const arr = new YArray();\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? /** @type {typeof el} */ (el.clone()) : el\n    ));\n    return arr\n  }\n\n  get length () {\n    this.doc ?? warnPrematureAccess();\n    return this._length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, /** @type {any} */ (content));\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   *\n   * @todo Use the following implementation in all types.\n   */\n  push (content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListPushGenerics(transaction, this, /** @type {any} */ (content));\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).push(...content);\n    }\n  }\n\n  /**\n   * Prepends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to prepend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length);\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Returns a portion of this YArray into a JavaScript Array selected\n   * from start to end (end not included).\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function once on every element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n *\n * @private\n * @function\n */\nconst readYArray = _decoder => new YArray();\n\n/**\n * @module YMap\n */\n\n\n/**\n * @template T\n * @extends YEvent<YMap<T>>\n * Event that describes the changes on a YMap.\n */\nclass YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n}\n\n/**\n * @template MapType\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<MapType>>\n * @implements {Iterable<[string, MapType]>}\n */\nclass YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super();\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null;\n\n    if (entries === undefined) {\n      this._prelimContent = new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n\n  /**\n   * @return {YMap<MapType>}\n   */\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YMap<MapType>}\n   */\n  clone () {\n    /**\n     * @type {YMap<MapType>}\n     */\n    const map = new YMap();\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ (value.clone()) : value);\n    });\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,any>}\n   */\n  toJSON () {\n    this.doc ?? warnPrematureAccess();\n    /**\n     * @type {Object<string,MapType>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<MapType>}\n   */\n  values () {\n    return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<[string, MapType]>}\n   */\n  entries () {\n    return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this), /** @param {any} v */ v => /** @type {any} */ ([v[0], v[1].content.getContent()[v[1].length - 1]]))\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    this.doc ?? warnPrematureAccess();\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<[string, MapType]>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key);\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   * @template {MapType} VAL\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {VAL} value The value of the element to add\n   * @return {VAL}\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, /** @type {any} */ (value));\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value);\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {MapType|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * Removes all elements from this YMap.\n   */\n  clear () {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        this.forEach(function (_value, key, map) {\n          typeMapDelete(transaction, map, key);\n        });\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).clear();\n    }\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n *\n * @private\n * @function\n */\nconst readYMap = _decoder => new YMap();\n\n/**\n * @module YText\n */\n\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && lib0_object__WEBPACK_IMPORTED_MODULE_18__.equalFlat(a, b));\n\nclass ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n    switch (this.right.content.constructor) {\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));\n        }\n        break\n      default:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));\n        }\n        break\n      default:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {boolean} useSearchMarker\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index, useSearchMarker) => {\n  const currentAttributes = new Map();\n  const marker = useSearchMarker ? findMarker(parent, index) : null;\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index)\n  }\n};\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);\n    }\n    currPos.forward();\n  }\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  negatedAttributes.forEach((val, key) => {\n    const left = currPos.left;\n    const right = currPos.right;\n    const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    nextFormat.integrate(transaction, 0);\n    currPos.right = nextFormat;\n    currPos.forward();\n  });\n};\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] ?? null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {\n      break\n    }\n    currPos.forward();\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const negatedAttributes = new Map();\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) ?? null;\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object|AbstractType<any>} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((_val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null;\n    }\n  });\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : (text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text));\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there\n  // eslint-disable-next-line no-labels\n  iterationLoop: while (\n    currPos.right !== null &&\n    (length > 0 ||\n      (\n        negatedAttributes.size > 0 &&\n        (currPos.right.deleted || currPos.right.content.constructor === ContentFormat)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content);\n          const attr = attributes[key];\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key);\n            } else {\n              if (length === 0) {\n                // no need to further extend negatedAttributes\n                // eslint-disable-next-line no-labels\n                break iterationLoop\n              }\n              negatedAttributes.set(key, value);\n            }\n            currPos.right.delete(transaction);\n          } else {\n            currPos.currentAttributes.set(key, value);\n          }\n          break\n        }\n        default:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          break\n      }\n    }\n    currPos.forward();\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = '';\n    for (; length > 0; length--) {\n      newlines += '\\n';\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} currAttributes\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {\n  /**\n   * @type {Item|null}\n   */\n  let end = start;\n  /**\n   * @type {Map<string,ContentFormat>}\n   */\n  const endFormats = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  while (end && (!end.countable || end.deleted)) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      const cf = /** @type {ContentFormat} */ (end.content);\n      endFormats.set(cf.key, cf);\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  let reachedCurr = false;\n  while (start !== end) {\n    if (curr === start) {\n      reachedCurr = true;\n    }\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content);\n          const startAttrValue = startAttributes.get(key) ?? null;\n          if (endFormats.get(key) !== content || startAttrValue === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction);\n            cleanups++;\n            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {\n              if (startAttrValue === null) {\n                currAttributes.delete(key);\n              } else {\n                currAttributes.set(key, startAttrValue);\n              }\n            }\n          }\n          if (!reachedCurr && !start.deleted) {\n            updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ (content));\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right);\n  }\n  return cleanups\n};\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || !item.right.countable)) {\n    item = item.right;\n  }\n  const attrs = new Set();\n  // iterate back until a content item is found\n  while (item && (item.deleted || !item.countable)) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key;\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nconst cleanupYTextFormatting = type => {\n  let res = 0;\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start);\n    let end = type._start;\n    let startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const currentAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(startAttributes);\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));\n            break\n          default:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n            startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currentAttributes);\n            start = end;\n            break\n        }\n      }\n      end = end.right;\n    }\n  });\n  return res\n};\n\n/**\n * This will be called by the transaction once the event handlers are called to potentially cleanup\n * formatting attributes.\n *\n * @param {Transaction} transaction\n */\nconst cleanupYTextAfterTransaction = transaction => {\n  /**\n   * @type {Set<YText>}\n   */\n  const needFullCleanup = new Set();\n  // check if another formatting item was inserted\n  const doc = transaction.doc;\n  for (const [client, afterClock] of transaction.afterState.entries()) {\n    const clock = transaction.beforeState.get(client) || 0;\n    if (afterClock === clock) {\n      continue\n    }\n    iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n      if (\n        !item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat && item.constructor !== GC\n      ) {\n        needFullCleanup.add(/** @type {any} */ (item).parent);\n      }\n    });\n  }\n  // cleanup in a new transaction\n  transact(doc, (t) => {\n    iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n      if (item instanceof GC || !(/** @type {YText} */ (item.parent)._hasFormatting) || needFullCleanup.has(/** @type {YText} */ (item.parent))) {\n        return\n      }\n      const parent = /** @type {YText} */ (item.parent);\n      if (item.content.constructor === ContentFormat) {\n        needFullCleanup.add(parent);\n      } else {\n        // If no formatting attribute was inserted or deleted, we can make due with contextless\n        // formatting cleanups.\n        // Contextless: it is not necessary to compute currentAttributes for the affected position.\n        cleanupContextlessFormattingGap(t, item);\n      }\n    });\n    // If a formatting item was inserted, we simply clean the whole type.\n    // We need to compute currentAttributes for the current position anyway.\n    for (const yText of needFullCleanup) {\n      cleanupYTextFormatting(yText);\n    }\n  });\n};\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length;\n  const startAttrs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentType:\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n  }\n  return currPos\n};\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For more information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * @extends YEvent<YText>\n * Event that describes the changes on a YText type.\n */\nclass YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    if (this._changes === null) {\n      /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}\n       */\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: new Set(),\n        deleted: new Set()\n      };\n      this._changes = changes;\n    }\n    return /** @type {any} */ (this._changes)\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc);\n      /**\n       * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */\n      const delta = [];\n      transact(y, transaction => {\n        const currentAttributes = new Map(); // saves all current attributes for insert\n        const oldAttributes = new Map();\n        let item = this.target._start;\n        /**\n         * @type {string?}\n         */\n        let action = null;\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}; // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = '';\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op = null;\n            switch (action) {\n              case 'delete':\n                if (deleteLen > 0) {\n                  op = { delete: deleteLen };\n                }\n                deleteLen = 0;\n                break\n              case 'insert':\n                if (typeof insert === 'object' || insert.length > 0) {\n                  op = { insert };\n                  if (currentAttributes.size > 0) {\n                    op.attributes = {};\n                    currentAttributes.forEach((value, key) => {\n                      if (value !== null) {\n                        op.attributes[key] = value;\n                      }\n                    });\n                  }\n                }\n                insert = '';\n                break\n              case 'retain':\n                if (retain > 0) {\n                  op = { retain };\n                  if (!lib0_object__WEBPACK_IMPORTED_MODULE_18__.isEmpty(attributes)) {\n                    op.attributes = lib0_object__WEBPACK_IMPORTED_MODULE_18__.assign({}, attributes);\n                  }\n                }\n                retain = 0;\n                break\n            }\n            if (op) delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentType:\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = 'insert';\n                  insert = item.content.getContent()[0];\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += 1;\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp();\n                    action = 'insert';\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += item.length;\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content);\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) ?? null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) ?? null))) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else if (value !== null) {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) ?? null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (value === null) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else if (attr !== null) { // this will be cleaned up automatically by the contextless cleanup function\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp();\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content));\n              }\n              break\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop();\n          } else {\n            break\n          }\n        }\n      });\n      this._delta = delta;\n    }\n    return /** @type {any} */ (this._delta)\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nclass YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super();\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];\n    /**\n     * @type {Array<ArraySearchMarker>|null}\n     */\n    this._searchMarker = [];\n    /**\n     * Whether this YText contains formatting attributes.\n     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)\n     */\n    this._hasFormatting = false;\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    this.doc ?? warnPrematureAccess();\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    callTypeObservers(this, transaction, event);\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local && this._hasFormatting) {\n      transaction._needFormattingCleanup = true;\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    this.doc ?? warnPrematureAccess();\n    let str = '';\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str;\n      }\n      n = n.right;\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {Array<any>} delta The changes to apply on this element.\n   * @param {object}  opts\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta));\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    this.doc ?? warnPrematureAccess();\n    /**\n     * @type{Array<any>}\n     */\n    const ops = [];\n    const currentAttributes = new Map();\n    const doc = /** @type {Doc} */ (this.doc);\n    let str = '';\n    let n = this._start;\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = '';\n      }\n    }\n    const computeDelta = () => {\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange');\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.type !== 'removed') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' });\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.type !== 'added') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' });\n                }\n              } else if (cur !== undefined) {\n                packStr();\n                currentAttributes.delete('ychange');\n              }\n              str += /** @type {ContentString} */ (n.content).str;\n              break\n            }\n            case ContentType:\n            case ContentEmbed: {\n              packStr();\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: n.content.getContent()[0]\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({});\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr();\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content));\n              }\n              break\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    };\n    if (snapshot || prevSnapshot) {\n      // snapshots are merged again after the transaction, so we need to keep the\n      // transaction alive until we are done\n      transact(doc, transaction => {\n        if (snapshot) {\n          splitSnapshotAffectedStructs(transaction, snapshot);\n        }\n        if (prevSnapshot) {\n          splitSnapshotAffectedStructs(transaction, prevSnapshot);\n        }\n        computeDelta();\n      }, 'cleanup');\n    } else {\n      computeDelta();\n    }\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index, !attributes);\n        if (!attributes) {\n          attributes = {};\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v; });\n        }\n        insertText(transaction, this, pos, text, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes));\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object | AbstractType<any>} embed The Object that represents the embed.\n   * @param {TextAttributes} [attributes] Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes) {\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index, !attributes);\n        insertText(transaction, this, pos, embed, attributes || {});\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes || {}));\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index, true), length);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length));\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index, false);\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes));\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName));\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes () {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nconst readYText = _decoder => new YText();\n\n/**\n * @module YXml\n */\n\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nclass YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start);\n    this._firstCall = true;\n    root.doc ?? warnPrematureAccess();\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode;\n    let type = n && n.content && /** @type {any} */ (n.content).type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start;\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            /**\n             * @type {Item | null}\n             */\n            const nxt = n.next;\n            if (nxt !== null) {\n              n = nxt;\n              break\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false;\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n;\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nclass YXmlFragment extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = [];\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment();\n    // @ts-ignore\n    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  get length () {\n    this.doc ?? warnPrematureAccess();\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    return lib0_array__WEBPACK_IMPORTED_MODULE_1__.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent);\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create('Reference item not found')\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length);\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Prepends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Returns a portion of this YXmlFragment into a JavaScript Array selected\n   * from start to end (end not included).\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Executes a provided function on once on every child element.\n   *\n   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nconst readYXmlFragment = _decoder => new YXmlFragment();\n\n/**\n * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes\n */\n\n/**\n * An YXmlElement imitates the behavior of a\n * https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n *\n * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]\n */\nclass YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super();\n    this.nodeName = nodeName;\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map();\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YXmlElement<KV>}\n   */\n  clone () {\n    /**\n     * @type {YXmlElement<KV>}\n     */\n    const el = new YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    lib0_object__WEBPACK_IMPORTED_MODULE_18__.forEach(attrs, (value, key) => {\n      el.setAttribute(key, /** @type {any} */ (value));\n    });\n    // @ts-ignore\n    el.insert(0, this.toArray().map(v => v instanceof AbstractType ? v.clone() : v));\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys = [];\n    for (const key in attrs) {\n      keys.push(key);\n    }\n    keys.sort();\n    const keysLen = keys.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {string} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName);\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that is to be set.\n   * @param {KV[KEY]} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue);\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {KV[KEY]|undefined} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns whether an attribute exists\n   *\n   * @param {string} attributeName The attribute name to check for existence.\n   * @return {boolean} whether the attribute exists.\n   *\n   * @public\n   */\n  hasAttribute (attributeName) {\n    return /** @type {any} */ (typeMapHas(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return /** @type {any} */ (snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this))\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      const value = attrs[key];\n      if (typeof value === 'string') {\n        dom.setAttribute(key, value);\n      }\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nconst readYXmlElement = decoder => new YXmlElement(decoder.readKey());\n\n/**\n * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nclass YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with which the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n}\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nclass YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super();\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== undefined) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName);\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nconst readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey());\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nclass YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      // now convert to dom string\n      let str = '';\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += '>';\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nconst readYXmlText = decoder => new YXmlText();\n\nclass AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id;\n    this.length = length;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} whether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n}\n\nconst structGCRefNumber = 0;\n\n/**\n * @private\n */\nclass GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nclass ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nconst readContentBinary = decoder => new ContentBinary(decoder.readBuf());\n\nclass ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nconst readContentDeleted = decoder => new ContentDeleted(decoder.readLen());\n\n/**\n * @param {string} guid\n * @param {Object<string, any>} opts\n */\nconst createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });\n\n/**\n * @private\n */\nclass ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * @type {any}\n     */\n    const opts = {};\n    this.opts = opts;\n    if (!doc.gc) {\n      opts.gc = false;\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta;\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts))\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nconst readContentDoc = decoder => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));\n\n/**\n * @private\n */\nclass ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nconst readContentEmbed = decoder => new ContentEmbed(decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} _offset\n   * @return {ContentFormat}\n   */\n  splice (_offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentFormat} _right\n   * @return {boolean}\n   */\n  mergeWith (_right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} _transaction\n   * @param {Item} item\n   */\n  integrate (_transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    const p = /** @type {YText} */ (item.parent);\n    p._searchMarker = null;\n    p._hasFormatting = true;\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nconst readContentFormat = decoder => new ContentFormat(decoder.readKey(), decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nconst readContentJSON = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === 'undefined') {\n      cs.push(undefined);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs)\n};\n\nconst isDevMode = lib0_environment__WEBPACK_IMPORTED_MODULE_19__.getVariable('node_env') === 'development';\n\nclass ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n    isDevMode && lib0_object__WEBPACK_IMPORTED_MODULE_18__.deepFreeze(arr);\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nconst readContentAny = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs)\n};\n\n/**\n * @private\n */\nclass ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character ( / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + '';\n      // replace right as well\n      right.str = '' + right.str.slice(1);\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nconst readContentString = decoder => new ContentString(decoder.readString());\n\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */\nconst typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\n\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n\n/**\n * @private\n */\nclass ContentType {\n  /**\n   * @param {AbstractType<any>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n        // This will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n        // same as above\n        transaction._mergeStructs.push(item);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true);\n        item = item.left;\n      }\n    });\n    this.type._map = new Map();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nconst readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nconst followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n};\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nconst keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */ (item.parent)._item;\n  }\n};\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nconst splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem;\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem);\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem\n};\n\n/**\n * @param {Array<StackItem>} stack\n * @param {ID} id\n */\nconst isDeletedByUndoStack = (stack, id) => lib0_array__WEBPACK_IMPORTED_MODULE_1__.some(stack, /** @param {StackItem} s */ s => isDeleted(s.deletions, id));\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n * @param {DeleteSet} itemsToDelete\n * @param {boolean} ignoreRemoteMapChanges\n * @param {import('../utils/UndoManager.js').UndoManager} um\n *\n * @return {Item|null}\n *\n * @private\n */\nconst redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {\n  const doc = transaction.doc;\n  const store = doc.store;\n  const ownClientID = doc.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item;\n  /**\n   * @type {Item|null}\n   */\n  let left = null;\n  /**\n   * @type {Item|null}\n   */\n  let right;\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true) {\n    // try to undo parent if it will be undone anyway\n    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {\n      return null\n    }\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n  }\n  const parentType = parentItem === null ? /** @type {AbstractType<any>} */ (item.parent) : /** @type {ContentType} */ (parentItem.content).type;\n\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left;\n    right = item;\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left;\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace;\n        break\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right;\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace;\n        break\n      }\n      right = right.right;\n    }\n  } else {\n    right = null;\n    if (item.right && !ignoreRemoteMapChanges) {\n      left = item;\n      // Iterate right while right is in itemsToDelete\n      // If it is intended to delete right while item is redone, we can expect that item should replace right.\n      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {\n        left = left.right;\n        // follow redone\n        while (left.redone) left = getItemCleanStart(transaction, left.redone);\n      }\n      if (left && left.right !== null) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    } else {\n      left = parentType._map.get(item.parentSub) || null;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentType,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem\n};\n\n/**\n * Abstract class that represents any content.\n */\nclass Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength());\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin;\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left;\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right;\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin;\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent;\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub;\n    /**\n     * If this type's effect is redone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null;\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content;\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2 : 0;\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0) !== isMarked) {\n      this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4;\n    }\n  }\n\n  get marker () {\n    return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1;\n    }\n  }\n\n  get countable () {\n    return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;\n    }\n  }\n\n  markDeleted () {\n    this.info |= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null;\n    } else if (!this.parent) {\n      // only set parent if this shouldn't be garbage collected\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      } else if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type;\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left;\n\n        /**\n         * @type {Item|null}\n         */\n        let o;\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start;\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set();\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set();\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction);\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub);\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction);\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      const searchMarker = /** @type {AbstractType<any>} */ (this.parent)._searchMarker;\n      if (searchMarker) {\n        searchMarker.forEach(marker => {\n          if (marker.p === right) {\n            // right is going to be \"forgotten\" so we need to update the marker\n            marker.p = this;\n            // adjust marker index\n            if (!this.deleted && this.countable) {\n              marker.index -= this.length;\n            }\n          }\n        });\n      }\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = (this.content.getRef() & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5) |\n      (origin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6); // parentSub is non-null\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      if (parent._item !== undefined) {\n        const parentItem = parent._item;\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent);\n          encoder.writeParentInfo(true); // write parentYKey\n          encoder.writeString(ykey);\n        } else {\n          encoder.writeParentInfo(false); // write parent id\n          encoder.writeLeftID(parentItem.id);\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true); // write parentYKey\n        encoder.writeString(parent);\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false); // write parent id\n        encoder.writeLeftID(parent);\n      } else {\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nconst readItemContent = (decoder, info) => contentRefs[info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5](decoder);\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nconst contentRefs = [\n  () => { lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase(); }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase(); } // 10 - Skip is not ItemContent\n];\n\nconst structSkipRefNumber = 10;\n\n/**\n * @private\n */\nclass Skip extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    // skip structs cannot be integrated\n    lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber);\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\n/** eslint-env browser */\n\n\nconst glo = /** @type {any} */ (typeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof window !== 'undefined'\n    ? window\n    // @ts-ignore\n    : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});\n\nconst importIdentifier = '__ $YJS$ __';\n\nif (glo[importIdentifier] === true) {\n  /**\n   * Dear reader of this message. Please take this seriously.\n   *\n   * If you see this message, make sure that you only import one version of Yjs. In many cases,\n   * your package manager installs two versions of Yjs that are used by different packages within your project.\n   * Another reason for this message is that some parts of your project use the commonjs version of Yjs\n   * and others use the EcmaScript version of Yjs.\n   *\n   * This often leads to issues that are hard to debug. We often need to perform constructor checks,\n   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to\n   * do the constructor checks anymore - which might break the CRDT algorithm.\n   *\n   * https://github.com/yjs/yjs/issues/438\n   */\n  console.error('Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438');\n}\nglo[importIdentifier] = true;\n\n\n//# sourceMappingURL=yjs.mjs.map\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../../node_modules/yjs/dist/yjs.mjs?\n}");

/***/ },

/***/ "../opencascade/lib/index.js"
/*!***********************************!*\
  !*** ../opencascade/lib/index.js ***!
  \***********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OCC: () => (/* reexport module object */ _jupytercad_opencascade__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   initializeOpenCascade: () => (/* binding */ initializeOpenCascade)\n/* harmony export */ });\n/* harmony import */ var _jupytercad_opencascade__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jupytercad.opencascade */ \"../opencascade/lib/jupytercad.opencascade.js\");\n/* harmony import */ var _jupytercad_opencascade_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jupytercad.opencascade.wasm */ \"../opencascade/lib/jupytercad.opencascade.wasm\");\n\n\n\nconst initOpenCascade = (options) => {\n    return new Promise((resolve, reject) => {\n        const { mainJS, mainWasm, worker, libs = [], module = [] } = options;\n        new mainJS(Object.assign({ locateFile(path) {\n                if (path.endsWith('.wasm')) {\n                    return mainWasm;\n                }\n                if (path.endsWith('.worker.js') && !!worker) {\n                    return worker;\n                }\n                return path;\n            } }, module)).then(async (oc) => {\n            for (const lib of libs) {\n                await oc.loadDynamicLibrary(lib, {\n                    loadAsync: true,\n                    global: true,\n                    nodelete: true,\n                    allowUndefined: false\n                });\n            }\n            resolve(oc);\n        });\n    });\n};\nasync function initializeOpenCascade() {\n    return initOpenCascade({\n        mainJS: _jupytercad_opencascade__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n        mainWasm: _jupytercad_opencascade_wasm__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    });\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../opencascade/lib/index.js?\n}");

/***/ },

/***/ "../opencascade/lib/jupytercad.opencascade.js"
/*!****************************************************!*\
  !*** ../opencascade/lib/jupytercad.opencascade.js ***!
  \****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nvar Module = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  \n  return (\nfunction(Module) {\n  Module = Module || {};\n\nvar Module=typeof Module!=\"undefined\"?Module:{};var readyPromiseResolve,readyPromiseReject;Module[\"ready\"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=true;var ENVIRONMENT_IS_WORKER=false;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\"undefined\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf(\"blob:\")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1)}else{scriptDirectory=\"\"}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,true);xhr.responseType=\"arraybuffer\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var POINTER_SIZE=4;var tempRet0=0;var setTempRet0=value=>{tempRet0=value};var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];var noExitRuntime=Module[\"noExitRuntime\"]||true;if(typeof WebAssembly!=\"object\"){abort(\"no native wasm support detected\")}var wasmMemory;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort(text)}}var UTF8Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){idx>>>=0;var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}else{var str=\"\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){ptr>>>=0;return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\"\"}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){outIdx>>>=0;if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6;heap[outIdx++>>>0]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18;heap[outIdx++>>>0]=128|u>>12&63;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}}heap[outIdx>>>0]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}var UTF16Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf-16le\"):undefined;function UTF16ToString(ptr,maxBytesToRead){var endPtr=ptr;var idx=endPtr>>1;var maxIdx=idx+maxBytesToRead/2;while(!(idx>=maxIdx)&&HEAPU16[idx>>>0])++idx;endPtr=idx<<1;if(endPtr-ptr>32&&UTF16Decoder){return UTF16Decoder.decode(HEAPU8.subarray(ptr>>>0,endPtr>>>0))}else{var str=\"\";for(var i=0;!(i>=maxBytesToRead/2);++i){var codeUnit=HEAP16[ptr+i*2>>>1];if(codeUnit==0)break;str+=String.fromCharCode(codeUnit)}return str}}function stringToUTF16(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>>1]=0;return outPtr-startPtr}function lengthBytesUTF16(str){return str.length*2}function UTF32ToString(ptr,maxBytesToRead){var i=0;var str=\"\";while(!(i>=maxBytesToRead/4)){var utf32=HEAP32[ptr+i*4>>>2];if(utf32==0)break;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}return str}function stringToUTF32(str,outPtr,maxBytesToWrite){outPtr>>>=0;if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr>>>2]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>>2]=0;return outPtr-startPtr}function lengthBytesUTF32(str){var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4}return len}function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer>>>0)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>>0]=0}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module[\"HEAP8\"]=HEAP8=new Int8Array(buf);Module[\"HEAP16\"]=HEAP16=new Int16Array(buf);Module[\"HEAP32\"]=HEAP32=new Int32Array(buf);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(buf);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(buf);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(buf);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(buf);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module[\"INITIAL_MEMORY\"]||15728640;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(!Module[\"noFSInit\"]&&!FS.init.initialized)FS.init();FS.ignorePermissions=false;TTY.init();callRuntimeCallbacks(__ATINIT__)}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){{if(Module[\"onAbort\"]){Module[\"onAbort\"](what)}}what=\"Aborted(\"+what+\")\";err(what);ABORT=true;EXITSTATUS=1;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix=\"data:application/octet-stream;base64,\";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}var wasmBinaryFile;wasmBinaryFile=\"jupytercad.opencascade.wasm\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else{throw\"both async and sync fetching of the wasm failed\"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){if(!response[\"ok\"]){throw\"failed to load wasm binary file at '\"+wasmBinaryFile+\"'\"}return response[\"arrayBuffer\"]()}).catch(function(){return getBinary(wasmBinaryFile)})}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={\"a\":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module[\"asm\"]=exports;wasmMemory=Module[\"asm\"][\"oa\"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module[\"asm\"][\"va\"];addOnInit(Module[\"asm\"][\"pa\"]);removeRunDependency(\"wasm-instantiate\")}addRunDependency(\"wasm-instantiate\");function receiveInstantiationResult(result){receiveInstance(result[\"instance\"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err(\"failed to asynchronously prepare wasm: \"+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==\"function\"&&!isDataURI(wasmBinaryFile)&&typeof fetch==\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err(\"wasm streaming compile failed: \"+reason);err(\"falling back to ArrayBuffer instantiation\");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module[\"instantiateWasm\"]){try{var exports=Module[\"instantiateWasm\"](info,receiveInstance);return exports}catch(e){err(\"Module.instantiateWasm callback failed with error: \"+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}var tempDouble;var tempI64;function OSD_MemInfo_getModuleHeapLength(){return Module.HEAP8.length}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback==\"function\"){callback(Module);continue}var func=callback.func;if(typeof func==\"number\"){if(callback.arg===undefined){getWasmTableEntry(func)()}else{getWasmTableEntry(func)(callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var wasmTableMirror=[];function getWasmTableEntry(funcPtr){var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func}function ___assert_fail(condition,filename,line,func){abort(\"Assertion failed: \"+UTF8ToString(condition)+\", at: \"+[filename?UTF8ToString(filename):\"unknown filename\",line,func?UTF8ToString(func):\"unknown function\"])}function ___cxa_allocate_exception(size){return _malloc(size+24)+24}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){var value=HEAP32[this.ptr>>>2];HEAP32[this.ptr>>>2]=value+1};this.release_ref=function(){var prev=HEAP32[this.ptr>>>2];HEAP32[this.ptr>>>2]=prev-1;return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}var PATH={isAbs:path=>path.charAt(0)===\"/\",splitPath:filename=>{var splitPathRe=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\".\"){parts.splice(i,1)}else if(last===\"..\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\"..\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.substr(-1)===\"/\";path=PATH.normalizeArray(path.split(\"/\").filter(p=>!!p),!isAbsolute).join(\"/\");if(!path&&!isAbsolute){path=\".\"}if(path&&trailingSlash){path+=\"/\"}return(isAbsolute?\"/\":\"\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\".\"}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:path=>{if(path===\"/\")return\"/\";path=PATH.normalize(path);path=path.replace(/\\/$/,\"\");var lastSlash=path.lastIndexOf(\"/\");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join(\"/\"))},join2:(l,r)=>{return PATH.normalize(l+\"/\"+r)}};function getRandomDevice(){if(typeof crypto==\"object\"&&typeof crypto[\"getRandomValues\"]==\"function\"){var randomBuffer=new Uint8Array(1);return function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]}}else return function(){abort(\"randomDevice\")}}var PATH_FS={resolve:function(){var resolvedPath=\"\",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=\"string\"){throw new TypeError(\"Arguments to path.resolve must be strings\")}else if(!path){return\"\"}resolvedPath=path+\"/\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\"/\").filter(p=>!!p),!resolvedAbsolute).join(\"/\");return(resolvedAbsolute?\"/\":\"\")+resolvedPath||\".\"},relative:(from,to)=>{from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\"\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\"\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\"/\"));var toParts=trim(to.split(\"/\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\"..\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\"/\")}};var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close:function(stream){stream.tty.ops.flush(stream.tty)},flush:function(stream){stream.tty.ops.flush(stream.tty)},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now()}return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(typeof window!=\"undefined\"&&typeof window.prompt==\"function\"){result=window.prompt(\"Input: \");if(result!==null){result+=\"\\n\"}}else if(typeof readline==\"function\"){result=readline();if(result!==null){result+=\"\\n\"}}if(!result){return null}tty.input=intArrayFromString(result,true)}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},flush:function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[]}}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},flush:function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[]}}}};function zeroMemory(address,size){HEAPU8.fill(0,address,address+size)}function alignMemory(size,alignment){return Math.ceil(size/alignment)*alignment}function mmapAlloc(size){size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(!ptr)return 0;zeroMemory(ptr,size);return ptr}var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,\"/\",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}}}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp}return node},getFileDataAsTypedArray:function(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,newCapacity){newCapacity>>>=0;var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage:function(node,newSize){newSize>>>=0;if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup:function(parent,name){throw FS.genericErrors[44]},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp;old_node.parent=new_dir},unlink:function(parent,name){delete parent.contents[name];parent.timestamp=Date.now()},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.timestamp=Date.now()},readdir:function(node){var entries=[\".\",\"..\"];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key)}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink:function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write:function(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap:function(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents.buffer===buffer){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}ptr>>>=0;HEAP8.set(contents,ptr>>>0)}return{ptr:ptr,allocated:allocated}},msync:function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};function asyncLoad(url,onload,onerror,noRunDep){var dep=!noRunDep?getUniqueRunDependency(\"al \"+url):\"\";readAsync(url,function(arrayBuffer){assert(arrayBuffer,'Loading data file \"'+url+'\" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency(dep)},function(event){if(onerror){onerror()}else{throw'Loading data file \"'+url+'\" failed.'}});if(dep)addRunDependency(dep)}var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path,opts={})=>{path=PATH_FS.resolve(FS.cwd(),path);if(!path)return{path:\"\",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=PATH.normalizeArray(path.split(\"/\").filter(p=>!!p),false);var current=FS.root;var current_path=\"/\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return{path:current_path,node:current}},getPath:node=>{var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\"/\"?mount+\"/\"+path:mount+path}path=path?node.name+\"/\"+path:node.name;node=node.parent}},hashName:(parentid,name)=>{var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode:node=>{var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode:node=>{var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode:(parent,name)=>{var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode:(parent,name,mode,rdev)=>{var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:node=>{FS.hashRemoveNode(node)},isRoot:node=>{return node===node.parent},isMountpoint:node=>{return!!node.mounted},isFile:mode=>{return(mode&61440)===32768},isDir:mode=>{return(mode&61440)===16384},isLink:mode=>{return(mode&61440)===40960},isChrdev:mode=>{return(mode&61440)===8192},isBlkdev:mode=>{return(mode&61440)===24576},isFIFO:mode=>{return(mode&61440)===4096},isSocket:mode=>{return(mode&49152)===49152},flagModes:{\"r\":0,\"r+\":2,\"w\":577,\"w+\":578,\"a\":1089,\"a+\":1090},modeStringToFlags:str=>{var flags=FS.flagModes[str];if(typeof flags==\"undefined\"){throw new Error(\"Unknown file open mode: \"+str)}return flags},flagsToPermissionString:flag=>{var perms=[\"r\",\"w\",\"rw\"][flag&3];if(flag&512){perms+=\"w\"}return perms},nodePermissions:(node,perms)=>{if(FS.ignorePermissions){return 0}if(perms.includes(\"r\")&&!(node.mode&292)){return 2}else if(perms.includes(\"w\")&&!(node.mode&146)){return 2}else if(perms.includes(\"x\")&&!(node.mode&73)){return 2}return 0},mayLookup:dir=>{var errCode=FS.nodePermissions(dir,\"x\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate:(dir,name)=>{try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\"wx\")},mayDelete:(dir,name,isdir)=>{var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\"wx\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else{if(FS.isDir(node.mode)){return 31}}return 0},mayOpen:(node,flags)=>{if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!==\"r\"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:(fd_start=0,fd_end=FS.MAX_OPEN_FDS)=>{for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStream:fd=>FS.streams[fd],createStream:(stream,fd_start,fd_end)=>{if(!FS.FSStream){FS.FSStream=function(){this.shared={}};FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:function(){return this.node},set:function(val){this.node=val}},isRead:{get:function(){return(this.flags&2097155)!==1}},isWrite:{get:function(){return(this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}},flags:{get:function(){return this.shared.flags},set:function(val){this.shared.flags=val}},position:{get:function(){return this.shared.position},set:function(val){this.shared.position=val}}})}stream=Object.assign(new FS.FSStream,stream);var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:fd=>{FS.streams[fd]=null},chrdev_stream_ops:{open:stream=>{var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream)}},llseek:()=>{throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice:(dev,ops)=>{FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts:mount=>{var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts},syncfs:(populate,callback)=>{if(typeof populate==\"function\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(\"warning: \"+FS.syncFSRequests+\" FS.syncfs operations in flight at once, probably just doing extra work\")}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount:(type,opts,mountpoint)=>{var root=mountpoint===\"/\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount:mountpoint=>{var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup:(parent,name)=>{return parent.node_ops.lookup(parent,name)},mknod:(path,mode,dev)=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name===\".\"||name===\"..\"){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create:(path,mode)=>{mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:(path,mode)=>{mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree:(path,mode)=>{var dirs=path.split(\"/\");var d=\"\";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+=\"/\"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev:(path,mode,dev)=>{if(typeof dev==\"undefined\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink:(oldpath,newpath)=>{if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename:(old_path,new_path)=>{var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir:path=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink:path=>{var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat:(path,dontFollow)=>{var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat:path=>{return FS.stat(path,true)},chmod:(path,mode,dontFollow)=>{var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod:(path,mode)=>{FS.chmod(path,mode,true)},fchmod:(fd,mode)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chmod(stream.node,mode)},chown:(path,uid,gid,dontFollow)=>{var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()})},lchown:(path,uid,gid)=>{FS.chown(path,uid,gid,true)},fchown:(fd,uid,gid)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chown(stream.node,uid,gid)},truncate:(path,len)=>{if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate:(fd,len)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len)},utime:(path,atime,mtime)=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open:(path,flags,mode)=>{if(path===\"\"){throw new FS.ErrnoError(44)}flags=typeof flags==\"string\"?FS.modeStringToFlags(flags):flags;mode=typeof mode==\"undefined\"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path==\"object\"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module[\"logReadFiles\"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1}}return stream},close:stream=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed:stream=>{return stream.fd===null},llseek:(stream,offset,whence)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read:(stream,buffer,offset,length,position)=>{offset>>>=0;if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:(stream,buffer,offset,length,position,canOwn)=>{offset>>>=0;if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate:(stream,offset,length)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length)},mmap:(stream,length,position,prot,flags)=>{if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync:(stream,buffer,offset,length,mmapFlags)=>{offset>>>=0;if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},munmap:stream=>0,ioctl:(stream,cmd,arg)=>{if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:(path,opts={})=>{opts.flags=opts.flags||0;opts.encoding=opts.encoding||\"binary\";if(opts.encoding!==\"utf8\"&&opts.encoding!==\"binary\"){throw new Error('Invalid encoding type \"'+opts.encoding+'\"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\"utf8\"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding===\"binary\"){ret=buf}FS.close(stream);return ret},writeFile:(path,data,opts={})=>{opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\"string\"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error(\"Unsupported data type\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir:path=>{var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\"x\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories:()=>{FS.mkdir(\"/tmp\");FS.mkdir(\"/home\");FS.mkdir(\"/home/web_user\")},createDefaultDevices:()=>{FS.mkdir(\"/dev\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length});FS.mkdev(\"/dev/null\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\"/dev/tty\",FS.makedev(5,0));FS.mkdev(\"/dev/tty1\",FS.makedev(6,0));var random_device=getRandomDevice();FS.createDevice(\"/dev\",\"random\",random_device);FS.createDevice(\"/dev\",\"urandom\",random_device);FS.mkdir(\"/dev/shm\");FS.mkdir(\"/dev/shm/tmp\")},createSpecialDirectories:()=>{FS.mkdir(\"/proc\");var proc_self=FS.mkdir(\"/proc/self\");FS.mkdir(\"/proc/self/fd\");FS.mount({mount:()=>{var node=FS.createNode(proc_self,\"fd\",16384|511,73);node.node_ops={lookup:(parent,name)=>{var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);var ret={parent:null,mount:{mountpoint:\"fake\"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;return ret}};return node}},{},\"/proc/self/fd\")},createStandardStreams:()=>{if(Module[\"stdin\"]){FS.createDevice(\"/dev\",\"stdin\",Module[\"stdin\"])}else{FS.symlink(\"/dev/tty\",\"/dev/stdin\")}if(Module[\"stdout\"]){FS.createDevice(\"/dev\",\"stdout\",null,Module[\"stdout\"])}else{FS.symlink(\"/dev/tty\",\"/dev/stdout\")}if(Module[\"stderr\"]){FS.createDevice(\"/dev\",\"stderr\",null,Module[\"stderr\"])}else{FS.symlink(\"/dev/tty1\",\"/dev/stderr\")}var stdin=FS.open(\"/dev/stdin\",0);var stdout=FS.open(\"/dev/stdout\",1);var stderr=FS.open(\"/dev/stderr\",1)},ensureErrnoError:()=>{if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=function(errno){this.errno=errno};this.setErrno(errno);this.message=\"FS error\"};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[44].forEach(code=>{FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack=\"<generic error, no stack>\"})},staticInit:()=>{FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\"/\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={\"MEMFS\":MEMFS}},init:(input,output,error)=>{FS.init.initialized=true;FS.ensureErrnoError();Module[\"stdin\"]=input||Module[\"stdin\"];Module[\"stdout\"]=output||Module[\"stdout\"];Module[\"stderr\"]=error||Module[\"stderr\"];FS.createStandardStreams()},quit:()=>{FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},getMode:(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},findObject:(path,dontResolveLastLink)=>{var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else{return null}},analyzePath:(path,dontResolveLastLink)=>{try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\"/\"}catch(e){ret.error=e.errno}return ret},createPath:(parent,path,canRead,canWrite)=>{parent=typeof parent==\"string\"?parent:FS.getPath(parent);var parts=path.split(\"/\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile:(parent,name,properties,canRead,canWrite)=>{var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:(parent,name,data,canRead,canWrite,canOwn)=>{var path=name;if(parent){parent=typeof parent==\"string\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\"string\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node},createDevice:(parent,name,input,output)=>{var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:stream=>{stream.seekable=false},close:stream=>{if(output&&output.buffer&&output.buffer.length){output(10)}},read:(stream,buffer,offset,length,pos)=>{var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:(stream,buffer,offset,length,pos)=>{for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile:obj=>{if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!=\"undefined\"){throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\")}else if(read_){try{obj.contents=intArrayFromString(read_(obj.url),true);obj.usedBytes=obj.contents.length}catch(e){throw new FS.ErrnoError(29)}}else{throw new Error(\"Cannot load without read() or XMLHttpRequest.\")}},createLazyFile:(parent,name,url,canRead,canWrite)=>{function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\"HEAD\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\"Couldn't load \"+url+\". Status: \"+xhr.status);var datalength=Number(xhr.getResponseHeader(\"Content-length\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\"Accept-Ranges\"))&&header===\"bytes\";var usesGzip=(header=xhr.getResponseHeader(\"Content-Encoding\"))&&header===\"gzip\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error(\"invalid range (\"+from+\", \"+to+\") or no bytes requested!\");if(to>datalength-1)throw new Error(\"only \"+datalength+\" bytes available! programmer error!\");var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\"Range\",\"bytes=\"+from+\"-\"+to);xhr.responseType=\"arraybuffer\";if(xhr.overrideMimeType){xhr.overrideMimeType(\"text/plain; charset=x-user-defined\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\"Couldn't load \"+url+\". Status: \"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else{return intArrayFromString(xhr.responseText||\"\",true)}};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\"undefined\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\"undefined\")throw new Error(\"doXHR failed!\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\"LazyFiles on gzip forces download of the whole file when length is accessed\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!=\"undefined\"){if(!ENVIRONMENT_IS_WORKER)throw\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._length}},chunkSize:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}});var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){FS.forceLoadFile(node);return fn.apply(null,arguments)}});function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,HEAP8,ptr,length,position);return{ptr:ptr,allocated:true}};node.stream_ops=stream_ops;return node},createPreloadedFile:(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(\"cp \"+fullname);function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}if(onload)onload();removeRunDependency(dep)}if(Browser.handledByPreloadPlugin(byteArray,fullname,finish,()=>{if(onerror)onerror();removeRunDependency(dep)})){return}finish(byteArray)}addRunDependency(dep);if(typeof url==\"string\"){asyncLoad(url,byteArray=>processData(byteArray),onerror)}else{processData(url)}},indexedDB:()=>{return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:()=>{return\"EM_FS_\"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:\"FILE_DATA\",saveFilesToDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=()=>{out(\"creating db\");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME)};openRequest.onsuccess=()=>{var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],\"readwrite\");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(path=>{var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=()=>{ok++;if(ok+fail==total)finish()};putRequest.onerror=()=>{fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror},loadFilesFromDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=()=>{var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],\"readonly\")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(path=>{var getRequest=files.get(path);getRequest.onsuccess=()=>{if(FS.analyzePath(path).exists){FS.unlink(path)}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()};getRequest.onerror=()=>{fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror}};var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt:function(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(8);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return PATH.join2(dir,path)},doStat:function(func,path,buf){try{var stat=func(path)}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return-54}throw e}HEAP32[buf>>>2]=stat.dev;HEAP32[buf+4>>>2]=0;HEAP32[buf+8>>>2]=stat.ino;HEAP32[buf+12>>>2]=stat.mode;HEAP32[buf+16>>>2]=stat.nlink;HEAP32[buf+20>>>2]=stat.uid;HEAP32[buf+24>>>2]=stat.gid;HEAP32[buf+28>>>2]=stat.rdev;HEAP32[buf+32>>>2]=0;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>>2]=tempI64[0],HEAP32[buf+44>>>2]=tempI64[1];HEAP32[buf+48>>>2]=4096;HEAP32[buf+52>>>2]=stat.blocks;HEAP32[buf+56>>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+60>>>2]=0;HEAP32[buf+64>>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+68>>>2]=0;HEAP32[buf+72>>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+76>>>2]=0;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+80>>>2]=tempI64[0],HEAP32[buf+84>>>2]=tempI64[1];return 0},doMsync:function(addr,stream,len,flags,offset){var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},getStreamFromFD:function(fd){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);return stream}};function ___syscall_chmod(path,mode){try{path=SYSCALLS.getStr(path);FS.chmod(path,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_faccessat(dirfd,path,amode,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(amode&~7){return-28}var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node){return-44}var perms=\"\";if(amode&4)perms+=\"r\";if(amode&2)perms+=\"w\";if(amode&1)perms+=\"x\";if(perms&&FS.nodePermissions(node,perms)){return-2}return 0}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function setErrNo(value){HEAP32[___errno_location()>>>2]=value;return value}function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return-28}var newStream;newStream=FS.createStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 5:{var arg=SYSCALLS.get();var offset=0;HEAP16[arg+offset>>>1]=2;return 0}case 6:case 7:return 0;case 16:case 8:return-28;case 9:setErrNo(28);return-1;default:{return-28}}}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_fstat64(fd,buf){try{var stream=SYSCALLS.getStreamFromFD(fd);return SYSCALLS.doStat(FS.stat,stream.path,buf)}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:case 21505:{if(!stream.tty)return-59;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return-59;return 0}case 21519:{if(!stream.tty)return-59;var argp=SYSCALLS.get();HEAP32[argp>>>2]=0;return 0}case 21520:{if(!stream.tty)return-59;return-28}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-59;return 0}case 21524:{if(!stream.tty)return-59;return 0}default:abort(\"bad ioctl syscall \"+op)}}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_lstat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.lstat,path,buf)}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_newfstatat(dirfd,path,buf,flags){try{path=SYSCALLS.getStr(path);var nofollow=flags&256;var allowEmpty=flags&4096;flags=flags&~4352;path=SYSCALLS.calculateAt(dirfd,path,allowEmpty);return SYSCALLS.doStat(nofollow?FS.lstat:FS.stat,path,buf)}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?SYSCALLS.get():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.stat,path,buf)}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function __embind_register_bigint(primitiveType,name,size,minRange,maxRange){}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(\"Unknown type size: \"+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i)}embind_charCodes=codes}var embind_charCodes=undefined;function readLatin1String(ptr){var ret=\"\";var c=ptr;while(HEAPU8[c>>>0]){ret+=embind_charCodes[HEAPU8[c++>>>0]]}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return\"_unknown\"}name=name.replace(/[^a-zA-Z0-9_]/g,\"$\");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return\"_\"+name}return name}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return new Function(\"body\",\"return function \"+name+\"() {\\n\"+'    \"use strict\";'+\"    return body.apply(this, arguments);\\n\"+\"};\\n\")(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+\"\\n\"+stack.replace(/^Error(:[^\\n]*)?\\n/,\"\")}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else{return this.name+\": \"+this.message}};return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError(\"Mismatched type converter count\")}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i])}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach((dt,i)=>{if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt]}else{unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[]}awaitingDependencies[dt].push(()=>{typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters)}})}});if(0===unregisteredTypes.length){onComplete(typeConverters)}}function registerType(rawType,registeredInstance,options={}){if(!(\"argPackAdvance\"in registeredInstance)){throw new TypeError(\"registerType registeredInstance requires argPackAdvance\")}var name=registeredInstance.name;if(!rawType){throwBindingError('type \"'+name+'\" must have a positive integer typeid pointer')}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else{throwBindingError(\"Cannot register type '\"+name+\"' twice\")}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(cb=>cb())}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(wt){return!!wt},\"toWireType\":function(destructors,o){return o?trueValue:falseValue},\"argPackAdvance\":8,\"readValueFromPointer\":function(pointer){var heap;if(size===1){heap=HEAP8}else if(size===2){heap=HEAP16}else if(size===4){heap=HEAP32}else{throw new TypeError(\"Unknown boolean type size: \"+name)}return this[\"fromWireType\"](heap[pointer>>>shift])},destructorFunction:null})}function ClassHandle_isAliasOf(other){if(!(this instanceof ClassHandle)){return false}if(!(other instanceof ClassHandle)){return false}var leftClass=this.$$.ptrType.registeredClass;var left=this.$$.ptr;var rightClass=other.$$.ptrType.registeredClass;var right=other.$$.ptr;while(leftClass.baseClass){left=leftClass.upcast(left);leftClass=leftClass.baseClass}while(rightClass.baseClass){right=rightClass.upcast(right);rightClass=rightClass.baseClass}return leftClass===rightClass&&left===right}function shallowCopyInternalPointer(o){return{count:o.count,deleteScheduled:o.deleteScheduled,preservePointerOnDelete:o.preservePointerOnDelete,ptr:o.ptr,ptrType:o.ptrType,smartPtr:o.smartPtr,smartPtrType:o.smartPtrType}}function throwInstanceAlreadyDeleted(obj){function getInstanceTypeName(handle){return handle.$$.ptrType.registeredClass.name}throwBindingError(getInstanceTypeName(obj)+\" instance already deleted\")}var finalizationRegistry=false;function detachFinalizer(handle){}function runDestructor($$){if($$.smartPtr){$$.smartPtrType.rawDestructor($$.smartPtr)}else{$$.ptrType.registeredClass.rawDestructor($$.ptr)}}function releaseClassHandle($$){$$.count.value-=1;var toDelete=0===$$.count.value;if(toDelete){runDestructor($$)}}function downcastPointer(ptr,ptrClass,desiredClass){if(ptrClass===desiredClass){return ptr}if(undefined===desiredClass.baseClass){return null}var rv=downcastPointer(ptr,ptrClass,desiredClass.baseClass);if(rv===null){return null}return desiredClass.downcast(rv)}var registeredPointers={};function getInheritedInstanceCount(){return Object.keys(registeredInstances).length}function getLiveInheritedInstances(){var rv=[];for(var k in registeredInstances){if(registeredInstances.hasOwnProperty(k)){rv.push(registeredInstances[k])}}return rv}var deletionQueue=[];function flushPendingDeletes(){while(deletionQueue.length){var obj=deletionQueue.pop();obj.$$.deleteScheduled=false;obj[\"delete\"]()}}var delayFunction=undefined;function setDelayFunction(fn){delayFunction=fn;if(deletionQueue.length&&delayFunction){delayFunction(flushPendingDeletes)}}function init_embind(){Module[\"getInheritedInstanceCount\"]=getInheritedInstanceCount;Module[\"getLiveInheritedInstances\"]=getLiveInheritedInstances;Module[\"flushPendingDeletes\"]=flushPendingDeletes;Module[\"setDelayFunction\"]=setDelayFunction}var registeredInstances={};function getBasestPointer(class_,ptr){if(ptr===undefined){throwBindingError(\"ptr should not be undefined\")}while(class_.baseClass){ptr=class_.upcast(ptr);class_=class_.baseClass}return ptr}function getInheritedInstance(class_,ptr){ptr=getBasestPointer(class_,ptr);return registeredInstances[ptr]}function makeClassHandle(prototype,record){if(!record.ptrType||!record.ptr){throwInternalError(\"makeClassHandle requires ptr and ptrType\")}var hasSmartPtrType=!!record.smartPtrType;var hasSmartPtr=!!record.smartPtr;if(hasSmartPtrType!==hasSmartPtr){throwInternalError(\"Both smartPtrType and smartPtr must be specified\")}record.count={value:1};return attachFinalizer(Object.create(prototype,{$$:{value:record}}))}function RegisteredPointer_fromWireType(ptr){var rawPointer=this.getPointee(ptr);if(!rawPointer){this.destructor(ptr);return null}var registeredInstance=getInheritedInstance(this.registeredClass,rawPointer);if(undefined!==registeredInstance){if(0===registeredInstance.$$.count.value){registeredInstance.$$.ptr=rawPointer;registeredInstance.$$.smartPtr=ptr;return registeredInstance[\"clone\"]()}else{var rv=registeredInstance[\"clone\"]();this.destructor(ptr);return rv}}function makeDefaultHandle(){if(this.isSmartPointer){return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:rawPointer,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this,ptr:ptr})}}var actualType=this.registeredClass.getActualType(rawPointer);var registeredPointerRecord=registeredPointers[actualType];if(!registeredPointerRecord){return makeDefaultHandle.call(this)}var toType;if(this.isConst){toType=registeredPointerRecord.constPointerType}else{toType=registeredPointerRecord.pointerType}var dp=downcastPointer(rawPointer,this.registeredClass,toType.registeredClass);if(dp===null){return makeDefaultHandle.call(this)}if(this.isSmartPointer){return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp})}}function attachFinalizer(handle){if(\"undefined\"===typeof FinalizationRegistry){attachFinalizer=handle=>handle;return handle}finalizationRegistry=new FinalizationRegistry(info=>{releaseClassHandle(info.$$)});attachFinalizer=handle=>{var $$=handle.$$;var hasSmartPtr=!!$$.smartPtr;if(hasSmartPtr){var info={$$:$$};finalizationRegistry.register(handle,info,handle)}return handle};detachFinalizer=handle=>finalizationRegistry.unregister(handle);return attachFinalizer(handle)}function ClassHandle_clone(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.preservePointerOnDelete){this.$$.count.value+=1;return this}else{var clone=attachFinalizer(Object.create(Object.getPrototypeOf(this),{$$:{value:shallowCopyInternalPointer(this.$$)}}));clone.$$.count.value+=1;clone.$$.deleteScheduled=false;return clone}}function ClassHandle_delete(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError(\"Object already scheduled for deletion\")}detachFinalizer(this);releaseClassHandle(this.$$);if(!this.$$.preservePointerOnDelete){this.$$.smartPtr=undefined;this.$$.ptr=undefined}}function ClassHandle_isDeleted(){return!this.$$.ptr}function ClassHandle_deleteLater(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError(\"Object already scheduled for deletion\")}deletionQueue.push(this);if(deletionQueue.length===1&&delayFunction){delayFunction(flushPendingDeletes)}this.$$.deleteScheduled=true;return this}function init_ClassHandle(){ClassHandle.prototype[\"isAliasOf\"]=ClassHandle_isAliasOf;ClassHandle.prototype[\"clone\"]=ClassHandle_clone;ClassHandle.prototype[\"delete\"]=ClassHandle_delete;ClassHandle.prototype[\"isDeleted\"]=ClassHandle_isDeleted;ClassHandle.prototype[\"deleteLater\"]=ClassHandle_deleteLater}function ClassHandle(){}function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError(\"Function '\"+humanName+\"' called with an invalid number of arguments (\"+arguments.length+\") - expects one of (\"+proto[methodName].overloadTable+\")!\")}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError(\"Cannot register public name '\"+name+\"' twice\")}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\"+numArguments+\")!\")}Module[name].overloadTable[numArguments]=value}else{Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments}}}function RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast){this.name=name;this.constructor=constructor;this.instancePrototype=instancePrototype;this.rawDestructor=rawDestructor;this.baseClass=baseClass;this.getActualType=getActualType;this.upcast=upcast;this.downcast=downcast;this.pureVirtualFunctions=[]}function upcastPointer(ptr,ptrClass,desiredClass){while(ptrClass!==desiredClass){if(!ptrClass.upcast){throwBindingError(\"Expected null or instance of \"+desiredClass.name+\", got an instance of \"+ptrClass.name)}ptr=ptrClass.upcast(ptr);ptrClass=ptrClass.baseClass}return ptr}function constNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError(\"null is not a valid \"+this.name)}return 0}if(!handle.$$){throwBindingError('Cannot pass \"'+_embind_repr(handle)+'\" as a '+this.name)}if(!handle.$$.ptr){throwBindingError(\"Cannot pass deleted object as a pointer of type \"+this.name)}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function genericPointerToWireType(destructors,handle){var ptr;if(handle===null){if(this.isReference){throwBindingError(\"null is not a valid \"+this.name)}if(this.isSmartPointer){ptr=this.rawConstructor();if(destructors!==null){destructors.push(this.rawDestructor,ptr)}return ptr}else{return 0}}if(!handle.$$){throwBindingError('Cannot pass \"'+_embind_repr(handle)+'\" as a '+this.name)}if(!handle.$$.ptr){throwBindingError(\"Cannot pass deleted object as a pointer of type \"+this.name)}if(!this.isConst&&handle.$$.ptrType.isConst){throwBindingError(\"Cannot convert argument of type \"+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+\" to parameter type \"+this.name)}var handleClass=handle.$$.ptrType.registeredClass;ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);if(this.isSmartPointer){if(undefined===handle.$$.smartPtr){throwBindingError(\"Passing raw pointer to smart pointer is illegal\")}switch(this.sharingPolicy){case 0:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr}else{throwBindingError(\"Cannot convert argument of type \"+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+\" to parameter type \"+this.name)}break;case 1:ptr=handle.$$.smartPtr;break;case 2:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr}else{var clonedHandle=handle[\"clone\"]();ptr=this.rawShare(ptr,Emval.toHandle(function(){clonedHandle[\"delete\"]()}));if(destructors!==null){destructors.push(this.rawDestructor,ptr)}}break;default:throwBindingError(\"Unsupporting sharing policy\")}}return ptr}function nonConstNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError(\"null is not a valid \"+this.name)}return 0}if(!handle.$$){throwBindingError('Cannot pass \"'+_embind_repr(handle)+'\" as a '+this.name)}if(!handle.$$.ptr){throwBindingError(\"Cannot pass deleted object as a pointer of type \"+this.name)}if(handle.$$.ptrType.isConst){throwBindingError(\"Cannot convert argument of type \"+handle.$$.ptrType.name+\" to parameter type \"+this.name)}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function simpleReadValueFromPointer(pointer){return this[\"fromWireType\"](HEAPU32[pointer>>>2])}function RegisteredPointer_getPointee(ptr){if(this.rawGetPointee){ptr=this.rawGetPointee(ptr)}return ptr}function RegisteredPointer_destructor(ptr){if(this.rawDestructor){this.rawDestructor(ptr)}}function RegisteredPointer_deleteObject(handle){if(handle!==null){handle[\"delete\"]()}}function init_RegisteredPointer(){RegisteredPointer.prototype.getPointee=RegisteredPointer_getPointee;RegisteredPointer.prototype.destructor=RegisteredPointer_destructor;RegisteredPointer.prototype[\"argPackAdvance\"]=8;RegisteredPointer.prototype[\"readValueFromPointer\"]=simpleReadValueFromPointer;RegisteredPointer.prototype[\"deleteObject\"]=RegisteredPointer_deleteObject;RegisteredPointer.prototype[\"fromWireType\"]=RegisteredPointer_fromWireType}function RegisteredPointer(name,registeredClass,isReference,isConst,isSmartPointer,pointeeType,sharingPolicy,rawGetPointee,rawConstructor,rawShare,rawDestructor){this.name=name;this.registeredClass=registeredClass;this.isReference=isReference;this.isConst=isConst;this.isSmartPointer=isSmartPointer;this.pointeeType=pointeeType;this.sharingPolicy=sharingPolicy;this.rawGetPointee=rawGetPointee;this.rawConstructor=rawConstructor;this.rawShare=rawShare;this.rawDestructor=rawDestructor;if(!isSmartPointer&&registeredClass.baseClass===undefined){if(isConst){this[\"toWireType\"]=constNoSmartPtrRawPointerToWireType;this.destructorFunction=null}else{this[\"toWireType\"]=nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction=null}}else{this[\"toWireType\"]=genericPointerToWireType}}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError(\"Replacing nonexistant public symbol\")}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value}else{Module[name]=value;Module[name].argCount=numArguments}}function dynCallLegacy(sig,ptr,args){var f=Module[\"dynCall_\"+sig];return args&&args.length?f.apply(null,[ptr].concat(args)):f.call(null,ptr)}function dynCall(sig,ptr,args){if(sig.includes(\"j\")){return dynCallLegacy(sig,ptr,args)}return getWasmTableEntry(ptr).apply(null,args)}function getDynCaller(sig,ptr){var argCache=[];return function(){argCache.length=0;Object.assign(argCache,arguments);return dynCall(sig,ptr,argCache)}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(){if(signature.includes(\"j\")){return getDynCaller(signature,rawFunction)}return getWasmTableEntry(rawFunction)}var fp=makeDynCaller();if(typeof fp!=\"function\"){throwBindingError(\"unknown function pointer with signature \"+signature+\": \"+rawFunction)}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true}types.forEach(visit);throw new UnboundTypeError(message+\": \"+unboundTypes.map(getTypeName).join([\", \"]))}function __embind_register_class(rawType,rawPointerType,rawConstPointerType,baseClassRawType,getActualTypeSignature,getActualType,upcastSignature,upcast,downcastSignature,downcast,name,destructorSignature,rawDestructor){name=readLatin1String(name);getActualType=embind__requireFunction(getActualTypeSignature,getActualType);if(upcast){upcast=embind__requireFunction(upcastSignature,upcast)}if(downcast){downcast=embind__requireFunction(downcastSignature,downcast)}rawDestructor=embind__requireFunction(destructorSignature,rawDestructor);var legalFunctionName=makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName,function(){throwUnboundTypeError(\"Cannot construct \"+name+\" due to unbound types\",[baseClassRawType])});whenDependentTypesAreResolved([rawType,rawPointerType,rawConstPointerType],baseClassRawType?[baseClassRawType]:[],function(base){base=base[0];var baseClass;var basePrototype;if(baseClassRawType){baseClass=base.registeredClass;basePrototype=baseClass.instancePrototype}else{basePrototype=ClassHandle.prototype}var constructor=createNamedFunction(legalFunctionName,function(){if(Object.getPrototypeOf(this)!==instancePrototype){throw new BindingError(\"Use 'new' to construct \"+name)}if(undefined===registeredClass.constructor_body){throw new BindingError(name+\" has no accessible constructor\")}var body=registeredClass.constructor_body[arguments.length];if(undefined===body){throw new BindingError(\"Tried to invoke ctor of \"+name+\" with invalid number of parameters (\"+arguments.length+\") - expected (\"+Object.keys(registeredClass.constructor_body).toString()+\") parameters instead!\")}return body.apply(this,arguments)});var instancePrototype=Object.create(basePrototype,{constructor:{value:constructor}});constructor.prototype=instancePrototype;var registeredClass=new RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast);var referenceConverter=new RegisteredPointer(name,registeredClass,true,false,false);var pointerConverter=new RegisteredPointer(name+\"*\",registeredClass,false,false,false);var constPointerConverter=new RegisteredPointer(name+\" const*\",registeredClass,false,true,false);registeredPointers[rawType]={pointerType:pointerConverter,constPointerType:constPointerConverter};replacePublicSymbol(legalFunctionName,constructor);return[referenceConverter,pointerConverter,constPointerConverter]})}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError(\"new_ called with constructor type \"+typeof constructor+\" which is not a function\")}var dummy=createNamedFunction(constructor.name||\"unknownFunctionName\",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr)}}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\")}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!==\"void\";var argsList=\"\";var argsListWired=\"\";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i;argsListWired+=(i!==0?\", \":\"\")+\"arg\"+i+\"Wired\"}var invokerFnBody=\"return function \"+makeLegalFunctionName(humanName)+\"(\"+argsList+\") {\\n\"+\"if (arguments.length !== \"+(argCount-2)+\") {\\n\"+\"throwBindingError('function \"+humanName+\" called with ' + arguments.length + ' arguments, expected \"+(argCount-2)+\" args!');\\n\"+\"}\\n\";if(needsDestructorStack){invokerFnBody+=\"var destructors = [];\\n\"}var dtorStack=needsDestructorStack?\"destructors\":\"null\";var args1=[\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+=\"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\"}for(var i=0;i<argCount-2;++i){invokerFnBody+=\"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";args1.push(\"argType\"+i);args2.push(argTypes[i+2])}if(isClassMethodFunc){argsListWired=\"thisWired\"+(argsListWired.length>0?\", \":\"\")+argsListWired}invokerFnBody+=(returns?\"var rv = \":\"\")+\"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";if(needsDestructorStack){invokerFnBody+=\"runDestructors(destructors);\\n\"}else{for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?\"thisWired\":\"arg\"+(i-2)+\"Wired\";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";args1.push(paramName+\"_dtor\");args2.push(argTypes[i].destructorFunction)}}}if(returns){invokerFnBody+=\"var ret = retType.fromWireType(rv);\\n\"+\"return ret;\\n\"}else{}invokerFnBody+=\"}\\n\";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i>>>0])}return array}function __embind_register_class_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,fn){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName=classType.name+\".\"+methodName;function unboundTypesHandler(){throwUnboundTypeError(\"Cannot call \"+humanName+\" due to unbound types\",rawArgTypes)}if(methodName.startsWith(\"@@\")){methodName=Symbol[methodName.substring(2)]}var proto=classType.registeredClass.constructor;if(undefined===proto[methodName]){unboundTypesHandler.argCount=argCount-1;proto[methodName]=unboundTypesHandler}else{ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-1]=unboundTypesHandler}whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));var func=craftInvokerFunction(humanName,invokerArgsArray,null,rawInvoker,fn);if(undefined===proto[methodName].overloadTable){func.argCount=argCount-1;proto[methodName]=func}else{proto[methodName].overloadTable[argCount-1]=func}return[]});return[]})}function __embind_register_class_constructor(rawClassType,argCount,rawArgTypesAddr,invokerSignature,invoker,rawConstructor){assert(argCount>0);var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);invoker=embind__requireFunction(invokerSignature,invoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName=\"constructor \"+classType.name;if(undefined===classType.registeredClass.constructor_body){classType.registeredClass.constructor_body=[]}if(undefined!==classType.registeredClass.constructor_body[argCount-1]){throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\"+(argCount-1)+\") for class '\"+classType.name+\"'! Overload resolution is currently only performed using the parameter count, not actual type info!\")}classType.registeredClass.constructor_body[argCount-1]=()=>{throwUnboundTypeError(\"Cannot construct \"+classType.name+\" due to unbound types\",rawArgTypes)};whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){argTypes.splice(1,0,null);classType.registeredClass.constructor_body[argCount-1]=craftInvokerFunction(humanName,argTypes,null,invoker,rawConstructor);return[]});return[]})}function __embind_register_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,context,isPureVirtual){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName=classType.name+\".\"+methodName;if(methodName.startsWith(\"@@\")){methodName=Symbol[methodName.substring(2)]}if(isPureVirtual){classType.registeredClass.pureVirtualFunctions.push(methodName)}function unboundTypesHandler(){throwUnboundTypeError(\"Cannot call \"+humanName+\" due to unbound types\",rawArgTypes)}var proto=classType.registeredClass.instancePrototype;var method=proto[methodName];if(undefined===method||undefined===method.overloadTable&&method.className!==classType.name&&method.argCount===argCount-2){unboundTypesHandler.argCount=argCount-2;unboundTypesHandler.className=classType.name;proto[methodName]=unboundTypesHandler}else{ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-2]=unboundTypesHandler}whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){var memberFunction=craftInvokerFunction(humanName,argTypes,classType,rawInvoker,context);if(undefined===proto[methodName].overloadTable){memberFunction.argCount=argCount-2;proto[methodName]=memberFunction}else{proto[methodName].overloadTable[argCount-2]=memberFunction}return[]});return[]})}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle)}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module[\"count_emval_handles\"]=count_emval_handles;Module[\"get_first_emval\"]=get_first_emval}var Emval={toValue:handle=>{if(!handle){throwBindingError(\"Cannot use deleted val. handle = \"+handle)}return emval_handle_array[handle].value},toHandle:value=>{switch(value){case undefined:return 1;case null:return 2;case true:return 3;case false:return 4;default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}};function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(handle){var rv=Emval.toValue(handle);__emval_decref(handle);return rv},\"toWireType\":function(destructors,value){return Emval.toHandle(value)},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:null})}function enumReadValueFromPointer(name,shift,signed){switch(shift){case 0:return function(pointer){var heap=signed?HEAP8:HEAPU8;return this[\"fromWireType\"](heap[pointer>>>0])};case 1:return function(pointer){var heap=signed?HEAP16:HEAPU16;return this[\"fromWireType\"](heap[pointer>>>1])};case 2:return function(pointer){var heap=signed?HEAP32:HEAPU32;return this[\"fromWireType\"](heap[pointer>>>2])};default:throw new TypeError(\"Unknown integer type: \"+name)}}function __embind_register_enum(rawType,name,size,isSigned){var shift=getShiftFromSize(size);name=readLatin1String(name);function ctor(){}ctor.values={};registerType(rawType,{name:name,constructor:ctor,\"fromWireType\":function(c){return this.constructor.values[c]},\"toWireType\":function(destructors,c){return c.value},\"argPackAdvance\":8,\"readValueFromPointer\":enumReadValueFromPointer(name,shift,isSigned),destructorFunction:null});exposePublicSymbol(name,ctor)}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+\" has unknown type \"+getTypeName(rawType))}return impl}function __embind_register_enum_value(rawEnumType,name,enumValue){var enumType=requireRegisteredType(rawEnumType,\"enum\");name=readLatin1String(name);var Enum=enumType.constructor;var Value=Object.create(enumType.constructor.prototype,{value:{value:enumValue},constructor:{value:createNamedFunction(enumType.name+\"_\"+name,function(){})}});Enum.values[enumValue]=Value;Enum[name]=Value}function _embind_repr(v){if(v===null){return\"null\"}var t=typeof v;if(t===\"object\"||t===\"array\"||t===\"function\"){return v.toString()}else{return\"\"+v}}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this[\"fromWireType\"](HEAPF32[pointer>>>2])};case 3:return function(pointer){return this[\"fromWireType\"](HEAPF64[pointer>>>3])};default:throw new TypeError(\"Unknown float type: \"+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":function(value){return value},\"toWireType\":function(destructors,value){return value},\"argPackAdvance\":8,\"readValueFromPointer\":floatReadValueFromPointer(name,shift),destructorFunction:null})}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer>>>0]}:function readU8FromPointer(pointer){return HEAPU8[pointer>>>0]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>>2]};default:throw new TypeError(\"Unknown integer type: \"+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295}var shift=getShiftFromSize(size);var fromWireType=value=>value;if(minRange===0){var bitshift=32-8*size;fromWireType=value=>value<<bitshift>>>bitshift}var isUnsignedType=name.includes(\"unsigned\");var checkAssertions=(value,toTypeName)=>{};var toWireType;if(isUnsignedType){toWireType=function(destructors,value){checkAssertions(value,this.name);return value>>>0}}else{toWireType=function(destructors,value){checkAssertions(value,this.name);return value}}registerType(primitiveType,{name:name,\"fromWireType\":fromWireType,\"toWireType\":toWireType,\"argPackAdvance\":8,\"readValueFromPointer\":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null})}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle>>>0];var data=heap[handle+1>>>0];return new TA(buffer,data,size)}name=readLatin1String(name);registerType(rawType,{name:name,\"fromWireType\":decodeMemoryView,\"argPackAdvance\":8,\"readValueFromPointer\":decodeMemoryView},{ignoreDuplicateRegistrations:true})}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name===\"std::string\";registerType(rawType,{name:name,\"fromWireType\":function(value){var length=HEAPU32[value>>>2];var str;if(stdStringIsUTF8){var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(i==length||HEAPU8[currentBytePtr>>>0]==0){var maxRead=currentBytePtr-decodeStartPtr;var stringSegment=UTF8ToString(decodeStartPtr,maxRead);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+1}}}else{var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i>>>0])}str=a.join(\"\")}_free(value);return str},\"toWireType\":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value)}var getLength;var valueIsOfTypeString=typeof value==\"string\";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError(\"Cannot pass non-string to std::string\")}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=()=>lengthBytesUTF8(value)}else{getLength=()=>value.length}var length=getLength();var ptr=_malloc(4+length+1);ptr>>>=0;HEAPU32[ptr>>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1)}else{if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\")}HEAPU8[ptr+4+i>>>0]=charCode}}else{for(var i=0;i<length;++i){HEAPU8[ptr+4+i>>>0]=value[i]}}}if(destructors!==null){destructors.push(_free,ptr)}return ptr},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr)}})}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var decodeString,encodeString,getHeap,lengthBytesUTF,shift;if(charSize===2){decodeString=UTF16ToString;encodeString=stringToUTF16;lengthBytesUTF=lengthBytesUTF16;getHeap=()=>HEAPU16;shift=1}else if(charSize===4){decodeString=UTF32ToString;encodeString=stringToUTF32;lengthBytesUTF=lengthBytesUTF32;getHeap=()=>HEAPU32;shift=2}registerType(rawType,{name:name,\"fromWireType\":function(value){var length=HEAPU32[value>>>2];var HEAP=getHeap();var str;var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i*charSize;if(i==length||HEAP[currentBytePtr>>>shift]==0){var maxReadBytes=currentBytePtr-decodeStartPtr;var stringSegment=decodeString(decodeStartPtr,maxReadBytes);if(str===undefined){str=stringSegment}else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+charSize}}_free(value);return str},\"toWireType\":function(destructors,value){if(!(typeof value==\"string\")){throwBindingError(\"Cannot pass non-string to C++ string type \"+name)}var length=lengthBytesUTF(value);var ptr=_malloc(4+length+charSize);ptr>>>=0;HEAPU32[ptr>>>2]=length>>shift;encodeString(value,ptr+4,length+charSize);if(destructors!==null){destructors.push(_free,ptr)}return ptr},\"argPackAdvance\":8,\"readValueFromPointer\":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr)}})}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,\"argPackAdvance\":0,\"fromWireType\":function(){return undefined},\"toWireType\":function(destructors,o){return undefined}})}function __emscripten_date_now(){return Date.now()}var nowIsMonotonic=true;function __emscripten_get_now_is_monotonic(){return nowIsMonotonic}function __emval_as(handle,returnType,destructorsRef){handle=Emval.toValue(handle);returnType=requireRegisteredType(returnType,\"emval::as\");var destructors=[];var rd=Emval.toHandle(destructors);HEAP32[destructorsRef>>>2]=rd;return returnType[\"toWireType\"](destructors,handle)}function emval_allocateDestructors(destructorsRef){var destructors=[];HEAP32[destructorsRef>>>2]=Emval.toHandle(destructors);return destructors}var emval_symbols={};function getStringOrSymbol(address){var symbol=emval_symbols[address];if(symbol===undefined){return readLatin1String(address)}return symbol}var emval_methodCallers=[];function __emval_call_method(caller,handle,methodName,destructorsRef,args){caller=emval_methodCallers[caller];handle=Emval.toValue(handle);methodName=getStringOrSymbol(methodName);return caller(handle,methodName,emval_allocateDestructors(destructorsRef),args)}function emval_get_global(){if(typeof globalThis==\"object\"){return globalThis}return function(){return Function}()(\"return this\")()}function __emval_get_global(name){if(name===0){return Emval.toHandle(emval_get_global())}else{name=getStringOrSymbol(name);return Emval.toHandle(emval_get_global()[name])}}function emval_addMethodCaller(caller){var id=emval_methodCallers.length;emval_methodCallers.push(caller);return id}function emval_lookupTypes(argCount,argTypes){var a=new Array(argCount);for(var i=0;i<argCount;++i){a[i]=requireRegisteredType(HEAPU32[argTypes+i*POINTER_SIZE>>>2],\"parameter \"+i)}return a}var emval_registeredMethods=[];function __emval_get_method_caller(argCount,argTypes){var types=emval_lookupTypes(argCount,argTypes);var retType=types[0];var signatureName=retType.name+\"_$\"+types.slice(1).map(function(t){return t.name}).join(\"_\")+\"$\";var returnId=emval_registeredMethods[signatureName];if(returnId!==undefined){return returnId}var params=[\"retType\"];var args=[retType];var argsList=\"\";for(var i=0;i<argCount-1;++i){argsList+=(i!==0?\", \":\"\")+\"arg\"+i;params.push(\"argType\"+i);args.push(types[1+i])}var functionName=makeLegalFunctionName(\"methodCaller_\"+signatureName);var functionBody=\"return function \"+functionName+\"(handle, name, destructors, args) {\\n\";var offset=0;for(var i=0;i<argCount-1;++i){functionBody+=\"    var arg\"+i+\" = argType\"+i+\".readValueFromPointer(args\"+(offset?\"+\"+offset:\"\")+\");\\n\";offset+=types[i+1][\"argPackAdvance\"]}functionBody+=\"    var rv = handle[name](\"+argsList+\");\\n\";for(var i=0;i<argCount-1;++i){if(types[i+1][\"deleteObject\"]){functionBody+=\"    argType\"+i+\".deleteObject(arg\"+i+\");\\n\"}}if(!retType.isVoid){functionBody+=\"    return retType.toWireType(destructors, rv);\\n\"}functionBody+=\"};\\n\";params.push(functionBody);var invokerFunction=new_(Function,params).apply(null,args);returnId=emval_addMethodCaller(invokerFunction);emval_registeredMethods[signatureName]=returnId;return returnId}function __emval_get_property(handle,key){handle=Emval.toValue(handle);key=Emval.toValue(key);return Emval.toHandle(handle[key])}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1}}function __emval_new_cstring(v){return Emval.toHandle(getStringOrSymbol(v))}function __emval_run_destructors(handle){var destructors=Emval.toValue(handle);runDestructors(destructors);__emval_decref(handle)}function __emval_set_property(handle,key,value){handle=Emval.toValue(handle);key=Emval.toValue(key);value=Emval.toValue(value);handle[key]=value}function __emval_take_value(type,argv){type=requireRegisteredType(type,\"_emval_take_value\");var v=type[\"readValueFromPointer\"](argv);return Emval.toHandle(v)}function __emval_typeof(handle){handle=Emval.toValue(handle);return Emval.toHandle(typeof handle)}function __localtime_js(time,tmPtr){var date=new Date(HEAP32[time>>>2]*1e3);HEAP32[tmPtr>>>2]=date.getSeconds();HEAP32[tmPtr+4>>>2]=date.getMinutes();HEAP32[tmPtr+8>>>2]=date.getHours();HEAP32[tmPtr+12>>>2]=date.getDate();HEAP32[tmPtr+16>>>2]=date.getMonth();HEAP32[tmPtr+20>>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>>2]=date.getDay();var start=new Date(date.getFullYear(),0,1);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>>2]=yday;HEAP32[tmPtr+36>>>2]=-(date.getTimezoneOffset()*60);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>>2]=dst}function __munmap_js(addr,len,prot,flags,fd,offset){try{addr>>>=0;var stream=FS.getStream(fd);if(stream){if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}FS.munmap(stream)}}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function _tzset_impl(timezone,daylight,tzname){var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAP32[timezone>>>2]=stdTimezoneOffset*60;HEAP32[daylight>>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/);return match?match[1]:\"GMT\"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){HEAPU32[tzname>>>2]=winterNamePtr;HEAPU32[tzname+4>>>2]=summerNamePtr}else{HEAPU32[tzname>>>2]=summerNamePtr;HEAPU32[tzname+4>>>2]=winterNamePtr}}function __tzset_js(timezone,daylight,tzname){if(__tzset_js.called)return;__tzset_js.called=true;_tzset_impl(timezone,daylight,tzname)}function _abort(){abort(\"\")}function getHeapMax(){return 4294901760}function _emscripten_get_heap_max(){return getHeapMax()}var _emscripten_get_now;_emscripten_get_now=()=>performance.now();function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest>>>0,src>>>0,src+num>>>0)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var ENV={};function getExecutableName(){return thisProgram||\"./this.program\"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={\"USER\":\"web_user\",\"LOGNAME\":\"web_user\",\"PATH\":\"/\",\"PWD\":\"/\",\"HOME\":\"/home/web_user\",\"LANG\":lang,\"_\":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+\"=\"+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAPU32[penviron_count>>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAPU32[penviron_buf_size>>>2]=bufSize;return 0}function _exit(status){exit(status)}function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function doReadv(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2];var len=HEAPU32[iov+4>>>2];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break}return ret}function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAP32[pnum>>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function convertI32PairToI53Checked(lo,hi){return hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{var offset=convertI32PairToI53Checked(offset_low,offset_high);if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>>2]=tempI64[0],HEAP32[newOffset+4>>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function doWritev(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2];var len=HEAPU32[iov+4>>>2];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr}return ret}function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function inetPton4(str){var b=str.split(\".\");for(var i=0;i<4;i++){var tmp=Number(b[i]);if(isNaN(tmp))return null;b[i]=tmp}return(b[0]|b[1]<<8|b[2]<<16|b[3]<<24)>>>0}function jstoi_q(str){return parseInt(str)}function inetPton6(str){var words;var w,offset,z;var valid6regx=/^((?=.*::)(?!.*::.+::)(::)?([\\dA-F]{1,4}:(:|\\b)|){5}|([\\dA-F]{1,4}:){6})((([\\dA-F]{1,4}((?!\\3)::|:\\b|$))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/i;var parts=[];if(!valid6regx.test(str)){return null}if(str===\"::\"){return[0,0,0,0,0,0,0,0]}if(str.startsWith(\"::\")){str=str.replace(\"::\",\"Z:\")}else{str=str.replace(\"::\",\":Z:\")}if(str.indexOf(\".\")>0){str=str.replace(new RegExp(\"[.]\",\"g\"),\":\");words=str.split(\":\");words[words.length-4]=jstoi_q(words[words.length-4])+jstoi_q(words[words.length-3])*256;words[words.length-3]=jstoi_q(words[words.length-2])+jstoi_q(words[words.length-1])*256;words=words.slice(0,words.length-2)}else{words=str.split(\":\")}offset=0;z=0;for(w=0;w<words.length;w++){if(typeof words[w]==\"string\"){if(words[w]===\"Z\"){for(z=0;z<8-words.length+1;z++){parts[w+z]=0}offset=z-1}else{parts[w+offset]=_htons(parseInt(words[w],16))}}else{parts[w+offset]=words[w]}}return[parts[1]<<16|parts[0],parts[3]<<16|parts[2],parts[5]<<16|parts[4],parts[7]<<16|parts[6]]}var DNS={address_map:{id:1,addrs:{},names:{}},lookup_name:function(name){var res=inetPton4(name);if(res!==null){return name}res=inetPton6(name);if(res!==null){return name}var addr;if(DNS.address_map.addrs[name]){addr=DNS.address_map.addrs[name]}else{var id=DNS.address_map.id++;assert(id<65535,\"exceeded max address mappings of 65535\");addr=\"172.29.\"+(id&255)+\".\"+(id&65280);DNS.address_map.names[addr]=name;DNS.address_map.addrs[name]=addr}return addr},lookup_addr:function(addr){if(DNS.address_map.names[addr]){return DNS.address_map.names[addr]}return null}};function getHostByName(name){var ret=_malloc(20);var nameBuf=_malloc(name.length+1);stringToUTF8(name,nameBuf,name.length+1);HEAPU32[ret>>>2]=nameBuf;var aliasesBuf=_malloc(4);HEAPU32[aliasesBuf>>>2]=0;HEAPU32[ret+4>>>2]=aliasesBuf;var afinet=2;HEAP32[ret+8>>>2]=afinet;HEAP32[ret+12>>>2]=4;var addrListBuf=_malloc(12);HEAPU32[addrListBuf>>>2]=addrListBuf+8;HEAPU32[addrListBuf+4>>>2]=0;HEAP32[addrListBuf+8>>>2]=inetPton4(DNS.lookup_name(name));HEAPU32[ret+16>>>2]=addrListBuf;return ret}function _gethostbyname(name){return getHostByName(UTF8ToString(name))}function __webgl_enable_ANGLE_instanced_arrays(ctx){var ext=ctx.getExtension(\"ANGLE_instanced_arrays\");if(ext){ctx[\"vertexAttribDivisor\"]=function(index,divisor){ext[\"vertexAttribDivisorANGLE\"](index,divisor)};ctx[\"drawArraysInstanced\"]=function(mode,first,count,primcount){ext[\"drawArraysInstancedANGLE\"](mode,first,count,primcount)};ctx[\"drawElementsInstanced\"]=function(mode,count,type,indices,primcount){ext[\"drawElementsInstancedANGLE\"](mode,count,type,indices,primcount)};return 1}}function __webgl_enable_OES_vertex_array_object(ctx){var ext=ctx.getExtension(\"OES_vertex_array_object\");if(ext){ctx[\"createVertexArray\"]=function(){return ext[\"createVertexArrayOES\"]()};ctx[\"deleteVertexArray\"]=function(vao){ext[\"deleteVertexArrayOES\"](vao)};ctx[\"bindVertexArray\"]=function(vao){ext[\"bindVertexArrayOES\"](vao)};ctx[\"isVertexArray\"]=function(vao){return ext[\"isVertexArrayOES\"](vao)};return 1}}function __webgl_enable_WEBGL_draw_buffers(ctx){var ext=ctx.getExtension(\"WEBGL_draw_buffers\");if(ext){ctx[\"drawBuffers\"]=function(n,bufs){ext[\"drawBuffersWEBGL\"](n,bufs)};return 1}}function __webgl_enable_WEBGL_multi_draw(ctx){return!!(ctx.multiDrawWebgl=ctx.getExtension(\"WEBGL_multi_draw\"))}var GL={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:[],offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function recordError(errorCode){if(!GL.lastError){GL.lastError=errorCode}},getNewId:function(table){var ret=GL.counter++;for(var i=table.length;i<ret;i++){table[i]=null}return ret},getSource:function(shader,count,string,length){var source=\"\";for(var i=0;i<count;++i){var len=length?HEAP32[length+i*4>>>2]:-1;source+=UTF8ToString(HEAP32[string+i*4>>>2],len<0?undefined:len)}return source},createContext:function(canvas,webGLContextAttributes){if(!canvas.getContextSafariWebGL2Fixed){canvas.getContextSafariWebGL2Fixed=canvas.getContext;function fixedGetContext(ver,attrs){var gl=canvas.getContextSafariWebGL2Fixed(ver,attrs);return ver==\"webgl\"==gl instanceof WebGLRenderingContext?gl:null}canvas.getContext=fixedGetContext}var ctx=canvas.getContext(\"webgl\",webGLContextAttributes);if(!ctx)return 0;var handle=GL.registerContext(ctx,webGLContextAttributes);return handle},registerContext:function(ctx,webGLContextAttributes){var handle=GL.getNewId(GL.contexts);var context={handle:handle,attributes:webGLContextAttributes,version:webGLContextAttributes.majorVersion,GLctx:ctx};if(ctx.canvas)ctx.canvas.GLctxObject=context;GL.contexts[handle]=context;if(typeof webGLContextAttributes.enableExtensionsByDefault==\"undefined\"||webGLContextAttributes.enableExtensionsByDefault){GL.initExtensions(context)}return handle},makeContextCurrent:function(contextHandle){GL.currentContext=GL.contexts[contextHandle];Module.ctx=GLctx=GL.currentContext&&GL.currentContext.GLctx;return!(contextHandle&&!GLctx)},getContext:function(contextHandle){return GL.contexts[contextHandle]},deleteContext:function(contextHandle){if(GL.currentContext===GL.contexts[contextHandle])GL.currentContext=null;if(typeof JSEvents==\"object\")JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);if(GL.contexts[contextHandle]&&GL.contexts[contextHandle].GLctx.canvas)GL.contexts[contextHandle].GLctx.canvas.GLctxObject=undefined;GL.contexts[contextHandle]=null},initExtensions:function(context){if(!context)context=GL.currentContext;if(context.initExtensionsDone)return;context.initExtensionsDone=true;var GLctx=context.GLctx;__webgl_enable_ANGLE_instanced_arrays(GLctx);__webgl_enable_OES_vertex_array_object(GLctx);__webgl_enable_WEBGL_draw_buffers(GLctx);{GLctx.disjointTimerQueryExt=GLctx.getExtension(\"EXT_disjoint_timer_query\")}__webgl_enable_WEBGL_multi_draw(GLctx);var exts=GLctx.getSupportedExtensions()||[];exts.forEach(function(ext){if(!ext.includes(\"lose_context\")&&!ext.includes(\"debug\")){GLctx.getExtension(ext)}})}};function webglGetLeftBracePos(name){return name.slice(-1)==\"]\"&&name.lastIndexOf(\"[\")}function webglPrepareUniformLocationsBeforeFirstUse(program){var uniformLocsById=program.uniformLocsById,uniformSizeAndIdsByName=program.uniformSizeAndIdsByName,i,j;if(!uniformLocsById){program.uniformLocsById=uniformLocsById={};program.uniformArrayNamesById={};for(i=0;i<GLctx.getProgramParameter(program,35718);++i){var u=GLctx.getActiveUniform(program,i);var nm=u.name;var sz=u.size;var lb=webglGetLeftBracePos(nm);var arrayName=lb>0?nm.slice(0,lb):nm;var id=program.uniformIdCounter;program.uniformIdCounter+=sz;uniformSizeAndIdsByName[arrayName]=[sz,id];for(j=0;j<sz;++j){uniformLocsById[id]=j;program.uniformArrayNamesById[id++]=arrayName}}}}function _glGetUniformLocation(program,name){name=UTF8ToString(name);if(program=GL.programs[program]){webglPrepareUniformLocationsBeforeFirstUse(program);var uniformLocsById=program.uniformLocsById;var arrayIndex=0;var uniformBaseName=name;var leftBrace=webglGetLeftBracePos(name);if(leftBrace>0){arrayIndex=jstoi_q(name.slice(leftBrace+1))>>>0;uniformBaseName=name.slice(0,leftBrace)}var sizeAndId=program.uniformSizeAndIdsByName[uniformBaseName];if(sizeAndId&&arrayIndex<sizeAndId[0]){arrayIndex+=sizeAndId[1];if(uniformLocsById[arrayIndex]=uniformLocsById[arrayIndex]||GLctx.getUniformLocation(program,name)){return arrayIndex}}}else{GL.recordError(1281)}return-1}function webglGetUniformLocation(location){var p=GLctx.currentProgram;if(p){var webglLoc=p.uniformLocsById[location];if(typeof webglLoc==\"number\"){p.uniformLocsById[location]=webglLoc=GLctx.getUniformLocation(p,p.uniformArrayNamesById[location]+(webglLoc>0?\"[\"+webglLoc+\"]\":\"\"))}return webglLoc}else{GL.recordError(1282)}}function _glUniform1f(location,v0){GLctx.uniform1f(webglGetUniformLocation(location),v0)}function _glUniform1i(location,v0){GLctx.uniform1i(webglGetUniformLocation(location),v0)}var miniTempWebGLFloatBuffers=[];function _glUniform2fv(location,count,value){if(count<=144){var view=miniTempWebGLFloatBuffers[2*count-1];for(var i=0;i<2*count;i+=2){view[i]=HEAPF32[value+4*i>>>2];view[i+1]=HEAPF32[value+(4*i+4)>>>2]}}else{var view=HEAPF32.subarray(value>>>2,value+count*8>>>2)}GLctx.uniform2fv(webglGetUniformLocation(location),view)}var __miniTempWebGLIntBuffers=[];function _glUniform2iv(location,count,value){if(count<=144){var view=__miniTempWebGLIntBuffers[2*count-1];for(var i=0;i<2*count;i+=2){view[i]=HEAP32[value+4*i>>>2];view[i+1]=HEAP32[value+(4*i+4)>>>2]}}else{var view=HEAP32.subarray(value>>>2,value+count*8>>>2)}GLctx.uniform2iv(webglGetUniformLocation(location),view)}function _glUniform3fv(location,count,value){if(count<=96){var view=miniTempWebGLFloatBuffers[3*count-1];for(var i=0;i<3*count;i+=3){view[i]=HEAPF32[value+4*i>>>2];view[i+1]=HEAPF32[value+(4*i+4)>>>2];view[i+2]=HEAPF32[value+(4*i+8)>>>2]}}else{var view=HEAPF32.subarray(value>>>2,value+count*12>>>2)}GLctx.uniform3fv(webglGetUniformLocation(location),view)}function _glUniform3iv(location,count,value){if(count<=96){var view=__miniTempWebGLIntBuffers[3*count-1];for(var i=0;i<3*count;i+=3){view[i]=HEAP32[value+4*i>>>2];view[i+1]=HEAP32[value+(4*i+4)>>>2];view[i+2]=HEAP32[value+(4*i+8)>>>2]}}else{var view=HEAP32.subarray(value>>>2,value+count*12>>>2)}GLctx.uniform3iv(webglGetUniformLocation(location),view)}function _glUniform4fv(location,count,value){if(count<=72){var view=miniTempWebGLFloatBuffers[4*count-1];var heap=HEAPF32;value>>=2;for(var i=0;i<4*count;i+=4){var dst=value+i;view[i]=heap[dst>>>0];view[i+1]=heap[dst+1>>>0];view[i+2]=heap[dst+2>>>0];view[i+3]=heap[dst+3>>>0]}}else{var view=HEAPF32.subarray(value>>>2,value+count*16>>>2)}GLctx.uniform4fv(webglGetUniformLocation(location),view)}function _glUniform4iv(location,count,value){if(count<=72){var view=__miniTempWebGLIntBuffers[4*count-1];for(var i=0;i<4*count;i+=4){view[i]=HEAP32[value+4*i>>>2];view[i+1]=HEAP32[value+(4*i+4)>>>2];view[i+2]=HEAP32[value+(4*i+8)>>>2];view[i+3]=HEAP32[value+(4*i+12)>>>2]}}else{var view=HEAP32.subarray(value>>>2,value+count*16>>>2)}GLctx.uniform4iv(webglGetUniformLocation(location),view)}function _setTempRet0(val){setTempRet0(val)}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>>2];var date={tm_sec:HEAP32[tm>>>2],tm_min:HEAP32[tm+4>>>2],tm_hour:HEAP32[tm+8>>>2],tm_mday:HEAP32[tm+12>>>2],tm_mon:HEAP32[tm+16>>>2],tm_year:HEAP32[tm+20>>>2],tm_wday:HEAP32[tm+24>>>2],tm_yday:HEAP32[tm+28>>>2],tm_isdst:HEAP32[tm+32>>>2],tm_gmtoff:HEAP32[tm+36>>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):\"\"};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,\"g\"),EXPANSION_RULES_1[rule])}var WEEKDAYS=[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"];var MONTHS=[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"];function leadingSomething(value,digits,character){var str=typeof value==\"number\"?value.toString():value||\"\";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,\"0\")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else{return thisDate.getFullYear()}}else{return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={\"%a\":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},\"%A\":function(date){return WEEKDAYS[date.tm_wday]},\"%b\":function(date){return MONTHS[date.tm_mon].substring(0,3)},\"%B\":function(date){return MONTHS[date.tm_mon]},\"%C\":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},\"%d\":function(date){return leadingNulls(date.tm_mday,2)},\"%e\":function(date){return leadingSomething(date.tm_mday,2,\" \")},\"%g\":function(date){return getWeekBasedYear(date).toString().substring(2)},\"%G\":function(date){return getWeekBasedYear(date)},\"%H\":function(date){return leadingNulls(date.tm_hour,2)},\"%I\":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},\"%j\":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},\"%m\":function(date){return leadingNulls(date.tm_mon+1,2)},\"%M\":function(date){return leadingNulls(date.tm_min,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return\"AM\"}else{return\"PM\"}},\"%S\":function(date){return leadingNulls(date.tm_sec,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(date){return date.tm_wday||7},\"%U\":function(date){var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},\"%V\":function(date){var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&__isLeapYear(date.tm_year%400-1)){val++}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!__isLeapYear(date.tm_year)))val=1}return leadingNulls(val,2)},\"%w\":function(date){return date.tm_wday},\"%W\":function(date){var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},\"%y\":function(date){return(date.tm_year+1900).toString().substring(2)},\"%Y\":function(date){return date.tm_year+1900},\"%z\":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?\"+\":\"-\")+String(\"0000\"+off).slice(-4)},\"%Z\":function(date){return date.tm_zone},\"%%\":function(){return\"%\"}};pattern=pattern.replace(/%%/g,\"\\0\\0\");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,\"g\"),EXPANSION_RULES_2[rule](date))}}pattern=pattern.replace(/\\0\\0/g,\"%\");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}var FSNode=function(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev};var readMode=292|73;var writeMode=146;Object.defineProperties(FSNode.prototype,{read:{get:function(){return(this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode}},write:{get:function(){return(this.mode&writeMode)===writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}});FS.FSNode=FSNode;FS.staticInit();embind_init_charCodes();BindingError=Module[\"BindingError\"]=extendError(Error,\"BindingError\");InternalError=Module[\"InternalError\"]=extendError(Error,\"InternalError\");init_ClassHandle();init_embind();init_RegisteredPointer();UnboundTypeError=Module[\"UnboundTypeError\"]=extendError(Error,\"UnboundTypeError\");init_emval();var GLctx;var miniTempWebGLFloatBuffersStorage=new Float32Array(288);for(var i=0;i<288;++i){miniTempWebGLFloatBuffers[i]=miniTempWebGLFloatBuffersStorage.subarray(0,i+1)}var __miniTempWebGLIntBuffersStorage=new Int32Array(288);for(var i=0;i<288;++i){__miniTempWebGLIntBuffers[i]=__miniTempWebGLIntBuffersStorage.subarray(0,i+1)}function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var asmLibraryArg={\"ga\":OSD_MemInfo_getModuleHeapLength,\"i\":___assert_fail,\"a\":___cxa_allocate_exception,\"b\":___cxa_throw,\"R\":___syscall_chmod,\"S\":___syscall_faccessat,\"q\":___syscall_fcntl64,\"K\":___syscall_fstat64,\"V\":___syscall_ioctl,\"I\":___syscall_lstat64,\"H\":___syscall_newfstatat,\"u\":___syscall_openat,\"J\":___syscall_stat64,\"z\":__embind_register_bigint,\"X\":__embind_register_bool,\"d\":__embind_register_class,\"f\":__embind_register_class_class_function,\"e\":__embind_register_class_constructor,\"c\":__embind_register_class_function,\"W\":__embind_register_emval,\"k\":__embind_register_enum,\"j\":__embind_register_enum_value,\"v\":__embind_register_float,\"h\":__embind_register_integer,\"g\":__embind_register_memory_view,\"w\":__embind_register_std_string,\"r\":__embind_register_std_wstring,\"Y\":__embind_register_void,\"N\":__emscripten_date_now,\"M\":__emscripten_get_now_is_monotonic,\"l\":__emval_as,\"la\":__emval_call_method,\"E\":__emval_decref,\"ma\":__emval_get_global,\"ka\":__emval_get_method_caller,\"s\":__emval_get_property,\"O\":__emval_incref,\"ja\":__emval_new_cstring,\"na\":__emval_run_destructors,\"n\":__emval_set_property,\"m\":__emval_take_value,\"x\":__emval_typeof,\"P\":__localtime_js,\"D\":__munmap_js,\"Q\":__tzset_js,\"t\":_abort,\"C\":_emscripten_get_heap_max,\"L\":_emscripten_memcpy_big,\"o\":_emscripten_resize_heap,\"F\":_environ_get,\"G\":_environ_sizes_get,\"ha\":_exit,\"p\":_fd_close,\"U\":_fd_read,\"y\":_fd_seek,\"T\":_fd_write,\"ia\":_gethostbyname,\"fa\":_glGetUniformLocation,\"da\":_glUniform1f,\"ea\":_glUniform1i,\"$\":_glUniform2fv,\"ca\":_glUniform2iv,\"_\":_glUniform3fv,\"ba\":_glUniform3iv,\"Z\":_glUniform4fv,\"aa\":_glUniform4iv,\"A\":_setTempRet0,\"B\":_strftime_l};var asm=createWasm();var ___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=function(){return(___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=Module[\"asm\"][\"pa\"]).apply(null,arguments)};var _malloc=Module[\"_malloc\"]=function(){return(_malloc=Module[\"_malloc\"]=Module[\"asm\"][\"qa\"]).apply(null,arguments)};var ___errno_location=Module[\"___errno_location\"]=function(){return(___errno_location=Module[\"___errno_location\"]=Module[\"asm\"][\"ra\"]).apply(null,arguments)};var _free=Module[\"_free\"]=function(){return(_free=Module[\"_free\"]=Module[\"asm\"][\"sa\"]).apply(null,arguments)};var ___getTypeName=Module[\"___getTypeName\"]=function(){return(___getTypeName=Module[\"___getTypeName\"]=Module[\"asm\"][\"ta\"]).apply(null,arguments)};var ___embind_register_native_and_builtin_types=Module[\"___embind_register_native_and_builtin_types\"]=function(){return(___embind_register_native_and_builtin_types=Module[\"___embind_register_native_and_builtin_types\"]=Module[\"asm\"][\"ua\"]).apply(null,arguments)};var _htons=Module[\"_htons\"]=function(){return(_htons=Module[\"_htons\"]=Module[\"asm\"][\"wa\"]).apply(null,arguments)};var _emscripten_builtin_memalign=Module[\"_emscripten_builtin_memalign\"]=function(){return(_emscripten_builtin_memalign=Module[\"_emscripten_builtin_memalign\"]=Module[\"asm\"][\"xa\"]).apply(null,arguments)};var ___cxa_is_pointer_type=Module[\"___cxa_is_pointer_type\"]=function(){return(___cxa_is_pointer_type=Module[\"___cxa_is_pointer_type\"]=Module[\"asm\"][\"ya\"]).apply(null,arguments)};var dynCall_jiji=Module[\"dynCall_jiji\"]=function(){return(dynCall_jiji=Module[\"dynCall_jiji\"]=Module[\"asm\"][\"za\"]).apply(null,arguments)};var dynCall_viiiiji=Module[\"dynCall_viiiiji\"]=function(){return(dynCall_viiiiji=Module[\"dynCall_viiiiji\"]=Module[\"asm\"][\"Aa\"]).apply(null,arguments)};var dynCall_viijii=Module[\"dynCall_viijii\"]=function(){return(dynCall_viijii=Module[\"dynCall_viijii\"]=Module[\"asm\"][\"Ba\"]).apply(null,arguments)};var dynCall_iiiiij=Module[\"dynCall_iiiiij\"]=function(){return(dynCall_iiiiij=Module[\"dynCall_iiiiij\"]=Module[\"asm\"][\"Ca\"]).apply(null,arguments)};var dynCall_iiiiijj=Module[\"dynCall_iiiiijj\"]=function(){return(dynCall_iiiiijj=Module[\"dynCall_iiiiijj\"]=Module[\"asm\"][\"Da\"]).apply(null,arguments)};var dynCall_iiiiiijj=Module[\"dynCall_iiiiiijj\"]=function(){return(dynCall_iiiiiijj=Module[\"dynCall_iiiiiijj\"]=Module[\"asm\"][\"Ea\"]).apply(null,arguments)};Module[\"FS\"]=FS;var calledRun;function ExitStatus(status){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+status+\")\";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(function(){setTimeout(function(){Module[\"setStatus\"](\"\")},1);doRun()},1)}else{doRun()}}Module[\"run\"]=run;function exit(status,implicit){EXITSTATUS=status;procExit(status)}function procExit(code){EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module[\"onExit\"])Module[\"onExit\"](code);ABORT=true}quit_(code,new ExitStatus(code))}if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}run();\n\n\n  return Module.ready\n}\n);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../opencascade/lib/jupytercad.opencascade.js?\n}");

/***/ },

/***/ "../opencascade/lib/jupytercad.opencascade.wasm"
/*!******************************************************!*\
  !*** ../opencascade/lib/jupytercad.opencascade.wasm ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"jupytercad.opencascade.wasm\");\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../opencascade/lib/jupytercad.opencascade.wasm?\n}");

/***/ },

/***/ "../schema/lib/_interface/version.js"
/*!*******************************************!*\
  !*** ../schema/lib/_interface/version.js ***!
  \*******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SCHEMA_VERSION: () => (/* binding */ SCHEMA_VERSION)\n/* harmony export */ });\nconst SCHEMA_VERSION = '3.0.0';\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../schema/lib/_interface/version.js?\n}");

/***/ },

/***/ "../schema/lib/doc.js"
/*!****************************!*\
  !*** ../schema/lib/doc.js ***!
  \****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JupyterCadDoc: () => (/* binding */ JupyterCadDoc)\n/* harmony export */ });\n/* harmony import */ var _jupyter_ydoc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyter/ydoc */ \"../../node_modules/@jupyter/ydoc/lib/index.js\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ \"../../node_modules/@lumino/coreutils/dist/index.js\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ \"../../node_modules/@lumino/signaling/dist/index.es6.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"../../node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _interface_version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_interface/version */ \"../schema/lib/_interface/version.js\");\n\n\n\n\n\nclass JupyterCadDoc extends _jupyter_ydoc__WEBPACK_IMPORTED_MODULE_0__.YDocument {\n    constructor() {\n        super();\n        this.editable = true;\n        this._objectsObserver = (events) => {\n            const changes = [];\n            let needEmit = false;\n            events.forEach(event => {\n                const name = event.target.get('name');\n                if (name) {\n                    event.keys.forEach((change, key) => {\n                        if (!needEmit && key !== 'shapeMetadata') {\n                            needEmit = true;\n                        }\n                        changes.push({\n                            name,\n                            key: key,\n                            newValue: _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepCopy(event.target.toJSON())\n                        });\n                    });\n                }\n            });\n            needEmit = changes.length === 0 ? true : needEmit;\n            if (needEmit) {\n                this._objectsChanged.emit({ objectChange: changes });\n            }\n            this._changed.emit({ objectChange: changes });\n        };\n        this._metaObserver = (event) => {\n            const changes = new Map();\n            event.changes.keys.forEach((event, key) => {\n                changes.set(key, {\n                    action: event.action,\n                    oldValue: event.oldValue,\n                    newValue: this._metadata.get(key)\n                });\n            });\n            this._metadataChanged.emit(changes);\n        };\n        this._optionsObserver = (event) => {\n            const changes = new Map();\n            event.changes.keys.forEach((event, key) => {\n                changes.set(key, {\n                    action: event.action,\n                    oldValue: event.oldValue,\n                    newValue: this._options.get(key)\n                });\n            });\n            this._optionsChanged.emit(changes);\n        };\n        this._metadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this._optionsChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this._objectsChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);\n        this._options = this.ydoc.getMap('options');\n        this._objects = this.ydoc.getArray('objects');\n        this._metadata = this.ydoc.getMap('metadata');\n        this._outputs = this.ydoc.getMap('outputs');\n        this.undoManager.addToScope(this._objects);\n        this._objects.observeDeep(this._objectsObserver);\n        this._metadata.observe(this._metaObserver);\n        this._options.observe(this._optionsObserver);\n    }\n    dispose() {\n        super.dispose();\n    }\n    get version() {\n        return _interface_version__WEBPACK_IMPORTED_MODULE_4__.SCHEMA_VERSION;\n    }\n    get objects() {\n        const objs = this._objects.map(obj => _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepCopy(obj.toJSON()));\n        return objs;\n    }\n    get options() {\n        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepCopy(this._options.toJSON());\n    }\n    get metadata() {\n        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepCopy(this._metadata.toJSON());\n    }\n    get outputs() {\n        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepCopy(this._outputs.toJSON());\n    }\n    get objectsChanged() {\n        return this._objectsChanged;\n    }\n    get optionsChanged() {\n        return this._optionsChanged;\n    }\n    getSource() {\n        const objects = this._objects.toJSON();\n        const options = this._options.toJSON();\n        const metadata = this._metadata.toJSON();\n        const outputs = this._outputs.toJSON();\n        return { objects, options, metadata, outputs };\n    }\n    setSource(source) {\n        if (!source) {\n            return;\n        }\n        let value;\n        if (typeof source === 'string') {\n            value = JSON.parse(source);\n        }\n        else {\n            value = source;\n        }\n        this.transact(() => {\n            var _a, _b, _c, _d;\n            const objects = ((_a = value['objects']) !== null && _a !== void 0 ? _a : []);\n            objects.forEach(obj => {\n                this._objects.push([new yjs__WEBPACK_IMPORTED_MODULE_3__.Map(Object.entries(obj))]);\n            });\n            const options = (_b = value['options']) !== null && _b !== void 0 ? _b : {};\n            Object.entries(options).forEach(([key, val]) => this._options.set(key, val));\n            const metadata = (_c = value['metadata']) !== null && _c !== void 0 ? _c : {};\n            Object.entries(metadata).forEach(([key, val]) => this._metadata.set(key, val));\n            const outputs = (_d = value['outputs']) !== null && _d !== void 0 ? _d : {};\n            Object.entries(outputs).forEach(([key, val]) => this._outputs.set(key, val));\n        });\n    }\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    objectExists(name) {\n        return Boolean(this._getObjectAsYMapByName(name));\n    }\n    getObjectByName(name) {\n        const obj = this._getObjectAsYMapByName(name);\n        if (obj) {\n            return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepCopy(obj.toJSON());\n        }\n        return undefined;\n    }\n    getDependants(name) {\n        const dependants = [];\n        const dependantMap = new Map();\n        for (const obj of this._objects) {\n            const deps = obj.get('dependencies') || [];\n            const objName = obj.get('name');\n            deps.forEach(dep => {\n                const currentSet = dependantMap.get(dep);\n                if (currentSet) {\n                    currentSet.add(objName);\n                }\n                else {\n                    dependantMap.set(dep, new Set([objName]));\n                }\n            });\n        }\n        const selectedDeps = dependantMap.get(name);\n        if (!selectedDeps) {\n            return [];\n        }\n        while (selectedDeps.size) {\n            const depsList = [...selectedDeps];\n            depsList.forEach(it => {\n                var _a;\n                dependants.push(it);\n                selectedDeps.delete(it);\n                (_a = dependantMap.get(it)) === null || _a === void 0 ? void 0 : _a.forEach(newIt => selectedDeps.add(newIt));\n            });\n        }\n        return dependants;\n    }\n    removeObjects(names) {\n        this.transact(() => {\n            for (const name of names) {\n                this.removeObjectByName(name);\n            }\n        });\n    }\n    removeObjectByName(name) {\n        // Get object index\n        let index = 0;\n        for (const obj of this._objects) {\n            if (obj.get('name') === name) {\n                break;\n            }\n            index++;\n        }\n        if (this._objects.length > index) {\n            this._objects.delete(index);\n            this.removeOutput(name);\n        }\n    }\n    addObject(value) {\n        this.addObjects([value]);\n    }\n    addObjects(value) {\n        this.transact(() => {\n            value.map(obj => {\n                if (!this.objectExists(obj.name)) {\n                    this._objects.push([new yjs__WEBPACK_IMPORTED_MODULE_3__.Map(Object.entries(obj))]);\n                }\n                else {\n                    console.error('There is already an object with the name:', obj.name);\n                }\n            });\n        });\n    }\n    updateObjectByName(name, payload) {\n        const obj = this._getObjectAsYMapByName(name);\n        if (!obj) {\n            return;\n        }\n        const { key, value } = payload.data;\n        this.transact(() => {\n            // Special case for changing parameters, we may need to update dependencies\n            if (key === 'parameters') {\n                switch (obj.get('shape')) {\n                    case 'Part::Cut': {\n                        obj.set('dependencies', [value['Base'], value['Tool']]);\n                        break;\n                    }\n                    case 'Part::Extrusion':\n                    case 'Part::Fillet':\n                    case 'Part::Chamfer': {\n                        obj.set('dependencies', [value['Base']]);\n                        break;\n                    }\n                    case 'Part::MultiCommon':\n                    case 'Part::MultiFuse': {\n                        obj.set('dependencies', value['Shapes']);\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            }\n            obj.set(key, value);\n            if (payload.meta) {\n                obj.set('shapeMetadata', payload.meta);\n            }\n        });\n    }\n    getOption(key) {\n        const content = this._options.get(key);\n        if (!content) {\n            return;\n        }\n        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.deepCopy(content);\n    }\n    setOption(key, value) {\n        this.transact(() => void this._options.set(key, value));\n    }\n    setOptions(options) {\n        this.transact(() => {\n            for (const [key, value] of Object.entries(options)) {\n                this._options.set(key, value);\n            }\n        });\n    }\n    getMetadata(key) {\n        return this._metadata.get(key);\n    }\n    setMetadata(key, value) {\n        this.transact(() => void this._metadata.set(key, value));\n    }\n    removeMetadata(key) {\n        if (this._metadata.has(key)) {\n            this._metadata.delete(key);\n        }\n    }\n    getOutput(key) {\n        return this._outputs.get(key);\n    }\n    setOutput(key, value) {\n        this.transact(() => void this._outputs.set(key, value));\n    }\n    removeOutput(key) {\n        if (this._outputs.has(key)) {\n            this._outputs.delete(key);\n        }\n    }\n    setShapeMeta(name, meta) {\n        const obj = this._getObjectAsYMapByName(name);\n        if (meta && obj) {\n            this.transact(() => void obj.set('shapeMetadata', meta));\n        }\n    }\n    static create() {\n        return new JupyterCadDoc();\n    }\n    _getObjectAsYMapByName(name) {\n        for (const obj of this._objects) {\n            if (obj.get('name') === name) {\n                return obj;\n            }\n        }\n        return undefined;\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../schema/lib/doc.js?\n}");

/***/ },

/***/ "../schema/lib/index.js"
/*!******************************!*\
  !*** ../schema/lib/index.js ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IAnnotationToken: () => (/* reexport safe */ _token__WEBPACK_IMPORTED_MODULE_2__.IAnnotationToken),\n/* harmony export */   IJCadExternalCommandRegistryToken: () => (/* reexport safe */ _token__WEBPACK_IMPORTED_MODULE_2__.IJCadExternalCommandRegistryToken),\n/* harmony export */   IJCadFormSchemaRegistryToken: () => (/* reexport safe */ _token__WEBPACK_IMPORTED_MODULE_2__.IJCadFormSchemaRegistryToken),\n/* harmony export */   IJCadWorkerRegistryToken: () => (/* reexport safe */ _token__WEBPACK_IMPORTED_MODULE_2__.IJCadWorkerRegistryToken),\n/* harmony export */   IJupyterCadDocTracker: () => (/* reexport safe */ _token__WEBPACK_IMPORTED_MODULE_2__.IJupyterCadDocTracker),\n/* harmony export */   JCadWorkerSupportedFormat: () => (/* reexport safe */ _interfaces__WEBPACK_IMPORTED_MODULE_0__.JCadWorkerSupportedFormat),\n/* harmony export */   JupyterCadDoc: () => (/* reexport safe */ _doc__WEBPACK_IMPORTED_MODULE_3__.JupyterCadDoc),\n/* harmony export */   JupyterCadModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_1__.JupyterCadModel),\n/* harmony export */   MainAction: () => (/* reexport safe */ _interfaces__WEBPACK_IMPORTED_MODULE_0__.MainAction),\n/* harmony export */   SCHEMA_VERSION: () => (/* reexport safe */ _interface_version__WEBPACK_IMPORTED_MODULE_4__.SCHEMA_VERSION),\n/* harmony export */   WorkerAction: () => (/* reexport safe */ _interfaces__WEBPACK_IMPORTED_MODULE_0__.WorkerAction)\n/* harmony export */ });\n/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interfaces */ \"../schema/lib/interfaces.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ \"../schema/lib/model.js\");\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./token */ \"../schema/lib/token.js\");\n/* harmony import */ var _doc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./doc */ \"../schema/lib/doc.js\");\n/* harmony import */ var _interface_version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_interface/version */ \"../schema/lib/_interface/version.js\");\n\n\n\n\n\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../schema/lib/index.js?\n}");

/***/ },

/***/ "../schema/lib/interfaces.js"
/*!***********************************!*\
  !*** ../schema/lib/interfaces.js ***!
  \***********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JCadWorkerSupportedFormat: () => (/* binding */ JCadWorkerSupportedFormat),\n/* harmony export */   MainAction: () => (/* binding */ MainAction),\n/* harmony export */   WorkerAction: () => (/* binding */ WorkerAction)\n/* harmony export */ });\n/**\n * Action definitions for worker\n */\nvar WorkerAction;\n(function (WorkerAction) {\n    WorkerAction[\"DRY_RUN\"] = \"DRY_RUN\";\n    WorkerAction[\"LOAD_FILE\"] = \"LOAD_FILE\";\n    WorkerAction[\"SAVE_FILE\"] = \"SAVE_FILE\";\n    WorkerAction[\"REGISTER\"] = \"REGISTER\";\n    WorkerAction[\"POSTPROCESS\"] = \"POSTPROCESS\";\n})(WorkerAction || (WorkerAction = {}));\n/**\n * Action definitions for main thread\n */\nvar MainAction;\n(function (MainAction) {\n    MainAction[\"DISPLAY_SHAPE\"] = \"DISPLAY_SHAPE\";\n    MainAction[\"INITIALIZED\"] = \"INITIALIZED\";\n    MainAction[\"DISPLAY_POST\"] = \"DISPLAY_POST\";\n    MainAction[\"DRY_RUN_RESPONSE\"] = \"DRY_RUN_RESPONSE\";\n})(MainAction || (MainAction = {}));\nvar JCadWorkerSupportedFormat;\n(function (JCadWorkerSupportedFormat) {\n    JCadWorkerSupportedFormat[\"BREP\"] = \"BREP\";\n    JCadWorkerSupportedFormat[\"GLTF\"] = \"GLTF\";\n    JCadWorkerSupportedFormat[\"STL\"] = \"STL\";\n})(JCadWorkerSupportedFormat || (JCadWorkerSupportedFormat = {}));\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../schema/lib/interfaces.js?\n}");

/***/ },

/***/ "../schema/lib/model.js"
/*!******************************!*\
  !*** ../schema/lib/model.js ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JupyterCadModel: () => (/* binding */ JupyterCadModel)\n/* harmony export */ });\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ \"../../node_modules/@lumino/signaling/dist/index.es6.js\");\n/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ajv */ \"../../node_modules/ajv/dist/ajv.js\");\n/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ajv__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _doc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./doc */ \"../schema/lib/doc.js\");\n/* harmony import */ var _schema_jcad_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schema/jcad.json */ \"../schema/lib/schema/jcad.json\");\n\n\n\n\nconst SETTINGS_ID = '@jupytercad/jupytercad-core:jupytercad-settings';\nclass JupyterCadModel {\n    constructor(options) {\n        this.collaborative = true;\n        this._onSharedModelChanged = (sender, changes) => {\n            var _a;\n            if (changes && ((_a = changes === null || changes === void 0 ? void 0 : changes.objectChange) === null || _a === void 0 ? void 0 : _a.length)) {\n                this._contentChanged.emit(void 0);\n                this.dirty = true;\n            }\n        };\n        this._onClientStateChanged = changed => {\n            const clients = this.sharedModel.awareness.getStates();\n            this._clientStateChanged.emit(clients);\n            if (changed.added.length || changed.removed.length) {\n                this._userChanged.emit(this.users);\n            }\n        };\n        this.defaultKernelName = '';\n        this.defaultKernelLanguage = '';\n        this._dirty = false;\n        this._readOnly = false;\n        this._isDisposed = false;\n        this._jcadSettings = {\n            showAxesHelper: false,\n            cameraType: 'Perspective'\n        };\n        this._userChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._contentChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._stateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._themeChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._clientStateChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._sharedMetadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._sharedOptionsChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._sharedObjectsChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._sharedModelSwapped = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        const { annotationModel, sharedModel, settingRegistry } = options;\n        if (sharedModel) {\n            this._sharedModel = sharedModel;\n        }\n        else {\n            this._sharedModel = this.createSharedModel();\n        }\n        this._connectSignal();\n        this.annotationModel = annotationModel;\n        this.settingRegistry = settingRegistry;\n        this._copiedObject = null;\n        this._pathChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n        this._settingsChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);\n    }\n    /**\n     * Initialize custom settings for JupyterLab.\n     */\n    async initSettings() {\n        if (this.settingRegistry) {\n            try {\n                const setting = await this.settingRegistry.load(SETTINGS_ID);\n                this._settings = setting;\n                this._updateLocalSettings();\n                setting.changed.connect(this._onSettingsChanged, this);\n            }\n            catch (error) {\n                console.error(`Failed to load settings for ${SETTINGS_ID}:`, error);\n                this._jcadSettings = {\n                    showAxesHelper: false,\n                    cameraType: 'Perspective'\n                };\n            }\n        }\n        else {\n            this._jcadSettings = {\n                showAxesHelper: false,\n                cameraType: 'Perspective'\n            };\n        }\n    }\n    _onSettingsChanged() {\n        const oldSettings = this._jcadSettings;\n        this._updateLocalSettings();\n        const newSettings = this._jcadSettings;\n        if (oldSettings.showAxesHelper !== newSettings.showAxesHelper) {\n            this._settingsChanged.emit('showAxesHelper');\n        }\n        if (oldSettings.cameraType !== newSettings.cameraType) {\n            this._settingsChanged.emit('cameraType');\n        }\n    }\n    _updateLocalSettings() {\n        var _a, _b;\n        const composite = this._settings.composite;\n        this._jcadSettings = {\n            showAxesHelper: (_a = composite.showAxesHelper) !== null && _a !== void 0 ? _a : false,\n            cameraType: (_b = composite.cameraType) !== null && _b !== void 0 ? _b : 'Perspective'\n        };\n    }\n    get jcadSettings() {\n        return this._jcadSettings;\n    }\n    /**\n     * Expose the settingsChanged signal for external use.\n     */\n    get settingsChanged() {\n        return this._settingsChanged;\n    }\n    emitSettingChanged(settingName) {\n        this._settingsChanged.emit(settingName);\n    }\n    /**\n     * Return stored settings.\n     */\n    async getSettings() {\n        return this._settings;\n    }\n    get sharedModel() {\n        return this._sharedModel;\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    get contentChanged() {\n        return this._contentChanged;\n    }\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    get themeChanged() {\n        return this._themeChanged;\n    }\n    get currentUserId() {\n        var _a;\n        return (_a = this.sharedModel) === null || _a === void 0 ? void 0 : _a.awareness.clientID;\n    }\n    get users() {\n        var _a;\n        this._usersMap = (_a = this.sharedModel) === null || _a === void 0 ? void 0 : _a.awareness.getStates();\n        const users = [];\n        if (this._usersMap) {\n            this._usersMap.forEach((val, key) => {\n                users.push({ userId: key, userData: val.user });\n            });\n        }\n        return users;\n    }\n    get userChanged() {\n        return this._userChanged;\n    }\n    get dirty() {\n        return this._dirty;\n    }\n    set dirty(value) {\n        this._dirty = value;\n    }\n    get readOnly() {\n        return this._readOnly;\n    }\n    set readOnly(value) {\n        this._readOnly = value;\n    }\n    get localState() {\n        return this.sharedModel.awareness.getLocalState();\n    }\n    /**\n     * Getter for the contents manager.\n     */\n    get contentsManager() {\n        return this._contentsManager;\n    }\n    /**\n     * Setter for the contents manager.\n     * Also updates the file path.\n     */\n    set contentsManager(manager) {\n        this._contentsManager = manager;\n    }\n    get clientStateChanged() {\n        return this._clientStateChanged;\n    }\n    get sharedMetadataChanged() {\n        return this._sharedMetadataChanged;\n    }\n    get sharedOptionsChanged() {\n        return this._sharedOptionsChanged;\n    }\n    get sharedObjectsChanged() {\n        return this._sharedObjectsChanged;\n    }\n    get sharedModelSwapped() {\n        return this._sharedModelSwapped;\n    }\n    /**\n     * Getter for the file path associated with the contents manager.\n     */\n    get filePath() {\n        return this._filePath;\n    }\n    /**\n     * Setter for the file path associated with the contents manager.\n     */\n    set filePath(path) {\n        this._filePath = path;\n        this._pathChanged.emit(path);\n    }\n    get pathChanged() {\n        return this._pathChanged;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    swapSharedModel(newSharedModel) {\n        this._disconnectSignal();\n        this._sharedModel.dispose();\n        this._sharedModel = newSharedModel;\n        this._connectSignal();\n        this._sharedObjectsChanged.emit({ objectChange: [] });\n        this._sharedModelSwapped.emit();\n    }\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disconnectSignal();\n        this._sharedModel.dispose();\n        this._disposed.emit();\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal.clearData(this);\n    }\n    toString() {\n        return JSON.stringify(this.getContent(), null, 2);\n    }\n    fromString(data) {\n        const jsonData = JSON.parse(data);\n        const ajv = new (ajv__WEBPACK_IMPORTED_MODULE_1___default())();\n        const validate = ajv.compile(_schema_jcad_json__WEBPACK_IMPORTED_MODULE_3__);\n        const valid = validate(jsonData);\n        if (!valid) {\n            let errorMsg = 'JupyterCAD File format invalid:\\n';\n            for (const error of validate.errors || []) {\n                errorMsg = `${errorMsg}- ${error.instancePath} ${error.message}\\n`;\n            }\n            console.warn(errorMsg);\n        }\n        this.sharedModel.transact(() => {\n            var _a;\n            this.sharedModel.addObjects(jsonData.objects);\n            this.sharedModel.setOptions((_a = jsonData.options) !== null && _a !== void 0 ? _a : {});\n        });\n        this.dirty = true;\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    fromJSON(data) {\n        // nothing to do\n    }\n    initialize() {\n        //\n    }\n    getWorker() {\n        return JupyterCadModel.worker;\n    }\n    getContent() {\n        return {\n            objects: this.sharedModel.objects,\n            options: this.sharedModel.options\n        };\n    }\n    getAllObject() {\n        return this.sharedModel.objects;\n    }\n    syncPointer(pointer, emitter) {\n        this.sharedModel.awareness.setLocalStateField('pointer', {\n            value: pointer,\n            emitter: emitter\n        });\n    }\n    syncCamera(camera, emitter) {\n        this.sharedModel.awareness.setLocalStateField('camera', {\n            value: camera,\n            emitter: emitter\n        });\n    }\n    syncSelected(value, emitter) {\n        this.sharedModel.awareness.setLocalStateField('selected', {\n            value,\n            emitter: emitter\n        });\n    }\n    syncSelectedPropField(data) {\n        this.sharedModel.awareness.setLocalStateField('selectedPropField', data);\n    }\n    setUserToFollow(userId) {\n        if (this.sharedModel) {\n            this.sharedModel.awareness.setLocalStateField('remoteUser', userId);\n        }\n    }\n    syncFormData(form) {\n        if (this.sharedModel) {\n            this.sharedModel.awareness.setLocalStateField('toolbarForm', form);\n        }\n    }\n    getClientId() {\n        return this.sharedModel.awareness.clientID;\n    }\n    addMetadata(key, value) {\n        this.sharedModel.setMetadata(key, value);\n    }\n    removeMetadata(key) {\n        this.sharedModel.removeMetadata(key);\n    }\n    setCopiedObject(object) {\n        this._copiedObject = object ? Object.assign({}, object) : null;\n    }\n    getCopiedObject() {\n        return this._copiedObject ? Object.assign({}, this._copiedObject) : null;\n    }\n    createSharedModel() {\n        return _doc__WEBPACK_IMPORTED_MODULE_2__.JupyterCadDoc.create();\n    }\n    _connectSignal() {\n        this._sharedModel.changed.connect(this._onSharedModelChanged);\n        this._sharedModel.awareness.on('change', this._onClientStateChanged);\n        this._sharedModel.metadataChanged.connect(this._metadataChangedHandler, this);\n        this._sharedModel.optionsChanged.connect(this._optionsChangedHandler, this);\n        this._sharedModel.objectsChanged.connect(this._objectsChangedHandler, this);\n    }\n    _disconnectSignal() {\n        this._sharedModel.changed.disconnect(this._onSharedModelChanged);\n        this._sharedModel.awareness.off('change', this._onClientStateChanged);\n        this._sharedModel.metadataChanged.disconnect(this._metadataChangedHandler, this);\n        this._sharedModel.optionsChanged.disconnect(this._optionsChangedHandler, this);\n        this._sharedModel.objectsChanged.disconnect(this._objectsChangedHandler, this);\n    }\n    _metadataChangedHandler(_, args) {\n        this._sharedMetadataChanged.emit(args);\n    }\n    _optionsChangedHandler(_, args) {\n        this._sharedOptionsChanged.emit(args);\n    }\n    _objectsChangedHandler(_, args) {\n        this._sharedObjectsChanged.emit(args);\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../schema/lib/model.js?\n}");

/***/ },

/***/ "../schema/lib/schema/jcad.json"
/*!**************************************!*\
  !*** ../schema/lib/schema/jcad.json ***!
  \**************************************/
(module) {

"use strict";
eval("{module.exports = /*#__PURE__*/JSON.parse('{\"type\":\"object\",\"title\":\"IJCadContent\",\"required\":[\"objects\"],\"additionalProperties\":false,\"properties\":{\"schemaVersion\":{\"type\":\"string\",\"default\":\"3.0.0\"},\"objects\":{\"$ref\":\"#/definitions/jcadModel\"},\"options\":{\"$ref\":\"#/definitions/jcadOptions\"},\"metadata\":{\"type\":\"object\",\"patternProperties\":{\"^.*$\":{\"type\":\"string\"}},\"additionalProperties\":false},\"outputs\":{\"type\":\"object\",\"additionalProperties\":false,\"patternProperties\":{\"^.*$\":{\"type\":\"string\"}}}},\"definitions\":{\"geometryFeature\":{\"$ref\":\"./geometryFeature.json\"},\"parts\":{\"type\":\"string\",\"enum\":[\"Part::Any\",\"Part::Box\",\"Part::Cylinder\",\"Part::Sphere\",\"Part::Cone\",\"Part::Torus\",\"Part::Cut\",\"Part::MultiFuse\",\"Part::MultiCommon\",\"Part::Extrusion\",\"Part::Chamfer\",\"Part::Fillet\",\"Sketcher::SketchObject\",\"Post::Operator\"]},\"shapeMetadata\":{\"title\":\"IShapeMetadata\",\"type\":\"object\",\"additionalProperties\":false,\"properties\":{\"shapeFormat\":{\"type\":\"string\"},\"workerId\":{\"type\":\"string\"},\"mass\":{\"type\":\"number\"},\"centerOfMass\":{\"type\":\"array\",\"items\":{\"type\":\"number\"}},\"matrixOfInertia\":{\"type\":\"array\",\"items\":{\"type\":\"array\",\"items\":{\"type\":\"number\"}}}}},\"jcadObject\":{\"title\":\"IJCadObject\",\"type\":\"object\",\"additionalProperties\":false,\"required\":[\"name\",\"visible\"],\"properties\":{\"name\":{\"type\":\"string\"},\"visible\":{\"type\":\"boolean\"},\"shape\":{\"$ref\":\"#/definitions/parts\"},\"parameters\":{\"type\":\"object\"},\"shapeMetadata\":{\"$ref\":\"#/definitions/shapeMetadata\"},\"operators\":{\"type\":\"array\",\"items\":{\"type\":\"object\"}},\"dependencies\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"geometryFeatures\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/geometryFeature\"},\"description\":\"Assembly features extracted from this object (for DTEditor integration)\"}}},\"jcadModel\":{\"title\":\"IJCadModel\",\"type\":\"array\",\"default\":[],\"items\":{\"$ref\":\"#/definitions/jcadObject\"}},\"jcadOptions\":{\"title\":\"IJCadOptions\",\"type\":\"object\",\"default\":{},\"additionalProperties\":false,\"properties\":{}}}}');\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../schema/lib/schema/jcad.json?\n}");

/***/ },

/***/ "../schema/lib/token.js"
/*!******************************!*\
  !*** ../schema/lib/token.js ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IAnnotationToken: () => (/* binding */ IAnnotationToken),\n/* harmony export */   IJCadExternalCommandRegistryToken: () => (/* binding */ IJCadExternalCommandRegistryToken),\n/* harmony export */   IJCadFormSchemaRegistryToken: () => (/* binding */ IJCadFormSchemaRegistryToken),\n/* harmony export */   IJCadWorkerRegistryToken: () => (/* binding */ IJCadWorkerRegistryToken),\n/* harmony export */   IJupyterCadDocTracker: () => (/* binding */ IJupyterCadDocTracker)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"../../node_modules/@lumino/coreutils/dist/index.js\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n\nconst IJupyterCadDocTracker = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('jupyterCadDocTracker');\nconst IAnnotationToken = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('jupytercadAnnotationModel');\nconst IJCadWorkerRegistryToken = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('jupytercadWorkerRegistry');\nconst IJCadFormSchemaRegistryToken = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('jupytercadFormSchemaRegistry');\nconst IJCadExternalCommandRegistryToken = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('jupytercadExternalCommandRegistry');\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/../schema/lib/token.js?\n}");

/***/ },

/***/ "./src/actions.ts"
/*!************************!*\
  !*** ./src/actions.ts ***!
  \************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _jupytercad_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupytercad/schema */ \"../schema/lib/index.js\");\n/* harmony import */ var _occapi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./occapi */ \"./src/occapi/index.ts\");\n/* harmony import */ var _occparser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./occparser */ \"./src/occparser.ts\");\n\n\n\nfunction buildModel(model) {\n    const outputModel = [];\n    const { objects } = model;\n    objects.forEach(object => {\n        var _a, _b, _c, _d;\n        const { shape, parameters, shapeMetadata } = object;\n        if (!shape || !parameters) {\n            return;\n        }\n        const shapeFactory = (0,_occapi__WEBPACK_IMPORTED_MODULE_1__.getShapesFactory)();\n        let shapeData = undefined;\n        if (shapeFactory[shape]) {\n            shapeData = (_a = shapeFactory[shape]) === null || _a === void 0 ? void 0 : _a.call(shapeFactory, parameters, model);\n        }\n        else if (parameters['Shape']) {\n            // Creating occ shape from brep file.\n            const type = (_b = parameters['Type']) !== null && _b !== void 0 ? _b : 'brep';\n            shapeData = (0,_occapi__WEBPACK_IMPORTED_MODULE_1__.ObjectFile)({\n                content: parameters['Shape'],\n                type,\n                placement: parameters === null || parameters === void 0 ? void 0 : parameters.Placement\n            }, model);\n        }\n        else if (shape.startsWith('Post::') && shapeMetadata) {\n            const shapeFormat = ((_c = shapeMetadata.shapeFormat) !== null && _c !== void 0 ? _c : _jupytercad_schema__WEBPACK_IMPORTED_MODULE_0__.JCadWorkerSupportedFormat.BREP);\n            switch (shapeFormat) {\n                case _jupytercad_schema__WEBPACK_IMPORTED_MODULE_0__.JCadWorkerSupportedFormat.GLTF: {\n                    shapeData = {\n                        postShape: ''\n                    };\n                    break;\n                }\n                case _jupytercad_schema__WEBPACK_IMPORTED_MODULE_0__.JCadWorkerSupportedFormat.BREP:\n                case _jupytercad_schema__WEBPACK_IMPORTED_MODULE_0__.JCadWorkerSupportedFormat.STL: {\n                    shapeData = (_d = shapeFactory['Post::Operator']) === null || _d === void 0 ? void 0 : _d.call(shapeFactory, parameters, model);\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n        if (shapeData) {\n            outputModel.push({ shapeData, jcObject: object });\n        }\n    });\n    return outputModel;\n}\nfunction loadFile(payload, raiseOnFailure = false) {\n    const { content } = payload;\n    const outputModel = buildModel(content);\n    const parser = new _occparser__WEBPACK_IMPORTED_MODULE_2__.OccParser(outputModel);\n    const result = parser.execute(raiseOnFailure);\n    const postResult = {};\n    outputModel.forEach(item => {\n        var _a;\n        if ((_a = item.jcObject.shape) === null || _a === void 0 ? void 0 : _a.startsWith('Post::')) {\n            postResult[item.jcObject.name] = {\n                jcObject: item.jcObject,\n                postShape: item.shapeData.postShape\n            };\n        }\n    });\n    return { result, postResult };\n}\nfunction dryRun(payload) {\n    return loadFile(payload, true);\n}\nconst WorkerHandler = {};\nWorkerHandler[_jupytercad_schema__WEBPACK_IMPORTED_MODULE_0__.WorkerAction.LOAD_FILE] = loadFile;\nWorkerHandler[_jupytercad_schema__WEBPACK_IMPORTED_MODULE_0__.WorkerAction.DRY_RUN] = dryRun;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WorkerHandler);\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/actions.ts?\n}");

/***/ },

/***/ "./src/occapi/any.ts"
/*!***************************!*\
  !*** ./src/occapi/any.ts ***!
  \***************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Any: () => (/* binding */ _Any)\n/* harmony export */ });\n/* harmony import */ var _loadObjectFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadObjectFile */ \"./src/occapi/loadObjectFile.ts\");\n\nfunction _Any(arg, content) {\n    const { Content, Type, Placement } = arg;\n    const result = (0,_loadObjectFile__WEBPACK_IMPORTED_MODULE_0__._loadObjectFile)({\n        content: Content,\n        type: Type,\n        placement: Placement\n    });\n    return result;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/any.ts?\n}");

/***/ },

/***/ "./src/occapi/box.ts"
/*!***************************!*\
  !*** ./src/occapi/box.ts ***!
  \***************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Box: () => (/* binding */ _Box)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\nfunction _Box(arg, _) {\n    const { Length, Width, Height, Placement } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const box = new oc.BRepPrimAPI_MakeBox_2(Length, Width, Height);\n    const shape = box.Shape();\n    return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(shape, Placement);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/box.ts?\n}");

/***/ },

/***/ "./src/occapi/brepIO.ts"
/*!******************************!*\
  !*** ./src/occapi/brepIO.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _loadBrepFile: () => (/* binding */ _loadBrepFile),\n/* harmony export */   _writeBrep: () => (/* binding */ _writeBrep)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"../../node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _writeBrep(shape) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getOcc)();\n    const fakeFileName = `${(0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}.brep`;\n    const progress = new oc.Message_ProgressRange_1();\n    oc.BRepTools.Write_4(shape, fakeFileName, false, false, oc.TopTools_FormatVersion.TopTools_FormatVersion_VERSION_1, progress);\n    const value = oc.FS.readFile('/' + fakeFileName, { encoding: 'utf8' });\n    oc.FS.unlink('/' + fakeFileName);\n    return value;\n}\nfunction _loadBrepFile(content) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getOcc)();\n    const fakeFileName = `${(0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}.brep`;\n    oc.FS.createDataFile('/', fakeFileName, content, true, true, true);\n    const shape = new oc.TopoDS_Shape();\n    const builder = new oc.BRep_Builder();\n    const progress = new oc.Message_ProgressRange_1();\n    oc.BRepTools.Read_2(shape, fakeFileName, builder, progress);\n    oc.FS.unlink('/' + fakeFileName);\n    return shape;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/brepIO.ts?\n}");

/***/ },

/***/ "./src/occapi/chamfer.ts"
/*!*******************************!*\
  !*** ./src/occapi/chamfer.ts ***!
  \*******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Chamfer: () => (/* binding */ _Chamfer)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Chamfer(arg, content) {\n    var _a;\n    const { Base, Edge, Dist, Placement } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const baseObject = content.objects.filter(obj => obj.name === Base);\n    if (baseObject.length === 0) {\n        return;\n    }\n    const baseShape = baseObject[0].shape;\n    const shapesFactory = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getShapesFactory)();\n    if (baseShape && shapesFactory[baseShape]) {\n        const base = (_a = shapesFactory[baseShape]) === null || _a === void 0 ? void 0 : _a.call(shapesFactory, baseObject[0].parameters, content);\n        if (!base || !base.occShape) {\n            return;\n        }\n        const mapOfShape = new oc.TopTools_IndexedMapOfShape_1();\n        oc.TopExp.MapShapes_1(base.occShape, oc.TopAbs_ShapeEnum.TopAbs_EDGE, mapOfShape);\n        const chamferBuilder = new oc.BRepFilletAPI_MakeChamfer(base.occShape);\n        const edgeList = Array.isArray(Edge) ? Edge : [Edge];\n        for (const edgeIdx of edgeList) {\n            const e = oc.TopoDS.Edge_1(mapOfShape.FindKey(edgeIdx + 1));\n            chamferBuilder.Add_2(Dist, e);\n        }\n        chamferBuilder.Build(new oc.Message_ProgressRange_1());\n        if (chamferBuilder.IsDone()) {\n            return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(chamferBuilder.Shape(), Placement);\n        }\n        else {\n            console.error('Failed to create chamfer');\n        }\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/chamfer.ts?\n}");

/***/ },

/***/ "./src/occapi/common.ts"
/*!******************************!*\
  !*** ./src/occapi/common.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOcc: () => (/* binding */ getOcc),\n/* harmony export */   getShapesFactory: () => (/* binding */ getShapesFactory),\n/* harmony export */   setShapePlacement: () => (/* binding */ setShapePlacement),\n/* harmony export */   setShapesFactory: () => (/* binding */ setShapesFactory),\n/* harmony export */   toDeg: () => (/* binding */ toDeg),\n/* harmony export */   toRad: () => (/* binding */ toRad)\n/* harmony export */ });\nlet occ;\nfunction getOcc() {\n    if (!occ) {\n        occ = self.occ;\n    }\n    return occ;\n}\nfunction toRad(deg) {\n    return (Math.PI * deg) / 180;\n}\nfunction toDeg(rad) {\n    return (180 * rad) / Math.PI;\n}\nfunction setShapePlacement(shape, placement) {\n    if (!placement) {\n        return shape;\n    }\n    const oc = getOcc();\n    const trsf = new oc.gp_Trsf_1();\n    const ax = new oc.gp_Ax1_2(new oc.gp_Pnt_3(0, 0, 0), new oc.gp_Dir_4(placement.Axis[0], placement.Axis[1], placement.Axis[2]));\n    const angle = toRad(placement.Angle);\n    trsf.SetRotation_1(ax, angle);\n    trsf.SetTranslationPart(new oc.gp_Vec_4(placement.Position[0], placement.Position[1], placement.Position[2]));\n    const loc = new oc.TopLoc_Location_2(trsf);\n    shape.Location_2(loc, true);\n    return shape;\n}\nconst _ShapesFactory = {\n    'Part::Any': undefined,\n    'Part::Box': undefined,\n    'Part::Cylinder': undefined,\n    'Part::Sphere': undefined,\n    'Part::Cone': undefined,\n    'Part::Torus': undefined,\n    'Part::Cut': undefined,\n    'Part::MultiFuse': undefined,\n    'Part::Extrusion': undefined,\n    'Part::MultiCommon': undefined,\n    'Part::Chamfer': undefined,\n    'Part::Fillet': undefined,\n    'Sketcher::SketchObject': undefined,\n    'Post::Operator': undefined\n};\nfunction getShapesFactory() {\n    return _ShapesFactory;\n}\nfunction setShapesFactory(key, value) {\n    _ShapesFactory[key] = value;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/common.ts?\n}");

/***/ },

/***/ "./src/occapi/cone.ts"
/*!****************************!*\
  !*** ./src/occapi/cone.ts ***!
  \****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Cone: () => (/* binding */ _Cone)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Cone(arg, _) {\n    const { Radius1, Radius2, Height, Angle, Placement } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const cone = new oc.BRepPrimAPI_MakeCone_2(Radius1, Radius2, Height, (0,_common__WEBPACK_IMPORTED_MODULE_0__.toRad)(Angle));\n    const shape = cone.Shape();\n    return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(shape, Placement);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/cone.ts?\n}");

/***/ },

/***/ "./src/occapi/cut.ts"
/*!***************************!*\
  !*** ./src/occapi/cut.ts ***!
  \***************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Cut: () => (/* binding */ _Cut)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Cut(arg, content) {\n    var _a, _b;\n    const { Placement, Base, Tool } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const baseObject = content.objects.filter(obj => obj.name === Base);\n    const toolObject = content.objects.filter(obj => obj.name === Tool);\n    if (baseObject.length === 0 || toolObject.length === 0) {\n        return;\n    }\n    const baseShape = baseObject[0].shape;\n    const toolShape = toolObject[0].shape;\n    const shapesFactory = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getShapesFactory)();\n    if (baseShape &&\n        shapesFactory[baseShape] &&\n        toolShape &&\n        shapesFactory[toolShape]) {\n        const base = (_a = shapesFactory[baseShape]) === null || _a === void 0 ? void 0 : _a.call(shapesFactory, baseObject[0].parameters, content);\n        const tool = (_b = shapesFactory[toolShape]) === null || _b === void 0 ? void 0 : _b.call(shapesFactory, toolObject[0].parameters, content);\n        if (base && tool && base.occShape && tool.occShape) {\n            baseObject[0].visible = false;\n            toolObject[0].visible = false;\n            const operator = new oc.BRepAlgoAPI_Cut_3(base.occShape, tool.occShape, new oc.Message_ProgressRange_1());\n            if (operator.IsDone()) {\n                return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(operator.Shape(), Placement);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/cut.ts?\n}");

/***/ },

/***/ "./src/occapi/cylinder.ts"
/*!********************************!*\
  !*** ./src/occapi/cylinder.ts ***!
  \********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Cylinder: () => (/* binding */ _Cylinder)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Cylinder(arg, _) {\n    const { Radius, Height, Angle, Placement } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const cylinder = new oc.BRepPrimAPI_MakeCylinder_2(Radius, Height, (0,_common__WEBPACK_IMPORTED_MODULE_0__.toRad)(Angle));\n    const shape = cylinder.Shape();\n    return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(shape, Placement);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/cylinder.ts?\n}");

/***/ },

/***/ "./src/occapi/extrude.ts"
/*!*******************************!*\
  !*** ./src/occapi/extrude.ts ***!
  \*******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Extrude: () => (/* binding */ _Extrude)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Extrude(arg, content) {\n    var _a;\n    const { Base, Dir, LengthFwd, LengthRev, Placement, Solid } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const baseObject = content.objects.filter(obj => obj.name === Base);\n    if (baseObject.length === 0) {\n        return;\n    }\n    const baseShape = baseObject[0].shape;\n    const shapesFactory = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getShapesFactory)();\n    if (baseShape && shapesFactory[baseShape]) {\n        const base = (_a = shapesFactory[baseShape]) === null || _a === void 0 ? void 0 : _a.call(shapesFactory, baseObject[0].parameters, content);\n        if (!base || !base.occShape) {\n            return;\n        }\n        const dirVec = new oc.gp_Vec_4(Dir[0], Dir[1], Dir[2]);\n        const vec = dirVec.Multiplied(LengthFwd + LengthRev);\n        let baseCopy = new oc.BRepBuilderAPI_Copy_2(base.occShape, true, false).Shape();\n        if (LengthRev !== 0) {\n            const mov = new oc.gp_Trsf_1();\n            mov.SetTranslation_1(dirVec.Multiplied(-LengthRev));\n            const loc = new oc.TopLoc_Location_2(mov);\n            baseCopy.Move(loc, true);\n        }\n        if (Solid) {\n            const xp = new oc.TopExp_Explorer_2(baseCopy, oc.TopAbs_ShapeEnum.TopAbs_FACE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);\n            if (xp.More()) {\n                //source shape has faces. Just extrude as-is.\n            }\n            else {\n                const wireEx = new oc.TopExp_Explorer_2(baseCopy, oc.TopAbs_ShapeEnum.TopAbs_EDGE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);\n                const wireMaker = new oc.BRepBuilderAPI_MakeWire_1();\n                while (wireEx.More()) {\n                    const ed = oc.TopoDS.Edge_1(wireEx.Current());\n                    wireMaker.Add_1(ed);\n                    wireEx.Next();\n                }\n                const wire = wireMaker.Wire();\n                const faceMaker = new oc.BRepBuilderAPI_MakeFace_15(wire, false);\n                baseCopy = faceMaker.Face();\n            }\n        }\n        const result = new oc.BRepPrimAPI_MakePrism_1(baseCopy, vec, false, true);\n        return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(result.Shape(), Placement);\n    }\n    return;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/extrude.ts?\n}");

/***/ },

/***/ "./src/occapi/fillet.ts"
/*!******************************!*\
  !*** ./src/occapi/fillet.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Fillet: () => (/* binding */ _Fillet)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Fillet(arg, content) {\n    var _a;\n    const { Base, Edge, Radius, Placement } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const baseObject = content.objects.filter(obj => obj.name === Base);\n    if (baseObject.length === 0) {\n        return;\n    }\n    const baseShape = baseObject[0].shape;\n    const shapesFactory = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getShapesFactory)();\n    if (baseShape && shapesFactory[baseShape]) {\n        const base = (_a = shapesFactory[baseShape]) === null || _a === void 0 ? void 0 : _a.call(shapesFactory, baseObject[0].parameters, content);\n        if (!base || !base.occShape) {\n            return;\n        }\n        const mapOfShape = new oc.TopTools_IndexedMapOfShape_1();\n        oc.TopExp.MapShapes_1(base.occShape, oc.TopAbs_ShapeEnum.TopAbs_EDGE, mapOfShape);\n        const filletBuilder = new oc.BRepFilletAPI_MakeFillet(base.occShape, oc.ChFi3d_FilletShape);\n        const edgeList = Array.isArray(Edge) ? Edge : [Edge];\n        for (const edgeIdx of edgeList) {\n            const e = oc.TopoDS.Edge_1(mapOfShape.FindKey(edgeIdx + 1));\n            filletBuilder.Add_2(Radius, e);\n        }\n        filletBuilder.Build(new oc.Message_ProgressRange_1());\n        if (filletBuilder.IsDone()) {\n            return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(filletBuilder.Shape(), Placement);\n        }\n        else {\n            console.error('Failed to create fillet');\n        }\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/fillet.ts?\n}");

/***/ },

/***/ "./src/occapi/fuse.ts"
/*!****************************!*\
  !*** ./src/occapi/fuse.ts ***!
  \****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Fuse: () => (/* binding */ _Fuse)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Fuse(arg, content) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const { Shapes, Placement } = arg;\n    const occShapes = [];\n    Shapes.forEach(Base => {\n        var _a;\n        const baseObject = content.objects.filter(obj => obj.name === Base);\n        if (baseObject.length === 0) {\n            return;\n        }\n        const shapesFactory = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getShapesFactory)();\n        const baseShape = baseObject[0].shape;\n        if (baseShape && shapesFactory[baseShape]) {\n            const base = (_a = shapesFactory[baseShape]) === null || _a === void 0 ? void 0 : _a.call(shapesFactory, baseObject[0].parameters, content);\n            if (base && base.occShape) {\n                occShapes.push(base.occShape);\n                baseObject[0].visible = false;\n            }\n        }\n    });\n    if (occShapes.length === 0) {\n        return;\n    }\n    let fusedShape = occShapes[0];\n    for (let i = 1; i < occShapes.length; i++) {\n        const operator = new oc.BRepAlgoAPI_Fuse_3(fusedShape, occShapes[i], new oc.Message_ProgressRange_1());\n        if (operator.IsDone()) {\n            fusedShape = operator.Shape();\n        }\n        else {\n            console.error(`Fusion failed at index ${i}`);\n            return;\n        }\n    }\n    return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(fusedShape, Placement);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/fuse.ts?\n}");

/***/ },

/***/ "./src/occapi/geomCircle.ts"
/*!**********************************!*\
  !*** ./src/occapi/geomCircle.ts ***!
  \**********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _GeomCircle: () => (/* binding */ _GeomCircle)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\nfunction _GeomCircle(arg) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const center = new oc.gp_Pnt_3(arg.CenterX, arg.CenterY, arg.CenterZ);\n    const norm = new oc.gp_Dir_4(arg.NormalX, arg.NormalY, arg.NormalZ);\n    const radius = arg.Radius;\n    const circle = new oc.GC_MakeCircle_6(center, norm, radius).Value();\n    const edge = new oc.BRepBuilderAPI_MakeEdge_8(circle.get().Circ()).Edge();\n    const circleWire = new oc.BRepBuilderAPI_MakeWire_2(edge).Wire();\n    return circleWire;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/geomCircle.ts?\n}");

/***/ },

/***/ "./src/occapi/geomLineSegment.ts"
/*!***************************************!*\
  !*** ./src/occapi/geomLineSegment.ts ***!
  \***************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _GeomLine: () => (/* binding */ _GeomLine)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\nfunction _GeomLine(arg) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const start = new oc.gp_Pnt_3(arg.StartX, arg.StartY, arg.StartZ);\n    const end = new oc.gp_Pnt_3(arg.EndX, arg.EndY, arg.EndZ);\n    const edge = new oc.BRepBuilderAPI_MakeEdge_3(start, end).Edge();\n    const lineWire = new oc.BRepBuilderAPI_MakeWire_2(edge).Wire();\n    return lineWire;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/geomLineSegment.ts?\n}");

/***/ },

/***/ "./src/occapi/index.ts"
/*!*****************************!*\
  !*** ./src/occapi/index.ts ***!
  \*****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Any: () => (/* binding */ Any),\n/* harmony export */   Box: () => (/* binding */ Box),\n/* harmony export */   Chamfer: () => (/* binding */ Chamfer),\n/* harmony export */   Cone: () => (/* binding */ Cone),\n/* harmony export */   Cut: () => (/* binding */ Cut),\n/* harmony export */   Cylinder: () => (/* binding */ Cylinder),\n/* harmony export */   Extrude: () => (/* binding */ Extrude),\n/* harmony export */   Fillet: () => (/* binding */ Fillet),\n/* harmony export */   Fuse: () => (/* binding */ Fuse),\n/* harmony export */   Intersection: () => (/* binding */ Intersection),\n/* harmony export */   ObjectFile: () => (/* binding */ ObjectFile),\n/* harmony export */   SketchObject: () => (/* binding */ SketchObject),\n/* harmony export */   Sphere: () => (/* binding */ Sphere),\n/* harmony export */   Torus: () => (/* binding */ Torus),\n/* harmony export */   getShapesFactory: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_2__.getShapesFactory),\n/* harmony export */   initShapesFactory: () => (/* binding */ initShapesFactory)\n/* harmony export */ });\n/* harmony import */ var _any__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./any */ \"./src/occapi/any.ts\");\n/* harmony import */ var _box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./box */ \"./src/occapi/box.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n/* harmony import */ var _cone__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cone */ \"./src/occapi/cone.ts\");\n/* harmony import */ var _cut__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cut */ \"./src/occapi/cut.ts\");\n/* harmony import */ var _cylinder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cylinder */ \"./src/occapi/cylinder.ts\");\n/* harmony import */ var _extrude__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extrude */ \"./src/occapi/extrude.ts\");\n/* harmony import */ var _fuse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fuse */ \"./src/occapi/fuse.ts\");\n/* harmony import */ var _chamfer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chamfer */ \"./src/occapi/chamfer.ts\");\n/* harmony import */ var _fillet__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./fillet */ \"./src/occapi/fillet.ts\");\n/* harmony import */ var _intersection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./intersection */ \"./src/occapi/intersection.ts\");\n/* harmony import */ var _loadObjectFile__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./loadObjectFile */ \"./src/occapi/loadObjectFile.ts\");\n/* harmony import */ var _operatorCache__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./operatorCache */ \"./src/occapi/operatorCache.ts\");\n/* harmony import */ var _postOperator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./postOperator */ \"./src/occapi/postOperator.ts\");\n/* harmony import */ var _sketchObject__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./sketchObject */ \"./src/occapi/sketchObject.ts\");\n/* harmony import */ var _sphere__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./sphere */ \"./src/occapi/sphere.ts\");\n/* harmony import */ var _torus__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./torus */ \"./src/occapi/torus.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Any = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Any', _any__WEBPACK_IMPORTED_MODULE_0__._Any);\nconst Box = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Box', _box__WEBPACK_IMPORTED_MODULE_1__._Box);\nconst Cylinder = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Cylinder', _cylinder__WEBPACK_IMPORTED_MODULE_5__._Cylinder);\nconst Sphere = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Sphere', _sphere__WEBPACK_IMPORTED_MODULE_15__._Sphere);\nconst Cone = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Cone', _cone__WEBPACK_IMPORTED_MODULE_3__._Cone);\nconst Torus = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Torus', _torus__WEBPACK_IMPORTED_MODULE_16__._Torus);\nconst SketchObject = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Sketcher::SketchObject', _sketchObject__WEBPACK_IMPORTED_MODULE_14__._SketchObject);\nconst Cut = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Cut', _cut__WEBPACK_IMPORTED_MODULE_4__._Cut);\nconst Fuse = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::MultiFuse', _fuse__WEBPACK_IMPORTED_MODULE_7__._Fuse);\nconst Intersection = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::MultiCommon', _intersection__WEBPACK_IMPORTED_MODULE_10__._Intersection);\nconst Extrude = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Extrusion', _extrude__WEBPACK_IMPORTED_MODULE_6__._Extrude);\nconst Chamfer = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Chamfer', _chamfer__WEBPACK_IMPORTED_MODULE_8__._Chamfer);\nconst Fillet = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('Part::Fillet', _fillet__WEBPACK_IMPORTED_MODULE_9__._Fillet);\nconst ObjectFile = (0,_operatorCache__WEBPACK_IMPORTED_MODULE_12__.operatorCache)('ObjectFile', _loadObjectFile__WEBPACK_IMPORTED_MODULE_11__._loadObjectFile);\nfunction initShapesFactory() {\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Any', Any);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Box', Box);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Cylinder', Cylinder);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Sphere', Sphere);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Cone', Cone);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Torus', Torus);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Cut', Cut);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::MultiFuse', Fuse);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Extrusion', Extrude);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::MultiCommon', Intersection);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Chamfer', Chamfer);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Part::Fillet', Fillet);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Sketcher::SketchObject', SketchObject);\n    (0,_common__WEBPACK_IMPORTED_MODULE_2__.setShapesFactory)('Post::Operator', _postOperator__WEBPACK_IMPORTED_MODULE_13__._PostOperator);\n}\n\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/index.ts?\n}");

/***/ },

/***/ "./src/occapi/intersection.ts"
/*!************************************!*\
  !*** ./src/occapi/intersection.ts ***!
  \************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Intersection: () => (/* binding */ _Intersection)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Intersection(arg, content) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const { Shapes, Placement } = arg;\n    const occShapes = [];\n    Shapes.forEach(Base => {\n        var _a;\n        const baseObject = content.objects.filter(obj => obj.name === Base);\n        if (baseObject.length === 0) {\n            return;\n        }\n        const shapesFactory = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getShapesFactory)();\n        const baseShape = baseObject[0].shape;\n        if (baseShape && shapesFactory[baseShape]) {\n            const base = (_a = shapesFactory[baseShape]) === null || _a === void 0 ? void 0 : _a.call(shapesFactory, baseObject[0].parameters, content);\n            if (base && base.occShape) {\n                occShapes.push(base.occShape);\n                baseObject[0].visible = false;\n            }\n        }\n    });\n    const operator = new oc.BRepAlgoAPI_Common_3(occShapes[0], occShapes[1], new oc.Message_ProgressRange_1());\n    if (operator.IsDone()) {\n        return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(operator.Shape(), Placement);\n    }\n    return;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/intersection.ts?\n}");

/***/ },

/***/ "./src/occapi/loadObjectFile.ts"
/*!**************************************!*\
  !*** ./src/occapi/loadObjectFile.ts ***!
  \**************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _loadObjectFile: () => (/* binding */ _loadObjectFile)\n/* harmony export */ });\n/* harmony import */ var _brepIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./brepIO */ \"./src/occapi/brepIO.ts\");\n/* harmony import */ var _stepIO__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stepIO */ \"./src/occapi/stepIO.ts\");\n/* harmony import */ var _stlIO__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stlIO */ \"./src/occapi/stlIO.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\n\n\nfunction _loadObjectFile(arg) {\n    let shape;\n    switch (arg.type.toLowerCase()) {\n        case 'brep':\n            shape = (0,_brepIO__WEBPACK_IMPORTED_MODULE_0__._loadBrepFile)(arg.content);\n            break;\n        case 'step':\n            shape = (0,_stepIO__WEBPACK_IMPORTED_MODULE_1__._loadStepFile)(arg.content);\n            break;\n        case 'stl':\n            shape = (0,_stlIO__WEBPACK_IMPORTED_MODULE_2__._loadStlFile)(arg.content);\n            break;\n        default:\n            throw `${arg.type} file not supported`;\n    }\n    if (shape) {\n        (0,_common__WEBPACK_IMPORTED_MODULE_3__.setShapePlacement)(shape, arg.placement);\n    }\n    return shape;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/loadObjectFile.ts?\n}");

/***/ },

/***/ "./src/occapi/makeShapeFromMesh.ts"
/*!*****************************************!*\
  !*** ./src/occapi/makeShapeFromMesh.ts ***!
  \*****************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeShapeFromMesh: () => (/* binding */ makeShapeFromMesh)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n/**\n * Structure representing mesh edge.\n *\n * @class Edge\n */\nclass Edge {\n    constructor(TheIdx1, TheIdx2) {\n        this._Idx1 = TheIdx1;\n        this._Idx2 = TheIdx2;\n    }\n    get Idx1() {\n        return this._Idx1;\n    }\n    get Idx2() {\n        return this._Idx2;\n    }\n    get hashStr() {\n        return `${this.Idx1}@${this.Idx2}`;\n    }\n    equal(other) {\n        return this.hashStr === other.hashStr;\n    }\n}\n/**\n * Ref. https://dev.opencascade.org/doc/refman/html/class_n_collection___indexed_data_map.html\n *\n * @class IndexedDataMap\n * @template K\n * @template V\n */\nclass IndexedDataMap {\n    constructor() {\n        this._internalMap = new Map();\n        this._currentIdx = 0;\n    }\n    add(k, v) {\n        const hash = this._hash(k);\n        const current = this._internalMap.get(hash);\n        if (current) {\n            return current.index;\n        }\n        else {\n            this._currentIdx += 1;\n            this._internalMap.set(hash, { index: this._currentIdx, value: v });\n            return this._currentIdx;\n        }\n    }\n    findFromKey(k) {\n        var _a;\n        const hash = this._hash(k);\n        return (_a = this._internalMap.get(hash)) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    contains(k) {\n        const hash = this._hash(k);\n        return this._internalMap.has(hash);\n    }\n    _hash(key) {\n        if (key['hashStr']) {\n            return key['hashStr'];\n        }\n        else if (typeof key === 'number' || typeof key === 'string') {\n            return key + '';\n        }\n        throw new Error('Key type is not supported');\n    }\n}\nfunction makeShapeFromMesh(myMeshHandle) {\n    if (myMeshHandle.IsNull()) {\n        return;\n    }\n    const myMesh = myMeshHandle.get();\n    if (myMesh.NbNodes() === 0 || myMesh.NbTriangles() === 0) {\n        return;\n    }\n    const SMALL = 1e-9;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const aNbNodes = myMesh.NbNodes();\n    const aNbTriangles = myMesh.NbTriangles();\n    const aPnt2VertexMap = new IndexedDataMap();\n    for (let idx = 1; idx <= aNbNodes; ++idx) {\n        const aP = myMesh.Node(idx);\n        const aV = new oc.BRepBuilderAPI_MakeVertex(aP);\n        aPnt2VertexMap.add(idx, aV.Vertex());\n    }\n    const anEdgeToTEgeMap = new IndexedDataMap();\n    for (let idx = 1; idx <= aNbTriangles; ++idx) {\n        const aTriangle = myMesh.Triangle(idx);\n        const anIdx = [\n            aTriangle.Value(1),\n            aTriangle.Value(2),\n            aTriangle.Value(3)\n        ];\n        if (anIdx[0] === anIdx[1] ||\n            anIdx[0] === anIdx[2] ||\n            anIdx[1] === anIdx[2]) {\n            continue;\n        }\n        const aP1 = myMesh.Node(anIdx[0]);\n        const aP2 = myMesh.Node(anIdx[1]);\n        const aP3 = myMesh.Node(anIdx[2]);\n        const aD1 = aP1.SquareDistance(aP2);\n        const aD2 = aP1.SquareDistance(aP3);\n        const aD3 = aP2.SquareDistance(aP3);\n        if (aD1 < SMALL || aD2 < SMALL || aD3 < SMALL) {\n            continue;\n        }\n        const aV1 = aPnt2VertexMap.findFromKey(anIdx[0]);\n        const aV2 = aPnt2VertexMap.findFromKey(anIdx[1]);\n        const aV3 = aPnt2VertexMap.findFromKey(anIdx[2]);\n        if (!aV1 || !aV2 || !aV3) {\n            return;\n        }\n        const aMeshEdge1 = new Edge(anIdx[0], anIdx[1]);\n        const aMeshEdge2 = new Edge(anIdx[1], anIdx[2]);\n        const aMeshEdge3 = new Edge(anIdx[2], anIdx[0]);\n        const aMaker1 = new oc.BRepBuilderAPI_MakeEdge_2(aV1, aV2);\n        const aTE1 = aMaker1.Edge();\n        if (anIdx[1] < anIdx[0]) {\n            aTE1.Reverse();\n        }\n        const aMaker2 = new oc.BRepBuilderAPI_MakeEdge_2(aV2, aV3);\n        const aTE2 = aMaker2.Edge();\n        if (anIdx[2] < anIdx[1]) {\n            aTE2.Reverse();\n        }\n        const aMaker3 = new oc.BRepBuilderAPI_MakeEdge_2(aV3, aV1);\n        const aTE3 = aMaker3.Edge();\n        if (anIdx[0] < anIdx[2]) {\n            aTE3.Reverse();\n        }\n        anEdgeToTEgeMap.add(aMeshEdge1, aTE1);\n        anEdgeToTEgeMap.add(aMeshEdge2, aTE2);\n        anEdgeToTEgeMap.add(aMeshEdge3, aTE3);\n    }\n    const aResult = new oc.TopoDS_Compound();\n    const aBB = new oc.BRep_Builder();\n    aBB.MakeCompound(aResult);\n    for (let idx = 1; idx <= aNbTriangles; idx++) {\n        const aTriangle = myMesh.Triangle(idx);\n        const anIdx = [\n            aTriangle.Value(1),\n            aTriangle.Value(2),\n            aTriangle.Value(3)\n        ];\n        const aMeshEdge1 = new Edge(anIdx[0], anIdx[1]);\n        const aMeshEdge2 = new Edge(anIdx[1], anIdx[2]);\n        const aMeshEdge3 = new Edge(anIdx[2], anIdx[0]);\n        const isReversed1 = anIdx[1] < anIdx[0];\n        const isReversed2 = anIdx[2] < anIdx[1];\n        const isReversed3 = anIdx[0] < anIdx[2];\n        const aHasAllEdges = anEdgeToTEgeMap.contains(aMeshEdge1) &&\n            anEdgeToTEgeMap.contains(aMeshEdge2) &&\n            anEdgeToTEgeMap.contains(aMeshEdge3);\n        if (!aHasAllEdges) {\n            continue;\n        }\n        const aTEdge1 = anEdgeToTEgeMap.findFromKey(aMeshEdge1);\n        const aTEdge2 = anEdgeToTEgeMap.findFromKey(aMeshEdge2);\n        const aTEdge3 = anEdgeToTEgeMap.findFromKey(aMeshEdge3);\n        if (!aTEdge1 || !aTEdge2 || !aTEdge3) {\n            continue;\n        }\n        if (isReversed1) {\n            aTEdge1.Reverse();\n        }\n        if (isReversed2) {\n            aTEdge2.Reverse();\n        }\n        if (isReversed3) {\n            aTEdge3.Reverse();\n        }\n        const aWireMaker = new oc.BRepBuilderAPI_MakeWire_1();\n        aWireMaker.Add_1(aTEdge1);\n        aWireMaker.Add_1(aTEdge2);\n        aWireMaker.Add_1(aTEdge3);\n        const aWire = aWireMaker.Wire();\n        const aC1 = new oc.BRepAdaptor_Curve_2(aTEdge1);\n        const aC2 = new oc.BRepAdaptor_Curve_2(aTEdge2);\n        const aD1 = aC1.Line().Direction();\n        const aD2 = aC2.Line().Direction();\n        const aN = aD1.XYZ().Crossed(aD2.XYZ());\n        if (aN.SquareModulus() < SMALL) {\n            continue;\n        }\n        if (aTEdge1.Orientation_1() === oc.TopAbs_Orientation.TopAbs_REVERSED) {\n            aN.Reverse();\n        }\n        if (aTEdge2.Orientation_1() === oc.TopAbs_Orientation.TopAbs_REVERSED) {\n            aN.Reverse();\n        }\n        const aNorm = new oc.gp_Dir_3(aN);\n        const aPln = new oc.gp_Pln_3(myMesh.Node(anIdx[0]), aNorm);\n        const aFaceMaker = new oc.BRepBuilderAPI_MakeFace_16(aPln, aWire, true);\n        const aFace = aFaceMaker.Face();\n        aBB.Add(aResult, aFace);\n    }\n    return aResult;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/makeShapeFromMesh.ts?\n}");

/***/ },

/***/ "./src/occapi/operatorCache.ts"
/*!*************************************!*\
  !*** ./src/occapi/operatorCache.ts ***!
  \*************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand_operator: () => (/* binding */ expand_operator),\n/* harmony export */   operatorCache: () => (/* binding */ operatorCache),\n/* harmony export */   shape_meta_data: () => (/* binding */ shape_meta_data)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"./src/utils.ts\");\n\n\nconst SHAPE_CACHE = new Map();\nconst PRIMITIVE_OPERATORS = [\n    'Part::Box',\n    'Part::Cylinder',\n    'Part::Sphere',\n    'Part::Cone',\n    'Part::Torus'\n];\nconst BOOLEAN_OPERATORS = [\n    'Part::Cut',\n    'Part::MultiFuse',\n    'Part::Extrusion',\n    'Part::MultiCommon',\n    'Part::Chamfer',\n    'Part::Fillet'\n];\nconst MISC_OPERATORS = [\n    'ObjectFile',\n    'Sketcher::SketchObject',\n    'Part::Any'\n];\nfunction expand_operator(name, args, content) {\n    const expanded_args = {};\n    if (PRIMITIVE_OPERATORS.includes(name)) {\n        expanded_args[name] = args;\n    }\n    else if (BOOLEAN_OPERATORS.includes(name)) {\n        switch (name) {\n            case 'Part::Cut': {\n                const expandedArgs = JSON.parse(JSON.stringify(args));\n                const { Base, Tool } = expandedArgs;\n                const baseData = content.objects.filter(item => item.name === Base);\n                const toolData = content.objects.filter(item => item.name === Tool);\n                if (baseData.length > 0) {\n                    expandedArgs.Base = expand_operator(baseData[0].shape, baseData[0].parameters, content);\n                }\n                if (toolData.length > 0) {\n                    expandedArgs.Tool = expand_operator(toolData[0].shape, toolData[0].parameters, content);\n                }\n                expanded_args[name] = expandedArgs;\n                break;\n            }\n            case 'Part::Extrusion':\n            case 'Part::Fillet':\n            case 'Part::Chamfer': {\n                const expandedArgs = JSON.parse(JSON.stringify(args));\n                const { Base } = expandedArgs;\n                const baseData = content.objects.filter(item => item.name === Base);\n                if (baseData.length > 0) {\n                    expandedArgs.Base = expand_operator(baseData[0].shape, baseData[0].parameters, content);\n                }\n                expanded_args[name] = expandedArgs;\n                break;\n            }\n            case 'Part::MultiCommon':\n            case 'Part::MultiFuse': {\n                const expandedArgs = JSON.parse(JSON.stringify(args));\n                const { Shapes } = expandedArgs;\n                const newShapes = [];\n                Shapes.forEach(element => {\n                    const elementData = content.objects.filter(item => item.name === element);\n                    if (elementData.length > 0) {\n                        newShapes.push(expand_operator(elementData[0].shape, elementData[0].parameters, content));\n                    }\n                });\n                expandedArgs.Shapes = newShapes;\n                expanded_args[name] = expandedArgs;\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    else if (MISC_OPERATORS.includes(name)) {\n        expanded_args[name] = args;\n    }\n    else {\n        expanded_args[name] = args;\n    }\n    return expanded_args;\n}\nfunction shape_meta_data(shape) {\n    const occ = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const system = new occ.GProp_GProps_1();\n    occ.BRepGProp.VolumeProperties_1(shape, system, false, false, false);\n    const mass = system.Mass();\n    const centerOfMass = system.CentreOfMass();\n    const matrixOfInertia = system.MatrixOfInertia();\n    return {\n        mass,\n        centerOfMass: [centerOfMass.X(), centerOfMass.Y(), centerOfMass.Z()],\n        matrixOfInertia: [\n            [\n                matrixOfInertia.Row(0).X(),\n                matrixOfInertia.Row(0).Y(),\n                matrixOfInertia.Row(0).Z()\n            ],\n            [\n                matrixOfInertia.Row(1).X(),\n                matrixOfInertia.Row(1).Y(),\n                matrixOfInertia.Row(1).Z()\n            ],\n            [\n                matrixOfInertia.Row(2).X(),\n                matrixOfInertia.Row(2).Y(),\n                matrixOfInertia.Row(2).Z()\n            ]\n        ]\n    };\n}\nfunction operatorCache(name, ops) {\n    return (args, content) => {\n        const expandedArgs = expand_operator(name, args, content);\n        const hash = `${(0,_utils__WEBPACK_IMPORTED_MODULE_1__.hashCode)(JSON.stringify(expandedArgs))}`;\n        if (SHAPE_CACHE.has(hash)) {\n            return SHAPE_CACHE.get(hash);\n        }\n        else {\n            const occShape = ops(args, content);\n            if (occShape) {\n                const cacheData = {\n                    occShape,\n                    metadata: shape_meta_data(occShape)\n                };\n                SHAPE_CACHE.set(hash, cacheData);\n                return cacheData;\n            }\n        }\n    };\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/operatorCache.ts?\n}");

/***/ },

/***/ "./src/occapi/postOperator.ts"
/*!************************************!*\
  !*** ./src/occapi/postOperator.ts ***!
  \************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _PostOperator: () => (/* binding */ _PostOperator)\n/* harmony export */ });\n/* harmony import */ var _brepIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./brepIO */ \"./src/occapi/brepIO.ts\");\n/* harmony import */ var _stlIO__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stlIO */ \"./src/occapi/stlIO.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\n\nfunction _PostOperator(arg, content) {\n    var _a;\n    const baseObject = content.objects.filter(obj => obj.name === arg.Object);\n    if (baseObject.length === 0) {\n        return { postShape: '' };\n    }\n    const shapesFactory = (0,_common__WEBPACK_IMPORTED_MODULE_2__.getShapesFactory)();\n    const baseShape = baseObject[0].shape;\n    if (baseShape && shapesFactory[baseShape]) {\n        const base = (_a = shapesFactory[baseShape]) === null || _a === void 0 ? void 0 : _a.call(shapesFactory, baseObject[0].parameters, content);\n        if (base === null || base === void 0 ? void 0 : base.occShape) {\n            let postShape = '';\n            if (arg.Type === 'BREP') {\n                postShape = (0,_brepIO__WEBPACK_IMPORTED_MODULE_0__._writeBrep)(base.occShape);\n            }\n            else if (arg.Type === 'STL') {\n                postShape = (0,_stlIO__WEBPACK_IMPORTED_MODULE_1__._writeStlFile)(base.occShape, arg.LinearDeflection, arg.AngularDeflection);\n            }\n            return { postShape };\n        }\n    }\n    return { postShape: '' };\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/postOperator.ts?\n}");

/***/ },

/***/ "./src/occapi/sketchObject.ts"
/*!************************************!*\
  !*** ./src/occapi/sketchObject.ts ***!
  \************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _SketchObject: () => (/* binding */ _SketchObject)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n/* harmony import */ var _geomCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geomCircle */ \"./src/occapi/geomCircle.ts\");\n/* harmony import */ var _geomLineSegment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geomLineSegment */ \"./src/occapi/geomLineSegment.ts\");\n\n\n\nfunction _SketchObject(arg, content) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const builder = new oc.BRep_Builder();\n    const compound = new oc.TopoDS_Compound();\n    if (arg.Geometry.length === 0) {\n        return undefined;\n    }\n    builder.MakeCompound(compound);\n    for (const geom of arg.Geometry) {\n        switch (geom.TypeId) {\n            case 'Part::GeomCircle':\n                builder.Add(compound, (0,_geomCircle__WEBPACK_IMPORTED_MODULE_1__._GeomCircle)(geom));\n                break;\n            case 'Part::GeomLineSegment': {\n                builder.Add(compound, (0,_geomLineSegment__WEBPACK_IMPORTED_MODULE_2__._GeomLine)(geom));\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    return compound;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/sketchObject.ts?\n}");

/***/ },

/***/ "./src/occapi/sphere.ts"
/*!******************************!*\
  !*** ./src/occapi/sphere.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Sphere: () => (/* binding */ _Sphere)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Sphere(arg, _) {\n    const { Radius, Angle1, Angle2, Angle3, Placement } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const sphere = new oc.BRepPrimAPI_MakeSphere_4(Radius, (0,_common__WEBPACK_IMPORTED_MODULE_0__.toRad)(Angle1), (0,_common__WEBPACK_IMPORTED_MODULE_0__.toRad)(Angle2), (0,_common__WEBPACK_IMPORTED_MODULE_0__.toRad)(Angle3));\n    const shape = sphere.Shape();\n    return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(shape, Placement);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/sphere.ts?\n}");

/***/ },

/***/ "./src/occapi/stepIO.ts"
/*!******************************!*\
  !*** ./src/occapi/stepIO.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _loadStepFile: () => (/* binding */ _loadStepFile)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"../../node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _loadStepFile(content) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getOcc)();\n    const fakeFileName = `${(0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}.STEP`;\n    oc.FS.createDataFile('/', fakeFileName, content, true, true, true);\n    const reader = new oc.STEPControl_Reader_1();\n    const readResult = reader.ReadFile(fakeFileName);\n    if (readResult === oc.IFSelect_ReturnStatus.IFSelect_RetDone) {\n        reader.TransferRoots(new oc.Message_ProgressRange_1());\n        const shape = reader.OneShape();\n        oc.FS.unlink('/' + fakeFileName);\n        return shape;\n    }\n    else {\n        console.error('Something in OCCT went wrong trying to read');\n        return undefined;\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/stepIO.ts?\n}");

/***/ },

/***/ "./src/occapi/stlIO.ts"
/*!*****************************!*\
  !*** ./src/occapi/stlIO.ts ***!
  \*****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _loadStlFile: () => (/* binding */ _loadStlFile),\n/* harmony export */   _writeStlFile: () => (/* binding */ _writeStlFile)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"../../node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n/* harmony import */ var _makeShapeFromMesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./makeShapeFromMesh */ \"./src/occapi/makeShapeFromMesh.ts\");\n\n\n\nfunction _loadStlFile(content) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getOcc)();\n    const fakeFileName = `${(0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}.STL`;\n    oc.FS.createDataFile('/', fakeFileName, content, true, true, true);\n    const readResult = oc.RWStl.ReadFile_2(fakeFileName, new oc.Message_ProgressRange_1());\n    const shape = (0,_makeShapeFromMesh__WEBPACK_IMPORTED_MODULE_2__.makeShapeFromMesh)(readResult);\n    if (shape) {\n        return shape;\n    }\n    else {\n        console.error('Something in OCCT went wrong trying to read');\n        return undefined;\n    }\n}\nfunction _writeStlFile(shape, linearDeflection = 0.1, angularDeflection = 0.5) {\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getOcc)();\n    new oc.BRepMesh_IncrementalMesh_2(shape, linearDeflection, false, angularDeflection, true);\n    const writer = new oc.StlAPI_Writer();\n    const progress = new oc.Message_ProgressRange_1();\n    const fakeFileName = `${(0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}.stl`;\n    try {\n        const success = writer.Write(shape, fakeFileName, progress);\n        if (!success) {\n            throw new Error('StlAPI_Writer failed to write the file.');\n        }\n        const stlContent = oc.FS.readFile(fakeFileName, {\n            encoding: 'utf8'\n        });\n        return stlContent;\n    }\n    finally {\n        if (oc.FS.analyzePath(fakeFileName).exists) {\n            oc.FS.unlink(fakeFileName);\n        }\n        writer.delete();\n        progress.delete();\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/stlIO.ts?\n}");

/***/ },

/***/ "./src/occapi/torus.ts"
/*!*****************************!*\
  !*** ./src/occapi/torus.ts ***!
  \*****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Torus: () => (/* binding */ _Torus)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/occapi/common.ts\");\n\n\nfunction _Torus(arg, _) {\n    const { Radius1, Radius2, Angle1, Angle2, Angle3, Placement } = arg;\n    const oc = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getOcc)();\n    const torus = new oc.BRepPrimAPI_MakeTorus_4(Radius1, Radius2, (0,_common__WEBPACK_IMPORTED_MODULE_0__.toRad)(Angle1), (0,_common__WEBPACK_IMPORTED_MODULE_0__.toRad)(Angle2), (0,_common__WEBPACK_IMPORTED_MODULE_0__.toRad)(Angle3));\n    const shape = torus.Shape();\n    return (0,_common__WEBPACK_IMPORTED_MODULE_0__.setShapePlacement)(shape, Placement);\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occapi/torus.ts?\n}");

/***/ },

/***/ "./src/occparser.ts"
/*!**************************!*\
  !*** ./src/occparser.ts ***!
  \**************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OccParser: () => (/* binding */ OccParser)\n/* harmony export */ });\nclass OccParser {\n    constructor(shapeList) {\n        this._occ = self.occ;\n        this._shapeList = shapeList;\n    }\n    execute(raiseOnFailure = false) {\n        const maxDeviation = 0.1;\n        const threejsData = {};\n        this._shapeList.forEach(data => {\n            const { shapeData, jcObject } = data;\n            const { occShape, metadata } = shapeData;\n            if (!occShape) {\n                if (raiseOnFailure) {\n                    throw Error('Unknown failure');\n                }\n                else {\n                    return;\n                }\n            }\n            new this._occ.BRepMesh_IncrementalMesh_2(occShape, maxDeviation, false, maxDeviation * 5, true);\n            const faceList = this._build_face_mesh(occShape);\n            let edgeList = [];\n            if (this._shouldComputeEdge(jcObject)) {\n                edgeList = this._build_edge_mesh(occShape);\n            }\n            let wireList = [];\n            if (this._shouldComputeWire(jcObject)) {\n                //Only compute the wire mesh for 2d geometries\n                wireList = this._build_wire_mesh(occShape, maxDeviation);\n            }\n            threejsData[jcObject.name] = {\n                jcObject,\n                faceList,\n                edgeList: [...edgeList, ...wireList],\n                meta: metadata\n            };\n        });\n        return threejsData;\n    }\n    _shouldComputeEdge(obj) {\n        var _a;\n        if (obj.shape === 'Part::Any' && ((_a = obj.parameters) === null || _a === void 0 ? void 0 : _a.Type) === 'STL') {\n            return false;\n        }\n        return true;\n    }\n    _shouldComputeWire(obj) {\n        if (obj.shape === 'Sketcher::SketchObject') {\n            return true;\n        }\n        return false;\n    }\n    _build_wire_mesh(shape, maxDeviation) {\n        const edgeList = [];\n        const oc = this._occ;\n        const expl = new oc.TopExp_Explorer_2(shape, oc.TopAbs_ShapeEnum.TopAbs_EDGE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);\n        expl.Init(shape, oc.TopAbs_ShapeEnum.TopAbs_EDGE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);\n        while (expl.More()) {\n            const edge = oc.TopoDS.Edge_1(expl.Current());\n            const aLocation = new oc.TopLoc_Location_1();\n            const adaptorCurve = new oc.BRepAdaptor_Curve_2(edge);\n            const tangDef = new oc.GCPnts_TangentialDeflection_2(adaptorCurve, maxDeviation, 0.1, 2, 1.0e-9, 1.0e-7);\n            const vertexCoord = new Array(tangDef.NbPoints() * 3);\n            for (let j = 0; j < tangDef.NbPoints(); j++) {\n                const vertex = tangDef\n                    .Value(j + 1)\n                    .Transformed(aLocation.Transformation());\n                vertexCoord[j * 3 + 0] = vertex.X();\n                vertexCoord[j * 3 + 1] = vertex.Y();\n                vertexCoord[j * 3 + 2] = vertex.Z();\n            }\n            edgeList.push({ vertexCoord, numberOfCoords: tangDef.NbPoints() * 3 });\n            expl.Next();\n        }\n        return edgeList;\n    }\n    _build_face_mesh(shape) {\n        const faceList = [];\n        const triangulations = [];\n        const oc = this._occ;\n        const expl = new oc.TopExp_Explorer_2(shape, oc.TopAbs_ShapeEnum.TopAbs_FACE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);\n        expl.Init(shape, oc.TopAbs_ShapeEnum.TopAbs_FACE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);\n        while (expl.More()) {\n            const face = oc.TopoDS.Face_1(expl.Current());\n            const aLocation = new oc.TopLoc_Location_1();\n            const myT = oc.BRep_Tool.Triangulation(face, aLocation, 0);\n            if (myT.IsNull()) {\n                console.error('Encountered Null Face!');\n                expl.Next();\n                continue;\n            }\n            const thisFace = {\n                vertexCoord: [],\n                triIndexes: [],\n                numberOfTriangles: 0\n            };\n            const triangulation = myT.get();\n            const nbNodes = triangulation.NbNodes();\n            thisFace.vertexCoord = new Array(nbNodes * 3);\n            for (let i = 0; i < nbNodes; i++) {\n                const p = triangulation\n                    .Node(i + 1)\n                    .Transformed(aLocation.Transformation());\n                thisFace.vertexCoord[i * 3 + 0] = p.X();\n                thisFace.vertexCoord[i * 3 + 1] = p.Y();\n                thisFace.vertexCoord[i * 3 + 2] = p.Z();\n            }\n            const orient = face.Orientation_1();\n            const nbTriangles = triangulation.NbTriangles();\n            // Write triangle buffer\n            thisFace.triIndexes = new Array(nbTriangles * 3);\n            let validFaceTriCount = 0;\n            for (let nt = 1; nt <= myT.get().NbTriangles(); nt++) {\n                const t = triangulation.Triangle(nt);\n                let n1 = t.Value(1);\n                let n2 = t.Value(2);\n                const n3 = t.Value(3);\n                if (orient !== oc.TopAbs_Orientation.TopAbs_FORWARD) {\n                    const tmp = n1;\n                    n1 = n2;\n                    n2 = tmp;\n                }\n                thisFace.triIndexes[validFaceTriCount * 3 + 0] = n1 - 1;\n                thisFace.triIndexes[validFaceTriCount * 3 + 1] = n2 - 1;\n                thisFace.triIndexes[validFaceTriCount * 3 + 2] = n3 - 1;\n                validFaceTriCount++;\n            }\n            thisFace.numberOfTriangles = validFaceTriCount;\n            faceList.push(thisFace);\n            triangulations.push(myT);\n            expl.Next();\n        }\n        return faceList;\n    }\n    _build_edge_mesh(shape) {\n        const oc = this._occ;\n        const edgeList = [];\n        const mapOfShape = new oc.TopTools_IndexedMapOfShape_1();\n        oc.TopExp.MapShapes_1(shape, oc.TopAbs_ShapeEnum.TopAbs_EDGE, mapOfShape);\n        const edgeMap = new oc.TopTools_IndexedDataMapOfShapeListOfShape_1();\n        oc.TopExp.MapShapesAndAncestors(shape, oc.TopAbs_ShapeEnum.TopAbs_EDGE, oc.TopAbs_ShapeEnum.TopAbs_FACE, edgeMap);\n        for (let iEdge = 1; iEdge <= edgeMap.Extent(); iEdge++) {\n            const faceList = edgeMap.FindFromIndex(iEdge);\n            if (faceList.Extent() === 0) {\n                continue;\n            }\n            const anEdge = oc.TopoDS.Edge_1(mapOfShape.FindKey(iEdge));\n            let myTransf = new oc.gp_Trsf_1();\n            const aLoc = new oc.TopLoc_Location_1();\n            const aPoly = oc.BRep_Tool.Polygon3D(anEdge, aLoc);\n            const theEdge = {\n                vertexCoord: [],\n                numberOfCoords: 0\n            };\n            let nbNodesInFace;\n            if (!aPoly.IsNull()) {\n                if (!aLoc.IsIdentity()) {\n                    myTransf = aLoc.Transformation();\n                }\n                const poly = aPoly.get();\n                nbNodesInFace = poly.NbNodes();\n                theEdge.numberOfCoords = nbNodesInFace;\n                theEdge.vertexCoord = new Array(nbNodesInFace * 3);\n                const nodeListOfEdge = aPoly.get().Nodes();\n                for (let ii = 0; ii < nbNodesInFace; ii++) {\n                    const V = nodeListOfEdge.Value(ii + 1);\n                    V.Transform(myTransf);\n                    theEdge.vertexCoord[ii * 3 + 0] = V.X();\n                    theEdge.vertexCoord[ii * 3 + 1] = V.Y();\n                    theEdge.vertexCoord[ii * 3 + 2] = V.Z();\n                }\n            }\n            else {\n                const aFace = oc.TopoDS.Face_1(edgeMap.FindFromIndex(iEdge).First_1());\n                const aPolyTria = oc.BRep_Tool.Triangulation(aFace, aLoc, 0);\n                if (!aLoc.IsIdentity()) {\n                    myTransf = aLoc.Transformation();\n                }\n                const aPoly = oc.BRep_Tool.PolygonOnTriangulation_1(anEdge, aPolyTria, aLoc);\n                if (aPoly.IsNull()) {\n                    continue;\n                }\n                nbNodesInFace = aPoly.get().NbNodes();\n                theEdge.numberOfCoords = nbNodesInFace;\n                theEdge.vertexCoord = new Array(nbNodesInFace * 3);\n                const indices = aPoly.get().Nodes();\n                const nodeListOfFace = aPolyTria.get();\n                for (let jj = indices.Lower(); jj <= indices.Upper(); jj++) {\n                    const v = nodeListOfFace.Node(indices.Value(jj));\n                    v.Transform(myTransf);\n                    const locIndex = jj - 1;\n                    theEdge.vertexCoord[locIndex * 3 + 0] = v.X();\n                    theEdge.vertexCoord[locIndex * 3 + 1] = v.Y();\n                    theEdge.vertexCoord[locIndex * 3 + 2] = v.Z();\n                }\n            }\n            edgeList.push(theEdge);\n        }\n        return edgeList;\n    }\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/occparser.ts?\n}");

/***/ },

/***/ "./src/utils.ts"
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashCode: () => (/* binding */ hashCode)\n/* harmony export */ });\nfunction hashCode(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash;\n    }\n    return hash;\n}\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/utils.ts?\n}");

/***/ },

/***/ "./src/worker.ts"
/*!***********************!*\
  !*** ./src/worker.ts ***!
  \***********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _jupytercad_opencascade__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupytercad/opencascade */ \"../opencascade/lib/index.js\");\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions */ \"./src/actions.ts\");\n/* harmony import */ var _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupytercad/schema */ \"../schema/lib/index.js\");\n/* harmony import */ var _occapi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./occapi */ \"./src/occapi/index.ts\");\n\n\n\n\nlet occ;\nconst ports = {};\nconsole.log('Initializing OCC...');\n(0,_jupytercad_opencascade__WEBPACK_IMPORTED_MODULE_0__.initializeOpenCascade)().then(occInstance => {\n    console.log('Done!');\n    occ = occInstance;\n    self.occ = occ;\n    (0,_occapi__WEBPACK_IMPORTED_MODULE_3__.initShapesFactory)();\n    for (const id of Object.keys(ports)) {\n        sendToMain({ action: _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.MainAction.INITIALIZED, payload: false }, id);\n    }\n});\nconst registerWorker = async (id, port) => {\n    ports[id] = port;\n    if (occ) {\n        sendToMain({ action: _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.MainAction.INITIALIZED, payload: false }, id);\n    }\n};\nconst sendToMain = (msg, id) => {\n    if (id in ports) {\n        ports[id].postMessage(msg);\n    }\n};\nself.onmessage = async (event) => {\n    var _a;\n    const message = event.data;\n    const { id } = message;\n    switch (message.action) {\n        case _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.WorkerAction.REGISTER: {\n            const port = event.ports[0];\n            await registerWorker(id, port);\n            break;\n        }\n        case _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.WorkerAction.LOAD_FILE: {\n            const result = _actions__WEBPACK_IMPORTED_MODULE_1__[\"default\"][message.action](message.payload);\n            sendToMain({\n                action: _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.MainAction.DISPLAY_SHAPE,\n                payload: result\n            }, id);\n            break;\n        }\n        case _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.WorkerAction.DRY_RUN: {\n            let response = {};\n            try {\n                response = _actions__WEBPACK_IMPORTED_MODULE_1__[\"default\"][_jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.WorkerAction.DRY_RUN](message.payload);\n            }\n            catch (e) {\n                let msg = '';\n                if (typeof e === 'string') {\n                    msg = e;\n                }\n                else if (e instanceof Error) {\n                    msg = e.message;\n                }\n                sendToMain({\n                    action: _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.MainAction.DRY_RUN_RESPONSE,\n                    payload: {\n                        id: message.payload.id,\n                        status: 'error',\n                        message: msg\n                    }\n                }, id);\n                return;\n            }\n            const shapeMetadata = {};\n            Object.entries((_a = response.result) !== null && _a !== void 0 ? _a : {}).forEach(([objName, data]) => {\n                shapeMetadata[objName] = data === null || data === void 0 ? void 0 : data['meta'];\n            });\n            sendToMain({\n                action: _jupytercad_schema__WEBPACK_IMPORTED_MODULE_2__.MainAction.DRY_RUN_RESPONSE,\n                payload: {\n                    id: message.payload.id,\n                    status: 'ok',\n                    shapeMetadata\n                }\n            }, id);\n            break;\n        }\n    }\n};\n\n\n//# sourceURL=webpack://@jupytercad/occ-worker/./src/worker.ts?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/worker.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});;